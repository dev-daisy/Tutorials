<!doctype html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-style-type" content="text/css2"><title>Course Transcript</title><link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css"><style>:root {
    --title-text: #243038;
    --toc-link: #0073C4;
    --section-title-text: #243038;
    --section-title-border: #bababa;
    --grid-caption-text: #164794;
    --grid-border: #c0c0c0;
    --grid-hdr-text: #973131;
    --grid-hdr-background: #f7f7f7;
    --missing-data: #767676;
    --text-color: #343434;
    --lightbox-border: #a0a0a0;

    --bold-font-weight: 700;

    font-family: Lato;
}

.report {
    margin: 24px;
}

.container {
    position: relative;
}

#lb-curtain {
    background-color: white;
    opacity: 1.0;
}

#lb-overlay {
    position: absolute;
    top: 40px;
    left: 20px;
    right: 20px;
    background-color: white;
    border: solid 1px var(--lightbox-border);
    visibility: hidden;
}

.lb-header, .lb-footer {
    height: 40px;
    line-height: 40px;
}

.lb-header {
    display: flex;
    justify-content: flex-end;
    padding-right: 20px;
}

#lb-image-container {
    margin: 0 40px;
}

#lb-image {
    width: 100%;
}

.report_title {
    font-size: 22px;
    font-weight: var(--bold-font-weight);
    color: var(--title-text);
}

.toc_link {
    font-size: 14px;
    color: var(--toc-link);
    margin-top: 6px;
    margin-bottom: 0;
}

.section {
    margin-top: 40px;
    margin-left: 16px;
}

.section.inner {
    margin-top: 20px;
}

.section.inline {
    margin-top: 20px;
    margin-left: 0;
}

.section_title {
    font-size: 18px;
    font-weight: var(--bold-font-weight);
    width: 100%;
    color: var(--section-title-text);
}

h2.section_title {
    border-bottom-color: var(--section-title-border);
    border-bottom-style: solid;
    border-bottom-width: thin;
}

h3.section_title {
    margin: 8px 0;
}

h3.list_title {
    margin: 8px 0;
    font-size: 14px;
    color: var(--title-text);
}

.section_text {
    font-size: 14px;
    color: var(--text-color);
    margin: 12px 0;
    width: 90%;
}

.section_link {
    font-size: 14px;
    margin: 12px 0;
    width: 90%;
}

.grid {
    border-collapse: collapse;
}
.grid_caption {
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    color: var(--grid-caption-text);
    margin: 12px 0;
    text-align: left;
    white-space: nowrap;
}
.grid_hdr_row {

}
.grid_col {
    font-size: 13px;
    color: var(--text-color);
    border-collapse: collapse;
    padding: 2px;
    text-align: left;
    vertical-align: top;
}
.grid_col_hdr, .grid_row_hdr {
    font-size: 12px;
    font-weight: var(--bold-font-weight);
    white-space: nowrap;
}
.grid_row_hdr {

}

.empty_grid {
    border-collapse: collapse;
    border-color: var(--grid-border);
    border-style: solid;
    border-width: 2px;
    padding: 4px;
    text-align: center;
}

.htmlbox {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    padding: 8px;
}

.list {
    font-size: 14px;
    font-style: italic;
}

.missing_data {
    color: var(--missing-data);
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    font-style: italic;
}

.copyright-container {
    margin-top: 24px;
    text-align: center;
}
.copyright-text {
    color: var(--text-color);
    font-size: 12px;
}

/* Transcript Questions CSS */

.question {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    display: flex;
    flex-direction: column;
    padding: 8px;
}

.question_content {
    display: flex;
    justify-content: space-between;
}

.question_details {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.question_images {
    display: flex;
    flex-direction: column;
    margin-left: 16px;
}

.question_image {
    margin-bottom: 8px;
}

.question_title {
    font-weight: var(--bold-font-weight);
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
    padding-bottom: 8px;
    margin-bottom: 8px;
}

.question_label, .question_stem {
    font-weight: var(--bold-font-weight);
    margin-top: 8px;
    margin-bottom: 8px;
}

.question_data_row {
    display: flex;
}

.question_data_col1 {
    padding: 8px;
    white-space: nowrap;
}

.question_data_col2 {
    padding: 8px;
    display: flex;
    flex-direction: column;
}

.question_answer_key {
    margin-top: 8px;
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
}

.feedback {
    font-style: italic;
}
</style></head><body class="report"><div class="container"><div class="content" id="lb-curtain"><h1 class="report_title">Java Certified Foundations Associate: Java Debugging & Exceptions</h1><div class="section_text">Sometimes the unexpected happens in your Java code and you will need to figure out what broke and how to fix it. In this course, you will learn how to handle exceptions and how to debug your Java code.

First, you will learn how to debug your code using the Java JDB tool as well as using IntelliJ. Next, you will learn the best practice for debugging Java code and some common syntax and logic errors that you may encounter and methods for fixing these errors. Finally, you will learn how to handle exceptions in your code using the try catch block statements.

This course is one of a collection of courses that prepares learners for Oracle’s 1Z0-811: Java Certified Foundations Associate certification.</div><div class="section"><h2 class="section_title">Table of Contents</h2><div class="toc"><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_0">1. Video: Course Overview (it_sdjcfa_13_enus_01)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_1">2. Video: Java Debugging with JDB (it_sdjcfa_13_enus_02)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_2">3. Video: Debugging Using the Java JDB Tool (it_sdjcfa_13_enus_03)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_3">4. Video: Java Debugging with IntelliJ (it_sdjcfa_13_enus_04)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_4">5. Video: Debugging Code Using IntelliJ (it_sdjcfa_13_enus_05)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_5">6. Video: Java Debugging Best Practices (it_sdjcfa_13_enus_06)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_6">7. Video: Java Syntax and Logic Errors (it_sdjcfa_13_enus_07)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_7">8. Video: Java Exception Handling (it_sdjcfa_13_enus_08)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_8">9. Video: Demonstrating Java Exception Handling (it_sdjcfa_13_enus_09)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_9">10. Video: Common Java Exceptions (it_sdjcfa_13_enus_10)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_10">11. Video: Demonstrating Common Java Exceptions ( it_sdjcfa_13_enus_11)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_11">12. Video: Java Try Catch Blocks ( it_sdjcfa_13_enus_12)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_12">13. Video: Demonstrating Java Try Catch Blocks ( it_sdjcfa_13_enus_13)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_13">14. Video: Course Summary ( it_sdjcfa_13_enus_14)</a></p></div></div><div class="section"><a name="section_0" /><h2 class="section_title">1. Video: Course Overview (it_sdjcfa_13_enus_01)</h2><img src="https://cdn2.percipio.com/public/b/9f6f4e93-d92f-4874-867c-7cd3ca518ef2/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/9f6f4e93-d92f-4874-867c-7cd3ca518ef2/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about the instructor and the course. You’ll learn how to handle exceptions and debug your Java code. First, you&#39;ll debug code using the Java JDB tool, as well as using IntelliJ. Next, you’ll learn best practices for debugging Java code and some common syntax and logic errors you may encounter. You’ll learn methods for fixing these errors and you’ll explore how to handle code exceptions using Try-catch block statements.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">discover the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Overview.</em> [Video description ends]
<p>Hi, I&#39;m Steve Scott. I&#39;ve been a software developer and tech consultant for almost a quarter of a century. <br /><br />[Video description begins] <em>Your host for this session is Steve Scott. He is an IT Consultant.</em> [Video description ends] <br /><br />I&#39;ve traveled around the globe to serve clients where I&#39;ve been responsible for building secure systems, hiring development teams, and solving complex problems through technology. With my toolbox of languages, platforms, frameworks, and APIs, I round out my technical experience with an academic background in mathematics and computer science. Oracle&#39;s 1Z0-811 Java Certified Foundations Associate Certification is targeted to audiences seeking foundational knowledge of the Java programming language and concepts.</p>
<p>Individuals tackling this certification will demonstrate they can write and execute a Java program, work with the Java Development Kit(JDK), and the Java Runtime Environment (JRE). Sometimes the unexpected happens in your Java code and you&#39;ll need to figure out what broke and how to fix it. In this course, you&#39;ll learn how to handle exceptions and debug your Java code. First, I&#39;ll debug code using the Java JDB tool, as well as using IntelliJ. Next, I&#39;ll discuss best practices for debugging Java code. And some common syntax and logic errors that you may encounter, and methods for fixing these errors.</p>
<p>Finally, I&#39;ll explore how to handle exceptions in your code using the Try-catch block statements.</p></div></div></div><div class="section"><a name="section_1" /><h2 class="section_title">2. Video: Java Debugging with JDB (it_sdjcfa_13_enus_02)</h2><img src="https://cdn2.percipio.com/public/b/43aa8264-dda7-472f-9637-a29853babe0c/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/43aa8264-dda7-472f-9637-a29853babe0c/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about debugging code using the Java JDB tool. You’ll start with the Java Platform Debugger Architecture, the JPDA. This allows for the implementation of debugging tools for Java remotely, in a cross-platform. It provides a reference implementation and a modular architecture for debugging Java. The JDI, or Java Debug Interface, is implemented so that debugger clients, IDEs, tracers, and monitoring tools can connect to the debugger architecture.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe how to debug code using the Java JDB tool</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Debugging with JDB. Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll present an overview of how to debug code using the Java JDB tool. So we&#39;ll start with the Java Platform Debugger Architecture, the JPDA. This allows for the implementation of debugging tools for Java in a cross platform and remote fashion. It provides a reference implementation and a modular architecture for debugging Java. The JDI, or Java Debug Interface, is implemented so that debugger clients, IDEs, tracers, and monitoring tools can connect to the debugger architecture. Once inside of Java debugging, whether from the command line or from an IDE, it&#39;s essential for Java to open up the tools to micromanage execution. This is done through stepping one line at a time and choosing whether to step into a function or step over it, getting the result while continuing the line by line fashion of the current method.</p>
<p>Setting breakpoints and running code until a particular line or function is reached. And allowing for the analysis of the current state of the program and variables when an exception is thrown. What are some of the common debugging methods? Well, we can attach to a specified class. We can use comments in the program source code that can help identify expected behavior so that you can test and work towards what&#39;s defined. You can debug code directly. You can debug on demand through the use of breakpoints. You can debug the Java bytecode, debugging the compiled Java directly as you would do for machine code in compiled languages. You can debug in the JVM language. And remote debugging, so attaching to a running program indirectly through a service, hook, or API.</p>
<p>How do we do this with Java debuggers? Well, we can do it through the command line debugger, the JDB. Through Notepad or VI, where you focus on the output of stack traces or exception information when a program crashes or throws an exception. Using IDEs such as IntelliJ or Eclipse, using their built-in debugging tools. And you can use another standalone debugger, a non-JDB or non-IDE, such as the Java Platform Debugger. So how do we handle JDB in the Java Development Kit? Well, we have the Java Virtual Machine Tool Interface, or JVMTI. This allows for the JVM to provide inspection and debugging of the running state of a Java application. Then through the Java Debug Wiring Pool, or JDWP, this is the backend debugging process. And the JDI, or Java Debugger Interface, sits on top of the JDWP to facilitate communication with the JVM for debugging.</p>
<p>Java debugging with JDB doesn&#39;t require any special installations. However, you should verify the Java installation, including the JDK and JVM versions. Especially if you&#39;re running the debugger outside of your development environment, perhaps on a staging server or pre-production environment. Setting up the Java environment by making sure paths and environment variables are set, such as Java home. And verifying the JDB installation directly, just by running JDB. Now what&#39;s the syntax for the JDB from the command line? Well, there&#39;s the JDB command itself, which we execute by running jdb in lowercase as the command. And the options follow that, such as the class path, the hyphen x, hyphen d, attach, launch, or other common options. The class name we want to debug, and the arguments for passing to the program, that is the string args passed into the main entry point into our Java application.</p>
<p>So the options with the JDB command, what are they? Well, we have the help command to get details on the JDB command itself. The attach command to attach to the JVM by address. The listenany command to connect to the VM using any address. The tclient and tserver for the Java HotSpot VM client and server. So in a Java JDB session, we add it to a class or attach to a class, and we add it to the running JVM. So this is what facilitates our JDB session. And we can get information, pause the program, set breakpoints, and step into and over our code. How do we do this with the JDB basic commands? Well, inside of JDB once JDB is running, we can use help or question mark to pull up the basic commands for JDB.</p>
<p>The main ones include the run command to start execution and specify a class name with the entry point and program arguments. The cont or a continue command to continue execution from a break point when the program is paused. The print command to print the value from an expression. The dump command to print all object information. The threads command to list the running threads. And thread to set the default thread. And where to dump a thread stack. And that concludes this presentation on Java debugging with JDB.</p></div></div></div><div class="section"><a name="section_2" /><h2 class="section_title">3. Video: Debugging Using the Java JDB Tool (it_sdjcfa_13_enus_03)</h2><img src="https://cdn2.percipio.com/public/b/a24a8774-154e-446c-89cd-951972bf88b2/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/a24a8774-154e-446c-89cd-951972bf88b2/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. In this demo, you’ll learn how to debug code using the Java JDB Tool. From a terminal window you’ll use the terminal client built into IntelliJ. You can run the JDB command as seen onscreen. You’ll run IntelliJ from the terminal window, but you can do this from any shell client or terminal window.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">debug code using the Java JDB tool</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Debugging Using the Java JDB Tool. Your host for this session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll demonstrate how to debug code using the Java JDB Tool. From a terminal window, in this case, I&#39;m using the terminal client built into IntelliJ. I can run the JDB command of my example Java code here in debug demo. I&#39;m running this from IntelliJ from the terminal window, but I can do this from any shell client or terminal window. The terminal window built into IntelliJ makes it convenient because I can display the code just above, and take you through the code, and run JDB to run this program from the command line. And we can use the debug commands, just step through it line by line. <br /><br />[Video description begins] <em>The IntelliJ IDEA window titled, DebugDemo - Main.java appears on the screen. Currently, the Main.java file is opened and displays various lines of code.</em> [Video description ends] <br /><br />So this Main.java file starts with package com.example, then public class Main for the main class declaration. And this class has two methods, handleString and the main entry point into our application, the main method.</p>
<p>So we&#39;ll start with handleString on line 5. It&#39;s declared public static boolean handleString, and it declares the parameter String str. It checks if string is equal to null, or str.length is equal to 0. And if it is, so if it&#39;s empty or a length of nothing, it&#39;ll call System.out.println with the string, the string is not ok and return false. And then outside of the if block, so if the if statement does not succeed, it continues executing, calling System.out.println, The string is ok!, return true. Then main is declared on line 14, public static void main with String[] args. I&#39;m going to use two arguments. The first argument is expected to be a number and integer, and the second is string. So on line 15, I have int i &#61; Integer.parseInt of args[0] and String A &#61; args[1].</p>
<p>On line 20, I check if i is greater than 0, call System.out.println with i, and then we concatenate the value of i. On line 25, outside of this if block, I have boolean b &#61; handleString with a as its argument. And on line 26, I call System.out.println(b). Now from the terminal window, I need to run jdb -sourcepath. So I need to specify where the Java source file is. And that&#39;s up directories in ../../../ will get me into the main debug demo project folder and then into the source folder /src. And under that, it&#39;s in com.example. But I don&#39;t need to specify the full package name, just the main root source folder. And now JDB needs the class com.example.Main and the arguments 1 and test. And once I&#39;m into JDB, I&#39;m going to set a breakpoint. I&#39;m going to say stop in com.example.Main.</p>
<p>So capital M for Main, the class .Main, the method so all in lowercase, and now run. So it shows me the line. Without the source code or without specifying the source path, I wouldn&#39;t see the actual line, the code on the line. I would just see the line number. So it tells me Breakpoint hit: &#34;thread&#61;main&#34;, com.example.Main.main(), line 15. So now I can type step, and I could see each line as it&#39;s executed, I can type list to show me where I am in the code at any given time. So it shows the code, and on line 20 for the if i is greater than 0. I can type print and a variable name, say print i will print the value of i, print a, which gives me test for the second argument. Now, there&#39;s another variable down the line called boolean b. If I type b at this point, it&#39;s just going to say b &#61; null and give me a parse exception because the debugger or the source code hasn&#39;t got that far yet. <br /><br />[Video description begins] <em>He executes the command, print b, in the Terminal window.</em> [Video description ends]</p>
<p>Now, if I keep typing step it will show me the line, if I execute a line that prints that shows me the output. So I call it 1 from line 21. Now in line 25 has boolean b &#61; handleString. Now, if I type step, it will step into the handleString method, so step by default to step into. I&#39;ve typed step to step to the next line of code. I have to type where and it shows me that I&#39;m inside of handleString on line 6 with the if(str &#61;&#61; null or str.length(). So at any time, I can type where and it will show me the stack trace. If I type step, it will keep executing. And then I set the value b, type step, and it shows me it prints true. And if I step right to the end of the program, it will exit the program, so once I reached the end of the main method. I&#39;m going to arrow up and run JDB again.</p>
<p>And this time, I&#39;m going to change the values to 0. And I&#39;m not going to enter a second argument. <br /><br />[Video description begins] <em>He enters the following command: jdb -sourcepath ../../../src com.example.Main 0</em> [Video description ends] <br /><br />I&#39;ll type stop in com.example.Main.main, run. And now, if I step and then step over the second argument, it gives me an array index out of bounds exception, because this second argument wasn&#39;t passed. And it can&#39;t get anything from args[1] because it doesn&#39;t exist. So I can see where this exception occurs. And if I try to type step, it gives me the full Exception in thread main and exits. So we can see exactly where the exception happens. We can examine variables around it using print. We can examine the call stack using where. And I&#39;m going to run it one more time.</p>
<p>This time, I&#39;m going to give it the value 0 and steve, stop in com.example.Main.main, run. <br /><br />[Video description begins] <em>He enters the following command: jdb -sourcepath ../../../src com.example.Main 0 steve</em> [Video description ends] <br /><br />Instead of using step, I can also use next. So next, we&#39;ll step over. So if I get to handleString, line 25, and I type next, the debugger won&#39;t go into handleString method. It will step over it to the next line and just get the result. And in this case, it prints The string is ok! from inside of handleString so I see that much. And also if I type cont for continue, it will continue executing until it hits a breakpoint or it reaches the end of the program and the application exited. And that concludes this demonstration on debugging with JDB.</p></div></div></div><div class="section"><a name="section_3" /><h2 class="section_title">4. Video: Java Debugging with IntelliJ (it_sdjcfa_13_enus_04)</h2><img src="https://cdn2.percipio.com/public/b/a06e3ce9-90b9-41e6-900c-a788073e242e/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/a06e3ce9-90b9-41e6-900c-a788073e242e/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll learn how to debug code using IntelliJ. You’ll launch a program with the debugger attached with IntelliJ&#39;s internal debugger. This interfaces with the program and provides information about what&#39;s going on. You can put in breakpoints and perform the functions you would when running JDB from the command line, right inside your IDE. This facilitates the detection of problems, and it makes fixing bugs easier.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe how to debug code using IntelliJ</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Debugging with IntelliJ. Your host for this session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll present details on how to debug code using IntelliJ. I&#39;ll demonstrate this with an example in the video titled IntelliJ Java Debugging, but I&#39;ll give you the high level description in this video. Now let&#39;s talk about debugging code using IntelliJ. So we launch a program with the debugger attached with IntelliJ&#39;s internal debugger. This interfaces with the program and provides information about what&#39;s going on. You can put in breakpoints and perform all of the functions you would when running JDB from the command line, and you&#39;ll find out what&#39;s happening under the hood, right inside your IDE. This facilitates the detection of problems, and it makes fixing bugs easier. You can choose where to pause your program, when to query its state, to check the state of variables, and objects, and threads,</p>
<p>and the current stack trace. How do we execute code in debug mode? We invoke context actions by using Alt&#43;Enter and choose Debug option. We click the Run icon in the gutter area and select Debug option or from the Run menu, or by pressing Shift&#43;F9, the default hotkey. When we debug code using IntelliJ, we can pause the program and resume either line by line or until the next breakpoint. We can restart the program entirely. We can resume or continue executing after being paused. And we can stop, and end the program at any point. How do we set IntelliJ breakpoint? Well, when we set a breakpoint, it stops the execution of the program. It allows us to analyze the state of code at that point. And when we set up a breakpoint on a line of code, we click in the gutter area in the left side margin of the code next to the line numbers.</p>
<p>And a small visual indicator usually a tiny red circle will be put there where the breakpoint is going to occur. We can use the shortcut key, the Ctrl&#43;F8 on Windows or Linux, or commad F8 on Mac OS. What&#39;s in the IntelliJ Debug Window? We get the list of stack frames, the current call stack, console window with the program&#39;s output. The threads associated with the program, the step action icons to click and step through code. And we get a variable pane to display the contents of the active variables that are in the current scope. What is our IntelliJ debugging procedure look like? We define breakpoints where the program needs to be stopped. So we set a breakpoint that will manually suspend the program when it reaches the breakpoint.</p>
<p>When we launch the program, we select debug mode to launch it in debug mode. And we use the debugger to get information about the state of the program, information about variable values, running threads, to test our program in various conditions and use the stepping feature to step into functions or over functions and execute code line by line. And we can also fix without terminating sessions within the IntelliJ IDEA. So we can adjust code and reload on the fly, continuing from where we left off. What are some IntelliJ debug tips? How do you debug non-responding applications? We can do this using pause to try and get state information to identify the source of the issue, and evaluate expressions and variables. And always remember to take care of your pre-launch tasks.</p>
<p>This means making sure you&#39;ve configured or enabled other services required by your program such as web, or network services or APIs, database connections, and other data you need to load or connect to during the running of your program and that concludes this presentation on Java debugging with IntelliJ.</p></div></div></div><div class="section"><a name="section_4" /><h2 class="section_title">5. Video: Debugging Code Using IntelliJ (it_sdjcfa_13_enus_05)</h2><img src="https://cdn2.percipio.com/public/b/859529b6-906e-47b9-ad9c-e0d77506f1fe/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/859529b6-906e-47b9-ad9c-e0d77506f1fe/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll learn how to use IntelliJ&#39;s Java debugging tools. You&#39;ll start in the project onscreen, called DebugDemo. Inside of Main.java, you’ll begin with the line package com.example, and add it to this particular package. On line 3, you’ll declare a public class Main. Then inside of this class, there are a couple of methods. One is the Main method, and another one is called handleString.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">debug code using IntelliJ</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Debugging Code Using IntelliJ. Your host for this session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll demonstrate how to use IntelliJ&#39;s Java debugging tools. I&#39;ll start in this project which I&#39;ve called DebugDemo. Inside of Main.java, I start with the line package com.example, and add it to this particular package. Then on line 3, I declare a public class Main. And then inside of this class, I have a couple of methods. One is the Main method, and another one is called handleString, which I use to execute a few lines of code, so that I can demonstrate debugging inside of IntelliJ. <br /><br />[Video description begins] <em>The IntelliJ IDEA window titled, DebugDemo - Main.java appears on the screen. Currently, the Main.java file is opened and displays various lines of code.</em> [Video description ends] <br /><br />So in line 5, I have public static boolean handleString, and it takes a string as an argument. So I declare the parameter String str. And inside the body of this function, I have if str is equal to null, or str.length is equal to 0.</p>
<p>So if the string is empty or null, I print using System.out.println, The string is not ok, and I return false. And outside of the if statement, I have System.out.println, The string is ok, and I return true. Now in line 14, I have public static void main String[] args. On line 15, I have int i &#61; Integer.parseInt of args at index 0, so the first argument. In line 16, it has string a &#61; args of index 1, the second argument. Then I check to see if i is greater than 0. So if it&#39;s greater than 0, I&#39;ve print i and the value of i. And then outside of the if statement on line 25, I have boolean b &#61; handleString. So I call the method, with the argument a, and then I print the result b, so System.out.println of b. Before I continue with the debugging, I want to check by run the configuration.</p>
<p>So from the Run menu, I&#39;ll select Edit Configurations.<br /><br />[Video description begins] <em>The Run/Debug Configurations dialog box appears.</em> [Video description ends] <br /><br />And then in the Build and run, there&#39;s a command line argument section where I put 5 for the first argument and Steve for the second argument. So I can edit those here in this menu, select OK. And now I&#39;m going to set some breakpoints. I&#39;m going to put one on line 15, the first line inside of my main function, then if I do Ctrl&#43;F8 after it&#39;s been set, it will remove it. <br /><br />[Video description begins] <em>Line 15 reads: int i &#61; Integer.parseInt(args[0]);</em> [Video description ends] <br /><br />So Ctrl&#43;F8 toggles the breakpoint on and off. Or I can select the margin area, the gutter area by clicking, I can click on the line where I want the breakpoint. So I&#39;ll set a breakpoint at line 15 and on line 25. <br /><br />[Video description begins] <em>Line 25 reads: boolean b &#61; handleString(a);</em> [Video description ends] <br /><br />Now I can run the code in debug mode from the Run menu by selecting Debug Main. Or I can go in the toolbar and select the Debug icon.</p>
<p>In this case, it&#39;s a green bug. Or I can type Shift&#43;F9. In this case, I&#39;ll just click the button, the icon in the Debug menu. It starts executing and stops at my first breakpoint on line 15. And immediately, we see that we have a variable set, the args variable. We can see it in the variable section in the bottom panel, in the Debug panel. And there&#39;s also icons here if I want to step into or step over, step out. So all of the actions to step through the code line by line are here in the Debug panel. I can also use the shortcut key, the F8, it will step over line by line and each step along the way updates the variables. So I have args, i, a at this point. And here the test is if i is greater than 0, and in this case it&#39;s 5 so it should print.</p>
<p>Now if I want to see what&#39;s printed, I&#39;ll have to go from the Debugger panel to the Console panel and see i: 5. <br /><br />[Video description begins] <em>He switches to the Console panel by clicking the Console option. </em>[Video description ends] <br /><br />And I can go back and forth between Debugger and Console. I&#39;m going to use F7 to step into the handleString method. <br /><br />[Video description begins] <em>He switches back to the Debugger panel and then presses F7.</em> [Video description ends] <br /><br />And once I&#39;m inside, I can continue using F7. And in this case, the string is Steve. So the str variable is set to Steve. So it should print, The string is ok! and return true. And I can continue to step. Now at any point, I can resume the program with F9, and it will continue executing either to the end of the program or until it hits another breakpoint. And I can always check the results in the console, where it prints my results such as The string is ok! and the true that&#39;s returned from the function handle string. <br /><br />[Video description begins] <em>He switches to the Console panel again.</em> [Video description ends] <br /><br />And that concludes this demonstration of IntelliJ&#39;s Java debugging.</p></div></div></div><div class="section"><a name="section_5" /><h2 class="section_title">6. Video: Java Debugging Best Practices (it_sdjcfa_13_enus_06)</h2><img src="https://cdn2.percipio.com/public/b/0bc234cb-a0fa-4a19-b676-22f2bb99beb1/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/0bc234cb-a0fa-4a19-b676-22f2bb99beb1/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn best practices for debugging code in Java. First, you’ll learn about Java breakpoints. You’ll learn you can set conditional breakpoints based on conditional if statements inside of if then else blocks. Exception breakpoints are ones that occur when an exception is thrown. Watch points are based on the value of a variable. You’ll learn the Eclipse IDE or IntelliJ enables you to choose any frame.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe some of the best practices when debugging code in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Debugging Best Practices. Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe some of the best practices when debugging code in Java. The first thing we need to take care of are Java breakpoints. Where do we set Java breakpoints? We can set conditional breakpoints based on conditional if statements inside of if then else blocks. Exception breakpoints, ones that occur when an exception is thrown. Watch points based on the value of a variable. And trace points. How do we take advantage of the Java debugging features we have available to us? Well, we should be looking to do things like drop to frame which means to jump back to a point in your stack frame at a particular level in your call stack.</p>
<p>In the Eclipse IDE or IntelliJ, this enables you to choose any frame. We should be using step filtering. So we can skip certain packages. And we can filter out JDK classes from the step into. So stepping into enters the method, which is usually fine for methods in our own source code. But most often, we avoid stepping into the JDK class code itself. And we can be using shortcuts. You should know the hotkeys common hotkeys for stepping into functions like F5. Stepping over, F6. And running until the next breakpoint, F8. What are some best practices when debugging code in Java? What can we do? We can evaluate expressions and variables along the way. Set breakpoints to carry out the evaluations at critical points or uncertain points in the code that you may need to examine. Environment variables and their contents.</p>
<p>Make sure they&#39;re consistent across different environments, especially if the program is deployed to multiple location, such as an array of servers or cloud computing environment. Modify the value of your variables directly from within your debugger. So you can set a breakpoint and change the variable&#39;s value from the debugging tools and see how the program response. This is a very handy option for testing hard to reproduce errors. If you need to test a particular failure code that might be returned from an external API resource. You can set a break point when the call happens or just after the call happens, change the result, and see how your program response. What about resolving deadlocks in Java? Well, this is when two or more threads are blocked.</p>
<p>When the threads are blocked permanently we call it a deadlock. This is a cyclic dependency of threads. For example, thread A will be waiting for a resource that thread B has, and thread B is waiting on another thread C. But thread C is also waiting on thread A. So at this point nobody can proceed, and we call it a deadlock. Using jstack on deadlocks is not always fruitful. These errors do not exhibit symptoms of common problems. Such as spikes in memory or CPU, or some OS metrics that let us know that something is not working properly. Sometimes the memory and CPU are all at a minimum but we&#39;re still blocked and we&#39;re still stuck in this deadlock. We may need to turn to external solutions such as application monitoring solutions, and using advanced debuggers and commercial APM tools to track down these problems.</p>
<p>I&#39;ve been in this situation before, with deadlocks happening in production environments, but we couldn&#39;t reproduce it in testing. This ended up requiring a manual reset every few hours to avoid these deadlocks for months before we could finally track down the issue and resolve it. We can also do remote debugging in Java. This allows you to debug Java code running on another machine. Most IDEs support remote debugging, such as NetBeans, Eclipse, Intellij IDEA, and Visual Studio. What are some common debugging code tips in Java? You can use your IDE to copy the stack and save the results. This might be necessary for debugging multi-threaded programs. You can suspend and resume individual threads, which might be necessary for debugging multi-threaded programs. Use the step into feature to go into a function.</p>
<p>And the step over feature to step over a function call and just get the result if there&#39;s no need for you to go into a function every time. This is especially handy if you have a loop that calls a function, and you don&#39;t really care to go in on each iteration of the loop. But you just want to examine the result each time it calls the function and stay within your current context, your current scope. And debug the code locally, and stay under the step return option. And that concludes this presentation on Java debugging best practices.</p></div></div></div><div class="section"><a name="section_6" /><h2 class="section_title">7. Video: Java Syntax and Logic Errors (it_sdjcfa_13_enus_07)</h2><img src="https://cdn2.percipio.com/public/b/1c7f998c-daf4-4090-9000-b7f7af9f8bff/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/1c7f998c-daf4-4090-9000-b7f7af9f8bff/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn some of the common syntax and logic errors made in Java code. Errors in Java fall into two main categories. Syntax errors occur when the language is used incorrectly. Compiler will catch most syntax errors. However, it doesn’t cover mistakes in the logic of the program itself. Logic errors occur where the code isn&#39;t performing as expected.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe some of the common syntax and logic errors that are made in Java code</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Syntax and Logic Errors. Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll present some of the common syntax and logic errors that are made in Java code. Errors in Java fall into two main category. Syntax, which covers the language used to create code. A syntax error is when the language is used incorrectly. Compiler will catch most syntax errors. If you use a keyword in the wrong place or in the wrong way, your code most likely won&#39;t even compile. It does not cover mistakes in logic of the program itself. So logic errors are different, logic errors is where the code isn&#39;t performing as expected. It can be difficult to find, and time-consuming going through code to find a reason for a logic error. If you have a conditional statement, an if statement that performs some comparison in the wrong way, your code won&#39;t execute as expected.</p>
<p>What are some common syntax errors in Java? Unintelligible commands, not following the prescribed format. Java has its own syntax, you can&#39;t use syntax from other languages, you can&#39;t use Objective-C or C&#43;&#43; in Java, it just won&#39;t work. There is some overlap, but you have to make sure you&#39;re writing actual Java keywords in the format Java wants. You&#39;ll get compiler errors, and most syntax errors will be detected immediately. If you&#39;re using an IDE, an IDE can pick them up as you type them. Syntax errors rarely make it to runtime errors but it can occur. So a syntax error that results in a runtime error is often not detected until the program is running. And in the case of a runtime error, it&#39;s usually a case of a typo or using the wrong keyword mistakenly.</p>
<p>Let&#39;s say you use the continue keyword when you mean break, where you apply the wrong keywords. But otherwise, syntax errors are most likely to result in compiler errors. What are the common syntax errors in Java? Forgetting to import a class. Missing parentheses. Splitting a string over two lines without a concatenation with the plus character. Treating a static method as an instance method. And using incorrect capitalization. And some more common syntax errors in Java are, forgetting the class or object. Missing curly braces. Mistyping the header for the main method. Not declaring it correctly.</p>
<p>Omitting the break clause from a switch statement. And omitting a return statement. Now omitting the break clause from a switch statement can also be considered a logic error, depending on how you use it. But errors of omission typically fall under syntax errors. Now, what are some of the common logic errors in Java? Assuming a condition is true. Defining the wrong count. Using incorrect operator precedence, as well as misplacing a semi colon. Relying on integer values when values might be strings or floating point values. Relying on floating point numbers when values might be integers or possibly null, or string values, or some other numeric type. And that concludes this presentation on Java syntax and logic errors.</p></div></div></div><div class="section"><a name="section_7" /><h2 class="section_title">8. Video: Java Exception Handling (it_sdjcfa_13_enus_08)</h2><img src="https://cdn2.percipio.com/public/b/271cf70c-1ef0-46be-9165-b31fdbec205b/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/271cf70c-1ef0-46be-9165-b31fdbec205b/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn some of the important aspects of Java&#39;s exception handling. This is one of the most overlooked and underestimated features. Exception handling gives you the ability to alter the flow of code in a structured way so the logic is easy to follow. The content of the exception is obvious and the handlers are defined in a consistent way.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe exception handling and how it relates to Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Exception Handling. Your host for this session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe some of the important aspects of Java&#39;s exception handling. One of the often overlooked and underestimated features especially when you come from a language and are used to languages like C where you use the return codes from functions or error codes or even go to statements for handling exceptional events. An example to keep in mind for exception handling is if you&#39;re trying to connect to a service that&#39;s unavailable. And you get a failure in the response where the connection drops and then an exception is thrown so you can handle it based on the content of the exception. So exception handling gives you the ability to alter the flow of code in a structured way so that the logic is easy to follow. The content of the exception is obvious and the handlers are defined in a consistent way.</p>
<p>So where does this come up? What sort of exceptional events require exceptional handling? Well, if you try to open a file that can&#39;t be found. If you try to make an Internet connection and it drops on you, especially if it drops before the transmission can complete. Or if your system doesn&#39;t have enough memory, how will your program fail in this case? We can handle this better through an exception hierarchy that classifies our exceptions in three ways. The first is checked exceptions. These are exceptions that have to be handled, your program won&#39;t compile unless these exceptions are caught. So this allows you to plan ahead, handle or declare when writing code, and detect problems before runtime.</p>
<p>So before they&#39;re found when the program is running, you find them at compile time. Unchecked exceptions, also called runtime exceptions because they happen when the program is running, and they&#39;re not caught at compile time. These occur to human error, to programmer error. They&#39;re checked at runtime, there&#39;s nothing forcing them to be caught. But the programmer should be aware of them because if they&#39;re not, the chances of introducing a bug increase. And they&#39;re often encountered in many different areas, such as null pointer exceptions, or number format exceptions. Now a part of the unchecked exceptions are errors. This is a special type of unchecked exception that are the most serious exceptional conditions, and these are very hard to recover from, they&#39;re irrecoverable.</p>
<p>So, an out of memory error if your operating system runs out of memory and you can&#39;t allocate any more, or if you have a stack overflow within your application. These errors don&#39;t need to be caught, and the best practice in this scenario is to let the program crash and hope you get information from your log files as to what exactly happened. Ideally a print of the stack trace of when it happened. These can occur due to human or programming errors, such as a stack overflow if you have too much recursion or operating system environment errors. So the best practices for Java exceptions is to use them to clean up resources such as closing file handles, database connections, and network connections when you&#39;re done with them, even if they fail partway through the operation. Prefer specific exceptions rather than generic exception classes or broad exceptions that cover many types. Make exception handling code self documenting, by using specific exceptions. And document exceptions describe how particular exceptions might occur if it&#39;s not obvious from the context.</p>
<p>You should also throw exceptions with descriptive messages and catch the most specific exception first. And don&#39;t catch throwable, throwable is the base exception superclass, it&#39;s the most general generic broad exception in Java. It&#39;s too general, it catches all exceptions and errors of all types. It makes the code harder to read and follow. It makes it too easy to catch exceptions such as errors that you shouldn&#39;t be trying to catch anyway. Some more best practices are to not ignore exceptions, for checked exceptions, but don&#39;t assume all unchecked exceptions don&#39;t need to be caught. Some if you know that they&#39;re likely, you can catch them and redirect the users to recover. Don&#39;t log and throw or rather log and rethrow.</p>
<p>I&#39;ve seen many exceptions caught, a log line written, and then the exception is rethrown further up the call stack. This usually results in duplicate log messages for the same exception and not really doing anything productive to handle the exception. You&#39;re just adding more work. In this case, exceptions should be in the method signature, so that it can be handled by the caller. And you can wrap exceptions. So extend your own exception classes where you need a specific handler tied to your applications functionality or underlying architecture. Wrapping exceptions is perfectly fine and may make debugging easier when you run into problems in your code. And that concludes this presentation on Java exception handling.</p></div></div></div><div class="section"><a name="section_8" /><h2 class="section_title">9. Video: Demonstrating Java Exception Handling (it_sdjcfa_13_enus_09)</h2><img src="https://cdn2.percipio.com/public/b/aa2bdeda-fde8-4fc9-b87e-49af507251a6/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/aa2bdeda-fde8-4fc9-b87e-49af507251a6/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll learn how to handle exceptions in Java, focusing on two different types, the checked exception and the unchecked exception. In the Main.java file, you’ll see this class in the package com.example. You’ll import java.io.FileInputStream.</p>
<p>You’ll open a file and see what happens if the file can&#39;t be found. You’ll find you need to import java.io.FileNotFoundException. This is part of a checked exception. </p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">handle exceptions in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Demonstrating Java Exception Handling. Your host for this session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll demonstrate how to handle exceptions in Java, focusing on two different types, the checked exception and the unchecked exception. So I&#39;ll have an example of each. So in my Main.java file, I put this class in the package com.example. And then I have my imports, import java.io.FileInputStream. <br /><br />[Video description begins] <em>The IntelliJ IDEA window titled, BasicExceptionDemo - Main.java appears on the screen. Currently, the Main.java file is opened and displays various lines of code.</em> [Video description ends] <br /><br />So I&#39;m going to demonstrate opening a file and what happens if the file can&#39;t be found, for which I need import java.io.FileNotFoundException. So this will be part of a checked exception, an exception that we need to catch or the program won&#39;t compile. Whereas an unchecked exception, which I&#39;ll also demonstrate, is something that we typically don&#39;t check. Because it&#39;s usually an error that we can&#39;t recover from or that we can&#39;t anticipate. So I&#39;ll explain this as I go.</p>
<p>So inside of public class Main, I define a function. So the first exception is going to be an unchecked exception, and I&#39;m not going to catch it. And the exception I&#39;m going to force this program to have is a StackOverflowError. So it&#39;s when you call too many functions, especially recursive functions, and the program runs out a stack space. A program running out of memory, things to do with the operating system that are external to the program are all errors that are typically unchecked exceptions. In general in Java, errors or runtime exceptions are these exceptional conditions, you can think of them as, that we don&#39;t need to catch. And when we don&#39;t catch them, the program crashing or exiting, usually printing a stack trace of where the error occurred, might be the best or only course of action that can be taken.</p>
<p>So in line 8, I have public static int factorial that defines the parameter int n. So this is computing the factorial successively and recursively. So in it, I have if n is equal to 1, return 1. So that&#39;s the first one. Then else return n times factorial of n-1. So the idea is you pass it a number n, and it will multiply it by all the numbers up until n, and then exit returning the result. And then in the main function in public static void main, where I have string double brackets args, inside of the main entry point on line 17, I have int result &#61; factorial with the argument -1. Well, if we pass -1, the factorial will never finish because it&#39;s expecting a positive n. And if we don&#39;t check for it, factorial will be called recursively and never exit.</p>
<p>But it will exit because we&#39;ll run into a stack overflow, we&#39;ll have called factorial recursively too many times and it will cause our program to fail. So in line 18, I have System.out.println of the result that&#39;s returned by the factorial. So I&#39;ll run the program at this point before I get to the second exception. So Shift&#43;F10 to run the program, and there&#39;s a whole long line of factorials. So this is the actual stack trace, the actual function call stack trace, and it just keeps calling factorial. And I scroll up through all of these calls to factorial, I&#39;ll select the scroll bar and go right to the top, and the Exception in thread &#34;main&#34; java.lang.StackOverflowError. So this isn&#39;t an exception that we look to catch. This is an error that happened due to a programming error and should be fixed in our code. This is an actual program bug.</p>
<p>So using exceptions to catch program bugs are not something you typically do. And arguably better to let the program fail, see what the exception was, and fix the code so it doesn&#39;t run into that exception. But this is not the case for checked exceptions. So what I&#39;ll do is I&#39;ll comment out those two lines of code with the factorial and the result on lines 17 and 18. So I&#39;ve commented out those two lines and then I have my checked exception. <br /><br />[Video description begins] <em>He updates line 17 to: //int result &#61; factorial(-1); and line 18 to: //System.out.println(&#34;Result:&#34; &#43; result);.</em> [Video description ends] <br /><br />Now, there&#39;s the try block. And inside of it I have FileInputStream f &#61; new FileInputStream, and the string is /non_existent_file, a file that I know doesn&#39;t exist on this system. So it&#39;s opening a file that doesn&#39;t exist, which should cause it to throw a FileNotFoundException. And that&#39;s my catch, catch(FileNotFoundException e) and System.out.println(e).</p>
<p>So it&#39;s going to print the exception or the results of the exception. Another way of doing this, if we want to see what the details of the exception are, we could also call e.printStackTrace. But what happens if I remove the try and catch block? So I comment out the try and the catch and the contents of it. So I put double slashes, but I leave FileInputStream f equals new File InputStream with the file. So if I save it, IntelliJ signals that there&#39;s an error. So there&#39;s a red underline and there&#39;s this stop symbol saying one error and three warnings. And if I do Shift&#43;F10 it&#39;s going to try to build, and it shows what the error is. It says unreported exception java.io.FileNotFoundException must be caught or declared to be thrown. So you either have to catch the checked exception or make sure that it gets thrown.</p>
<p>So in this case, we&#39;re going to catch it, so I have to put in the try block and the catch. <br /><br />[Video description begins] <em>He removes the comments placed before the try and catch blocks.</em> [Video description ends]<br /><br />And once I save it, type Shift&#43;F10 again, it compiles successfully and it gives me the result. And in this case, it prints java.io.FileNotFoundException: /non_existent_file (No such file or directory). So we caught it successfully, file wasn&#39;t found. And this is the type of thing that should be caught. So if you&#39;re trying to open a file, and it fails, you should be able to handle it. If you&#39;re trying to write to a file and you don&#39;t have write permissions. You should be able to inform the user that you can&#39;t write to the file, the file doesn&#39;t exist or you can&#39;t read it, or there&#39;s some error handling a file.</p>
<p>So these types of external resources, such as trying to connect to a web page and download some contents from your code. If you can&#39;t make that connection, if your Internet connection goes down, or the site you&#39;re connecting to goes down. That&#39;s the type of exception that you always need to catch, which we call checked exceptions. And that concludes this demonstration of programming with Java exception handling.</p></div></div></div><div class="section"><a name="section_9" /><h2 class="section_title">10. Video: Common Java Exceptions (it_sdjcfa_13_enus_10)</h2><img src="https://cdn2.percipio.com/public/b/a3cc786a-0c97-4c50-8655-f93d20f78c8d/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/a3cc786a-0c97-4c50-8655-f93d20f78c8d/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll learn some of the more common exceptions in Java. You’ll learn Java has two main categories of exceptions. Checked exceptions are ones that must be caught, otherwise, your program won&#39;t compile. Most IDEs like IntelliJ will flag checked exceptions as they’re written. Unchecked exceptions are ones that don&#39;t need to be handled, but areas where things can be thrown. Unchecked exceptions are exceptions programs don’t recover from.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe some of the common exceptions in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Common Java Exceptions. Your host for this session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe some of the more common exceptions in Java. So Java has two main categories of exceptions, the checked exceptions. These are exceptions that must be caught, otherwise your program won&#39;t compile. Most IDEs like IntelliJ will flag checked exceptions as you&#39;re writing them. Unchecked exceptions are ones that don&#39;t need to be handled, but areas where things can be thrown. Unchecked exceptions are typically exceptions, that don&#39;t expect a program to recover from. So if your system runs out of memory, the operating system itself, or some other type of error external to the application causes an error in your application. Java can still throw an exception, unchecked exceptions don&#39;t need to be caught, but in some cases you can catch and handle them.</p>
<p>But some, such as ones generated by the underlying operating system, if there&#39;s an out of memory error, they don&#39;t need to be caught, and your program can just fail printing a stack trace, and that&#39;s generally accepted as the best approach. Checked exceptions are often things like IOExceptions. So Input/output operations fails such as reading a file, reading network, that you may not have write permissions for. I/O operations typically come from the Java.io package or Java.net package. So network communications, and file and device input-output operations. Checked exceptions, one of the most common examples is the ParseException. This is used to create an object based on a given string. This happens, when you&#39;re trying to parse useful information out of a string to create an object, and it&#39;s not in the correct format, or you can&#39;t pull out the desired information. So the formatting might be something like a date, let&#39;s say you&#39;re expecting a date in dd/mm/yyyy.</p>
<p>So two digit day, two digit month, and four digit year, delimited by slashes, or, say another date format with a two digit day, a two digit month, and a three digit year separated by commas. So dates can come in all sorts of formats, and if you&#39;re expecting a certain one, and you&#39;re not given that date format, then your program will throw a ParseException. I demonstrate the ParseException with example code in the video titled programming common Java exceptions. Other common checked exceptions are the InterruptedExceptions for threads. So this is a thread base exception thrown for join, sleep, and wait, during wait states or timed waiting states. So this thread can interrupt another thread, either before or during the activity. And this can be checked by calling the interrupt method, and the current thread can test whether it has been interrupted by calling the interrupted method.</p>
<p>And these are all directed through the InterruptedException. A common unchecked exception is the NullPointerException. So an application attempts to use null when it requires or expects an object instance. So an object gets set to null, and then later on a method for that object is called, you&#39;ll get a NullPointerException. So this is illegally using null, or a null reference, when you&#39;re expecting an object. So the method of a class that has no object instance will throw a NullPointerException. And if you try to access or modify instance variables with null references, you&#39;ll also get the NullPointerException. Another common unchecked exception is the ArrayIndexOutOfBoundsException.</p>
<p>So a negative index, or most likely an index that&#39;s greater than the arrays maximum. So anything from the size of the array, and higher, will end up with an ArrayIndexOutOfBoundsException. StringIndexOutOfBoundsException, usually happens with the charAt method of a string. Where you&#39;re trying to index a single character, with the string result in a negative index, or an index passed the end of the strings length. So these are unchecked exceptions, you might think well, why don&#39;t we check these exceptions? These are typically driven by programmer error, a result of unchecked bounds, or checking past the end of an array. Another unchecked exception is a NumberFormatException. This happens when you&#39;re converting a string to a number, or numeric type, and it fails because of an invalid format.</p>
<p>For example, it&#39;s thrown when the integer.parseint fails. So if you call integer.parseint on a string, and you pass it something that&#39;s not a string, you&#39;ll get a NumberFormatException. Now, these unchecked ones can be caught and handled. Let&#39;s say a user inputs a number, or expected to input a number and they don&#39;t, then you can catch the exception until they input something valid. Division by zero is a common exception, where you get an ArithmeticException error thrown, or if you&#39;re trying to convert using an object cast to an unsupported type. For example, if you&#39;re trying to print an object by casting it to a string, using a prepended string in parentheses. If the cast is unsupported by the object, a ClassCastException is thrown. Another unchecked exception that&#39;s occasionally thrown is, an IllegalArgumentException. This is where a method is passed a bad argument incompatible with its parameters, such as null, or the state of the internal object throwing the IllegalAgumentException, can&#39;t recover from it.</p>
<p>Remember, this is an unchecked exception. If the caller can recover from the exception, then it should be checked. An IllegalArgumentException wouldn&#39;t be appropriate in this case. But if the calling method is forming the argument passed to the method from an external source, or from an operating system source, that may cause a null or an invalid value then the program can&#39;t recover from the state. You can think of this exception as the unchecked version of ParseException in many circumstances. The IllegalStateException comes up when trying to call a method, when the current state of the object doesn&#39;t support it. For example, trying to start a thread when that thread has already been started, or it&#39;s currently running, and that concludes this presentation on common Java exceptions.</p></div></div></div><div class="section"><a name="section_10" /><h2 class="section_title">11. Video: Demonstrating Common Java Exceptions ( it_sdjcfa_13_enus_11)</h2><img src="https://cdn2.percipio.com/public/b/6879be26-21da-4a91-9c8a-6a0de1e8fae9/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/6879be26-21da-4a91-9c8a-6a0de1e8fae9/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll learn some common exceptions in Java through the example code onscreen, open in IntelliJ. In Main.java, you’ll start by including it in the package com.example. And then on line 3, you’ll import java.text.ParseException; then import java.text.SimpleDateFormat. You’ll try and parse a date from a string and stored in a date object. But if we can&#39;t parse that string, a parse exception will be thrown.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate some of the common exceptions in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Demonstrating Common Java Exceptions. Your host for this session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll demonstrate some common exceptions in Java through this example code I have opened here in IntelliJ. So in my Main.java, I start by including it in the package com.example. And then on line 3, I import java.text.ParseException; then import java.text.SimpleDateFormat; <br /><br />[Video description begins] <em>The IntelliJ IDEA window titled, CommonExceptionDemo - Main.java appears on the screen. Currently, the Main.java file is opened and displays various lines of code.</em> [Video description ends] <br /><br />So we&#39;re going to try and parse a date from a string and stored in a date object. But if we can&#39;t parse that string, a parse exception will be thrown. Then on line 5, I have import java.util.Date; and import java.util.Scanner; to read our input when we run the program. So inside of the class main inside of the main function, the entry point into our application, I have Scanner input &#61; new Scanner(System.in); so that we can type our input into test it.</p>
<p>On line 13, I have System.out.print(&#34;Enter a date (YYYY-MM-DD): &#34;); So this is telling the user telling us that we&#39;re expecting a date in the format of year, month, day separated by hyphens. So the ISO 8601 date format. Then on line 14, String a &#61; input.nextLine(); And then, we go into a try block starting on line 16. Then I have SimpleDateFormat dateFormat &#61; new SimpleDateFormat( s: &#34;yyyy-MM-dd&#34;); in the expected format for our date formatter. And then on line 18, I have date of variable date in lowercase &#61; dateFormat.parse of our string a that was entered. And then on line 19, I call System.out.println with the variable date. On line 20, I have the catch. So catch ParseException.</p>
<p>So this is the checked exception thrown by the parse method. So we have to catch that, and if we don&#39;t, if we ignore it, if I comment out the try and catch block, it&#39;s going to complain and tell me that this is an unhandled exception, so we need to handle it. Otherwise the code won&#39;t compile and run. In the catch body where I catch the ParseException, I call System.out.println(&#34;ParseException caught!&#34;); And then I call System.out.println(e.toString()); And then the second part of the code on line 25, I have System.out.print(&#34;Enter a number from 1 to 10: &#34;); Then I enter a try block where I have int i &#61; input.nextInt(); And on line 28, I have int b &#61;10 / i; So there&#39;s a couple of things that can happen here. One, if we enter 0, which we don&#39;t check for, we&#39;ll have a division by 0 and that&#39;s an ArithmeticException.</p>
<p>If the input is not an int, if we enter some string, some letters that can&#39;t be parsed into an int, we&#39;ll get a number format exception. So, on line 30, I print the result, so I print 10 divided by, that i concatenate the variable i is, and then I concatenate the variable b. My catch block starts in line 31 with } catch(NumberFormatException | ArithmeticException e) { So this is a way of catching multiple exception types with a single catch block. So it&#39;s going to look for both of those exceptions and regardless of which one it is, it will store the results in the variable e, it&#39;ll print e Exception caught! and call e.printStackTrace to see the entire stack trace of the exception. So now we&#39;ll run the code with Shift&#43;F10. <br /><br />[Video description begins] <em>The Main window appears at the bottom of the screen and displays the following text: Enter a date (YYYY-MM-DD):</em> [Video description ends] <br /><br />And I&#39;ll type in a date. I&#39;ll put it an accurate date, 2021-01-01.</p>
<p>So let&#39;s have the correct format, and it prints Fri Jan 01 00:00:00 AST 2021. Enter a number from 1 to 10: well, I&#39;ll enter 5. And it shows 10 / 5 or 10 divided by 5 is 2, and it worked fine, so no exceptions thrown. And let&#39;s have it throw an exception. So enter a date. I&#39;ll enter my name, steve ParseException caught unparseable date, steve. So Steve is not a date, and I knew that going in. So it&#39;s not unexpected. Now enter number 0 exception caught Java Lang. ArithmeticException, division by 0 at com.example.main.main main.java line 28. So it happened on line 28. Let&#39;s run it one more time.</p>
<p>And let&#39;s enter a number this time,let&#39;s say 1 2 3 4 5 6, and it tells me that it&#39;s a unparsable date, 1 2 3 4 5 6, the ParseException was caught, and now I&#39;ll enter a number. In this case, my number will be Steve, which is not a number. Any exceptions thrown gives me in InputMismatchException. So it&#39;s not quite what I expected. I put in the NumberFormatException, which could be a possibility. I can also put in InputMismatchException, and put in an or if I want to catch that same one. And let&#39;s see if we can catch that input mismatch. So it doesn&#39;t matter what I put in for the date, and now I enter my name again, steve, when my program is expecting a number. <br /><br />[Video description begins] <em>He updates the code in line 32 to: } catch(NumberFormatException | InputMismatchException | ArithmeticException e) {<!-- --></em> [Video description ends] <br /><br />[Video description begins] <em>He enters the value, 1, in front of the text, Enter a date (YYYY-MM-DD): in the Main window.</em> [Video description ends] <br /><br />[Video description begins] <em>He enters the value, Steve, in front of the text, Enter a number from 1 to 10: in the Main window.</em> [Video description ends] <br /><br />And it tells me that the exception is caught and it prints the Java.util.InputMismatchException.</p>
<p>So these are unchecked exceptions. And generally, when you&#39;re expected to input an integer and you put something else, it&#39;s going to do bad things in your program. And in many instances, you should almost let the program fail and print this stack trace as it would by default so that the bug can be fixed. And that concludes, this demonstration, of programming common Java exceptions.</p></div></div></div><div class="section"><a name="section_11" /><h2 class="section_title">12. Video: Java Try Catch Blocks ( it_sdjcfa_13_enus_12)</h2><img src="https://cdn2.percipio.com/public/b/8f2006af-d76c-453e-8d69-400ec12ed81c/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/8f2006af-d76c-453e-8d69-400ec12ed81c/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll learn how Try Catch Blocks are used in Java. You’ll learn the finally statement. You’ll learn Java exceptions are a way of handling and passing error information. It’s a way of dealing with exceptional events. You’ll discover the syntax in Java is driven by the try and catch blocks. Onscreen, there&#39;s a try keyword and a catch keyword. And those blocks are surrounded with braces.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe how to use try catch blocks within Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Try Catch Blocks. Your host for this session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe how Try Catch Blocks are used in Java. I&#39;ve covered exception handling and common exceptions during this course but I haven&#39;t devoted direct attention to try catch blocks themselves including the finally statement, which I&#39;ll do here in this video. So Java exceptions are a way of handling and passing error information. It&#39;s our way of dealing with exceptional events. We&#39;re not passing around error codes or return codes, which is what happens in other languages that don&#39;t have exception handling, like in the C language. The syntax in Java is driven by the try and catch blocks. So there&#39;s a try keyword and a catch keyword. And their blocks are surrounded with braces like you would see in an if statement. And there&#39;s also a finally block with statements to handle situations.</p>
<p>Regardless of what happens in the try and catch blocks, the finally block will always execute. So Java try blocks are part of our exception handler syntax. So a try block is a block surrounded in braces that follow the try keyword, which is then followed by a catch statement. So the catch keyword, followed by parentheses that contain the types of exceptions that we&#39;re looking to catch. And following the catch statement, there&#39;s a catch block surrounded in braces where we execute code when an exception is caught. So the try only designates an area that corresponds to the catch block. So if an exception is thrown outside of the try block, the catch block won&#39;t have anything to do with it. Because it&#39;s only looking within its corresponding try block where the exception may be thrown. And you can&#39;t have a try block without a catch, and you can&#39;t have a catch without a try.</p>
<p>They&#39;re connected to each other. The Java catch block specifies an ExceptionType. With an if statement, you have an if block where you specify an expression that results in a true or false. A catch block specifies an ExceptionType. The exception thrown is indicated by its argument. It&#39;s executed if and when the exception handler&#39;s invoked. So the runtime system breaks out of the try block and proceeds immediately to the catch block, skipping over the remaining statements within the try block. The Java catch blocks are triggered within the corresponding try block. The try block jumps to the catch statement, skipping over any code that remains within the try block. So we have to take that into account when we&#39;re designing our catch blocks and our finally blocks.</p>
<p>So it checks for a matching exception type. So if an exception is thrown, and it&#39;s not contained within the catch statement, the program will exit, printing the stack trace of where that exception occurred. But the catch statement, if it is matched, then it leaves you with a way of handling the error, recovering from it if you can. And quite often this results in prompting users to make a decision. Either re-entering input that might be invalid, or reconnecting to a database or an external server that may have dropped the connection, which resulted in the exception. And in some cases we can propagate errors by handling the error locally and re-throwing the exception further up the call stack. But this is something we use sparingly. It&#39;s typically bad form to catch an exception and just propagate it, rather than just propagate it without catching the exception if we know it&#39;s going to be handled further up the call stack.</p>
<p>The catch blocks in the Java exception handler can handle more than one type of exception. So you can chain them together using the single pipe character which I demonstrated in the video titled Programming Java Try Catch Blocks. This is available in Java SE 7 and up. It reduces code duplication so you don&#39;t need multiple catch blocks. You can just have one catch block with multiple different types. It lessens the temptation to ignore certain exceptions or to use more generic exception classes. So your exception classes should be more specific if you can, which makes it easier for self-documenting code when we know exactly what types of exceptions are being caught. And a catch parameter is implicitly final, so we don&#39;t need to declare it final, the parameter&#39;s already flagged final for us.</p>
<p>Now the Java finally block is typically used, or mainly used for resource cleanup. So if you have open files or network connections or database connections that need to be closed or cleaned up, then you can perform that in the finally block. And the code in the finally block must assume both success and failure conditions. So if the try block fails before the file can be opened, then the file object might even be null at that point. If you try to call close on the open file where the object is null, you&#39;ll generate another error, another exception within your finally block. So you should have checks for null and partial failures, where your try block might fail before it reached the end, or what to do when the try block completes successfully. And that concludes this presentation on Java try catch blocks.</p></div></div></div><div class="section"><a name="section_12" /><h2 class="section_title">13. Video: Demonstrating Java Try Catch Blocks ( it_sdjcfa_13_enus_13)</h2><img src="https://cdn2.percipio.com/public/b/4f9ab9a7-465c-44a6-9e6c-5f30c213f40d/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/4f9ab9a7-465c-44a6-9e6c-5f30c213f40d/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll see a full example of a Java Try Catch Block, including a finally block. You’ll start in this Main.java by including this in the package com.example. You’ll import the classes needed for this example. In line 3, you have import java.io.FileWriter, because you&#39;re going to write to a file, import java.io.IOException. You’ll see the FileWriter has a problem and it will throw an io exception.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">use try catch blocks within Java
</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Demonstrating Java Try Catch Blocks. Your host for this session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll demonstrate a full example of a Java Try Catch Block, including a finally block. So I start in this Main.java by including this in the package com.example, and I import the classes we need for this example. So in line 3, I have import java.io.FileWriter, because we&#39;re going to write to a file, import java.io.IOException. Because the FileWriter has a problem. It&#39;s going to throw an io exception. Then import java.io.printwriter to help us write to the file. Then import java.util.Scanner, because our input is going to be what&#39;s written to the file. <br /><br />[Video description begins] <em>The IntelliJ IDEA window titled, TryCatchDemo - Main.java appears on the screen. Currently, the Main.java file is opened and displays various lines of code.</em> [Video description ends] <br /><br />So I have public class main, and the main function entry point, and then the code begins on line 11 with Scanner input &#61; new Scanner(System.in); and then I print using System.out.println(&#34;Enter a string:&#34;);</p>
<p>And then on line 14, String str &#61; input.nextLine(); So we&#39;re going to enter some text, hit enter. It&#39;s going to save it in the str variable, and we&#39;re going to write that to the file. On line 16, I create PrintWriter output &#61; null; So we initialize this output variable set to null, because this is what we&#39;re going to use to write. It&#39;s also going to have a handle to an open file, which we need to close when we&#39;re done with it. So I set it to null, just so we can check the state of it if there&#39;s an exception thrown. On line 18, I start my try block, and then System.out.println(&#34;Try: writing to file...&#34;); So I&#39;ve a little message saying that we&#39;re entering the try block and what we&#39;re doing.</p>
<p>Then in line 20, I check the length of the str variable. So if(str.length() &gt; 0) we try to write it to the file. <br /><br />[Video description begins] <em>Line 21 reads output &#61; new PrintWriter(new FileWriter(s: &#34;output.txt&#34;));. Line 22 reads output.println(str);.</em> [Video description ends] <br /><br />Otherwise, so in our else block, we just print Input: empty. So if a string was entered and not just an empty string, we&#39;ll get into the block the if block on line 21, where I set output &#61; new PrintWriter and to its constructor, I pass (new FileWriter ( s: &#34;output.txt&#34;)); So we&#39;re going to open this file output.txt in the current location, and then on line 22, output.println(str); So we write the string. If there&#39;s an exception thrown, I catch it on line 26. So I have a catch of IOException e, which can be thrown by our FileWriter constructor. On line 27, I have System.out.println(&#34;Could not open file for writing.&#34;); and then I print, e.toString to see what the exact exception was.</p>
<p>On line 29, I have my finally block. So no matter what happens, as long as we start processing in this try block, if there&#39;s no exception thrown finally is called, but if there is an exception thrown, and we catch it finally is still called. So this is called no matter what. So in line 30, I check if(output !&#61; null). So if something happens that output cannot be assigned, it will still be null at this point, so we don&#39;t have to do anything. But if it&#39;s not null, it will get into this if block and call output.close(); to close our file handle to the output.txt file we opened. So when you open a file, at some point later on when you&#39;re done with it, it&#39;s important to call close. Else System.out.println(&#34;File not written.&#34;); So if it wasn&#39;t open, I just say file not written because it&#39;s still null at this point and something bad happened.</p>
<p>So now we&#39;ll do a Ctrl&#43;F10. This will run the code. I&#39;ll enter the string test and hit Enter, and it tells me trying to write file, and everything seems fine.<br /><br />[Video description begins] <em>The Main window appears at the bottom of the screen and displays the following text: Enter a String:</em> [Video description ends] <br /><br />If I look in my Project Explorer, I see there&#39;s a file created, output.txt, and it&#39;s contents has test, exactly as expected.<br /><br />[Video description begins] <em>He selects the output.txt file in the Project Explorer pane. The output.txt tab appears on the right side and displays the word, test.</em> [Video description ends] <br /><br />And that concludes this demonstration of programming Java Try Catch Blocks.</p></div></div></div><div class="section"><a name="section_13" /><h2 class="section_title">14. Video: Course Summary ( it_sdjcfa_13_enus_14)</h2><img src="https://cdn2.percipio.com/public/b/d510e967-77d0-40d1-aec8-42f670bfdc8f/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/d510e967-77d0-40d1-aec8-42f670bfdc8f/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll summarize what you’ve learned in the course. You’ve learned how to handle exceptions and how to debug your Java code. You explored how to debug code using the Java JDB tool and IntelliJ. You also learned best practices when debugging Java code. You discovered common syntax and logic errors as well as programming Java exception handling.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">summarize the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Summary.</em> [Video description ends]
<p>In this course, we&#39;ve examined how to handle exceptions and how to debug your Java code. We did this by exploring how to debug code using the Java JDB tool and IntelliJ. Best practices when debugging Java code.</p>
<p>Common syntax and logic errors as well as programming Java exception handling. Common exceptions in Java. Programming Java try catch blocks. And in our next course, we&#39;ll move on to explore how arrays and ArrayLists are designed to handle looping through lists of data.</p></div></div></div><div class="copyright-container"><span class="copyright-text">© 2022 Skillsoft Ireland Limited - All rights reserved.</span></div></div><div id="lb-overlay"><div class="lb-header"><button onclick="(()=>{const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'hidden';const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 1.0;curtain.style.backgroundColor = 'white';curtain.style.pointerEvents = 'auto';})();">X</button></div><div id="lb-image-container"><img id="lb-image" alt onload="(()=>{const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 0.5;curtain.style.backgroundColor = 'grey';curtain.style.pointerEvents = 'none';const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'visible';window.scrollTo(0, 0);})();"/></div><div class="lb-footer" /></div></div></body></html>