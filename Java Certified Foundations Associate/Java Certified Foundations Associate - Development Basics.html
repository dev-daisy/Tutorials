<!doctype html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-style-type" content="text/css2"><title>Course Transcript</title><link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css"><style>:root {
    --title-text: #243038;
    --toc-link: #0073C4;
    --section-title-text: #243038;
    --section-title-border: #bababa;
    --grid-caption-text: #164794;
    --grid-border: #c0c0c0;
    --grid-hdr-text: #973131;
    --grid-hdr-background: #f7f7f7;
    --missing-data: #767676;
    --text-color: #343434;
    --lightbox-border: #a0a0a0;

    --bold-font-weight: 700;

    font-family: Lato;
}

.report {
    margin: 24px;
}

.container {
    position: relative;
}

#lb-curtain {
    background-color: white;
    opacity: 1.0;
}

#lb-overlay {
    position: absolute;
    top: 40px;
    left: 20px;
    right: 20px;
    background-color: white;
    border: solid 1px var(--lightbox-border);
    visibility: hidden;
}

.lb-header, .lb-footer {
    height: 40px;
    line-height: 40px;
}

.lb-header {
    display: flex;
    justify-content: flex-end;
    padding-right: 20px;
}

#lb-image-container {
    margin: 0 40px;
}

#lb-image {
    width: 100%;
}

.report_title {
    font-size: 22px;
    font-weight: var(--bold-font-weight);
    color: var(--title-text);
}

.toc_link {
    font-size: 14px;
    color: var(--toc-link);
    margin-top: 6px;
    margin-bottom: 0;
}

.section {
    margin-top: 40px;
    margin-left: 16px;
}

.section.inner {
    margin-top: 20px;
}

.section.inline {
    margin-top: 20px;
    margin-left: 0;
}

.section_title {
    font-size: 18px;
    font-weight: var(--bold-font-weight);
    width: 100%;
    color: var(--section-title-text);
}

h2.section_title {
    border-bottom-color: var(--section-title-border);
    border-bottom-style: solid;
    border-bottom-width: thin;
}

h3.section_title {
    margin: 8px 0;
}

h3.list_title {
    margin: 8px 0;
    font-size: 14px;
    color: var(--title-text);
}

.section_text {
    font-size: 14px;
    color: var(--text-color);
    margin: 12px 0;
    width: 90%;
}

.section_link {
    font-size: 14px;
    margin: 12px 0;
    width: 90%;
}

.grid {
    border-collapse: collapse;
}
.grid_caption {
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    color: var(--grid-caption-text);
    margin: 12px 0;
    text-align: left;
    white-space: nowrap;
}
.grid_hdr_row {

}
.grid_col {
    font-size: 13px;
    color: var(--text-color);
    border-collapse: collapse;
    padding: 2px;
    text-align: left;
    vertical-align: top;
}
.grid_col_hdr, .grid_row_hdr {
    font-size: 12px;
    font-weight: var(--bold-font-weight);
    white-space: nowrap;
}
.grid_row_hdr {

}

.empty_grid {
    border-collapse: collapse;
    border-color: var(--grid-border);
    border-style: solid;
    border-width: 2px;
    padding: 4px;
    text-align: center;
}

.htmlbox {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    padding: 8px;
}

.list {
    font-size: 14px;
    font-style: italic;
}

.missing_data {
    color: var(--missing-data);
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    font-style: italic;
}

.copyright-container {
    margin-top: 24px;
    text-align: center;
}
.copyright-text {
    color: var(--text-color);
    font-size: 12px;
}

/* Transcript Questions CSS */

.question {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    display: flex;
    flex-direction: column;
    padding: 8px;
}

.question_content {
    display: flex;
    justify-content: space-between;
}

.question_details {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.question_images {
    display: flex;
    flex-direction: column;
    margin-left: 16px;
}

.question_image {
    margin-bottom: 8px;
}

.question_title {
    font-weight: var(--bold-font-weight);
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
    padding-bottom: 8px;
    margin-bottom: 8px;
}

.question_label, .question_stem {
    font-weight: var(--bold-font-weight);
    margin-top: 8px;
    margin-bottom: 8px;
}

.question_data_row {
    display: flex;
}

.question_data_col1 {
    padding: 8px;
    white-space: nowrap;
}

.question_data_col2 {
    padding: 8px;
    display: flex;
    flex-direction: column;
}

.question_answer_key {
    margin-top: 8px;
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
}

.feedback {
    font-style: italic;
}
</style></head><body class="report"><div class="container"><div class="content" id="lb-curtain"><h1 class="report_title">Java Certified Foundations Associate: Development Basics</h1><div class="section_text">Java is a powerful object-oriented programming language that encapsulates data and code in classes using properties and methods. Java uses objects that can interact with other objects. In this course, you&#39;ll learn about the components of a basic Java program such as classes, attributes, methods, and access modifiers.

First, you&#39;ll examine the basics of Java development and the components of a basic program. Next, you&#39;ll learn about Java features, such as constructors, classes, attributes, and methods. Finally, you&#39;ll explore Java access modifiers and how to compile and run Java programs.

This course is one of a collection of courses that prepares learners for Oracleâ€™s 1Z0-811: Java Certified Foundations Associate certification.

</div><div class="section"><h2 class="section_title">Table of Contents</h2><div class="toc"><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_0">1. Video: Course Overview ( it_sdjcfa_06_enus_01)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_1">2. Video: Java Development Basics ( it_sdjcfa_06_enus_02)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_2">3. Video: Java Classes ( it_sdjcfa_06_enus_03)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_3">4. Video: Programming Java Classes ( it_sdjcfa_06_enus_04)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_4">5. Video: Java Class Attributes ( it_sdjcfa_06_enus_05)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_5">6. Video: Programming Java Class Attributes ( it_sdjcfa_06_enus_06)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_6">7. Video: Java Class Methods ( it_sdjcfa_06_enus_07)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_7">8. Video: Programming Java Class Methods ( it_sdjcfa_06_enus_08)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_8">9. Video: Java Constructors ( it_sdjcfa_06_enus_09)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_9">10. Video: Programming Java Constructors ( it_sdjcfa_06_enus_10)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_10">11. Video: Java Modifiers ( it_sdjcfa_06_enus_11)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_11">12. Video: Programming Java Modifiers ( it_sdjcfa_06_enus_12)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_12">13. Video: Compiling Java Programs ( it_sdjcfa_06_enus_13)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_13">14. Video: Course Summary ( it_sdjcfa_06_enus_14)</a></p></div></div><div class="section"><a name="section_0" /><h2 class="section_title">1. Video: Course Overview ( it_sdjcfa_06_enus_01)</h2><img src="https://cdn2.percipio.com/public/b/8b1dd088-8d45-4284-a039-803e1e0f425d/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/8b1dd088-8d45-4284-a039-803e1e0f425d/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">discover the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Overview.</em> [Video description ends]
<p>Hello! Welcome to the course. My name is Peter Adamson and I&#39;m going to be the instructor for this Java Development Basics course. A little bit about myself. I have a background in computer science as well as engineering, and I have spent most of my time working as a security software developer. [Video description begins] <em>Your host for this session is Peter Adamson. He is a Security Software Developer.</em> [Video description ends]</p>
<p>A lot of my career&#39;s focus has been on cybersecurity in conjunction with software development. So in this course, we&#39;re going to describe the features and components of a basic Java program. We&#39;re going to describe the features and components of Java classes. We&#39;ll then demonstrate the features and components of Java classes. We&#39;ll describe the features and components of Java attributes and demonstrate the features and components of Java attributes.</p>
<p>We&#39;ll describe the features and components of Java methods, and demonstrate the features and components of Java methods. We&#39;ll describe the features and components of Java constructors and demonstrate the features and components of Java constructors. We&#39;ll describe the features and components of Java modifiers and demonstrate the features and components of Java modifiers. And finally, we&#39;ll compile and run a basic Java program from the command line.</p></div></div></div><div class="section"><a name="section_1" /><h2 class="section_title">2. Video: Java Development Basics ( it_sdjcfa_06_enus_02)</h2><img src="https://cdn2.percipio.com/public/b/ae442cb0-eb4a-4d02-a832-30be84e24bf1/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/ae442cb0-eb4a-4d02-a832-30be84e24bf1/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe features and components of a basic Java program</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Development Basics. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>A Java class is a logical entity that we can use to create objects out of. You can think of the class like a blueprint or a set of instructions that tells an object what it should contain when it&#39;s being created. So to that end, within a Java class, we have various components that make up what that blueprint is. The first component of a Java Class is its Attributes. You can think of Attributes like variables. Basically an attribute of a Java Class is a defined instance variable that exists within the class.</p>
<p>So this could be an example, int a &#61; 1, as we see on the screen in the graphic bubble. Basically, it&#39;s defining, this class will always have this variable as part of it. This is an attribute of the class. And then we can manipulate those attributes or those variables in various different ways, depending on how they&#39;re defined. We can either manipulate them directly or indirectly through the use of something like a class method.</p>
<p>A class method is a logical function block that has a set of code that we can run repeatedly. Every time we call a Class Method on an object created out of that class, we can run the code contained within that Method. So a good example of a common class method is called a getter. And a getter would be used to retrieve the value of an attribute and return that value to us somewhere else in the program. Similarly, we also have setters, and setters are a class method that we can call on an object to set the value of an attribute.</p>
<p>So oftentimes these Attributes and Methods go hand in hand. The attributes provide constant values or dynamic values that we can feed into these Class Methods in order to do whatever the class needs to do. And then on those attributes and class methods, we can apply Java Modifiers. We have two types of Modifiers. The first are Access Modifiers and these are modifiers that control who and what can access certain attributes or certain class methods and how they can access those methods.</p>
<p>Examples of Access Modifiers are public, private, and protected. And each one means a different thing. So if we&#39;re looking at a Java attribute, a public attribute means, if we have an object created out of a class, then we can access that public attribute directly. We can just call on that object and modify that attribute to our heart&#39;s content. A private attribute means that we can&#39;t do that necessarily in the same way. We can&#39;t just access the attribute directly on an object.</p>
<p>Instead, we need to have some sort of method that allows us to access that attribute, because a private attribute is only accessible within the class that it exists inside of. So if you create an object out of a class, only methods or other attributes inside that class have access to a private attribute. Protected is a different kind of Access Modifier. It&#39;s not nearly as often used as public or private, but it defines things as being visible within a Java package as a whole, but not outside of the Java package.</p>
<p>But most often you&#39;re either using public or private, as your Access Modifier. The public or private works the same on class methods. A public class method can be accessed by anybody within the Java program, whereas a private class method can only be accessed by other methods or attributes within the class that it&#39;s defined in. Then we have other types like Non-access Modifiers. Non-access Modifiers are more about defining the behavior of an attribute or a class. So, for example, a Non-access Modifier is final.</p>
<p>We use final on an attribute if we don&#39;t want the value of it to be changed after it&#39;s defined. So if I were to, say, have the constant of gravity within my program, 9.8 meters per second squared, then there&#39;s a good chance that&#39;s not going to change. So I would define it as final. And then no matter what, if somebody tries to overwrite my gravity value, or tries to change it in some way, it won&#39;t work because I&#39;ve defined it as final. So you can&#39;t change that value.</p>
<p>We also have other Non-access Modifiers like the keyword abstract, which we can use to create abstract classes. Abstract classes are classes that can&#39;t be used to directly create an object out of, but instead define subclasses that would implement the abstract class, and then they&#39;re making a promise to implement whatever is defined within that abstract class. We can also apply the keyword abstract to attributes, and we would do that within an abstract class.</p>
<p>So abstract classes would have abstract attributes. We could also use a Non-access Modifier like static. If we apply the keyword static to, say, a class method, what that means is that we can call that method directly on a class. We don&#39;t necessarily need to have an object created out of that class in order to call that method. So if I have a static method inside of a test class, I could just call test dot whatever the name of the static method is. I don&#39;t need to first create an object and call that method. These are the two different Modifier types in Java and what they&#39;re used for.</p>
<p>Let&#39;s take a closer look at Java Class Attributes. This can be confusing sometimes because Attributes are called by many different names. They can be called Attributes, or instance variables, or fields. And in essence, they all mean the same thing. Sometimes they have slightly different connotations behind them, but they&#39;re all referring to these Java Class Attributes. So let&#39;s look at the different names that you might see and what they might mean. I mentioned earlier that you could think of them like Variables because they are Variables. A variable is just a piece of data that houses a dynamic value of some sort.</p>
<p>The value can change, it can be modified, it can be typecast into a different type of variable. You might also hear the word Fields used. And really the only difference between a Variable and a Field is semantic. A Variable becomes a Field once it&#39;s assigned an access modifier like public or private. And then we have what we&#39;ve been talking about all along, which are Attributes. Strictly speaking Attributes are publicly access modified. And we have Properties which are privately modified.</p>
<p>These are all the different semantics associated with Java class attributes. Taking a similar look at Java class methods, we can see all the different things that can be applied to them. So we talked about access modifiers earlier. Java class methods can be public or private or protected. They can be static or non-static. Once again, that means that static, you can call the method directly on a class, whereas non static methods, you first need to have an object created out of the class and then call the method on the object.</p>
<p>And you can have them abstract versus concrete. If you define a class as abstract, you can&#39;t create an object out of it. If you define it not being abstract, therefore, by default, it&#39;s concrete, then you can create an object out of it. And these class methods are used to execute repeated pieces of code. Taking a similar look at Java class methods, we can see all the different things that can be applied to them. So we talked about Access modifiers earlier. Java Class Methods can be public, or private, or protected.</p>
<p>They can be static or non-static. Once again, that means that static, you can call the method directly on a class, whereas non-static methods, you first need to have an object created out of the class and then call the method on the object. And you can have them abstract vs. concrete. If you define a class as Abstract, you can&#39;t create an object out of it. If you define it not being Abstract, therefore, by default, it&#39;s Concrete, then you can create an object out of it.</p>
<p>And these class methods are used to execute repeated pieces of code. And the final component of a Java class that I&#39;m going to talk about are Java Constructors. Java Constructors are a very special type of class method, and they&#39;re special because this class method is called automatically whenever an object of a class is created. So if you were to create a new object with the new keyword, then this constructor is run automatically.</p>
<p>You don&#39;t need to call the method explicitly. It&#39;s just going to run. So it&#39;s a good way to set up default values in a Class or within an object once it&#39;s created out of a Class. And you can have a constructor within any Java Class. Actually, all Java Classes have a constructor by default, even if you don&#39;t explicitly define one. Now, the default constructor doesn&#39;t really do anything, but it&#39;s still there.</p>
<p>But you define a Java Constructor by creating a method within a Class that is the exact same name as the Java Class and it has no return type. You can also have constructors within Abstract Classes, but you cannot have constructors in Interfaces. Interfaces are another extension or another type of abstract class, but they&#39;re defined in such a way that you can&#39;t put a constructor within the Interface. Rather, anything that implements the Interface will have to build its own constructor.</p></div></div></div><div class="section"><a name="section_2" /><h2 class="section_title">3. Video: Java Classes ( it_sdjcfa_06_enus_03)</h2><img src="https://cdn2.percipio.com/public/b/0682bd74-8dc7-471e-a55a-dbda9b6a2bdd/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/0682bd74-8dc7-471e-a55a-dbda9b6a2bdd/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the features and components of Java classes</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Classes. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Let&#39;s take a deeper dive into Java Classes. The majority of Java Classes consist of two things: the Attributes which are variables in the class, are instance variables. These can be integers, floats, strings, doubles, all kinds of different types. And they also have Methods which are the actions that these classes can take to modify and return these attributes to other parts of the program.</p>
<p>The primary use case for classes is to create objects out of them. So our objects are created using the template defined within the class. When we create an object out of a class, there are certain components that go along with the object. The first one is the State. So this relates to the attributes of the class. When we have an attribute defining the class, say, an integer, it&#39;s just there, but it&#39;s not necessarily being used.</p>
<p>We could have int i &#61; 1. Now, when we have an object, that integer suddenly represents the state of the object. If that integer i is still equal to 1 in the object, then that&#39;s representing a State. So, for example, we see on the page that there is a cat symbol within our bubble. Some things that might become states with a cat object are things like fur color, eye color, age, and height. All these different things that would describe what the cat object looks like would become state elements of our object.</p>
<p>Objects also have a certain behavior. So this is describing what the object does. And this relates to the class methods that are defined within the class. So if you have a method within a cat class called walk and then you create an object out of the cat class, you could then describe that walk method as being a Behavior of the Object that you have instantiated, because you could call that walk method on the object and then the walk method would do whatever it is that it&#39;s supposed to do.</p>
<p>Most likely it would tell the cat to move forward or backward or side to side. And finally, Objects have an Identity. So when you create an object out of a class, the internals of the Java virtual machine assign it a unique identifier so that Java will know this object is always taking up this part of our memory. This memory is allocated for the object, so whenever we need to access it, we go here to do that. And that&#39;s because you can create any number of objects out of the same class.</p>
<p>So if we created two cat objects, one with a cat fur color of brown and one with a cat fur color of black, we don&#39;t want Java to think that they&#39;re the same object because they have two distinctly different fur colors. So we would actually have two different, distinct objects that were both created out of the cat class and Java knows that they&#39;re different because they have different identities. In Java, we have special types of classes.</p>
<p>One type is an abstract class and an abstract class is special because it&#39;s a Restricted Class, and what that means is you can&#39;t use this Class to directly instantiate an object. We can&#39;t use the key word new to create an object out of this Class. First, another class has to inherit the Abstract Class before we can actually use it to create an object. And then we create an object out of the Class that has inherited the Abstract Class. And any class that inherits an Abstract Class has to implement whatever Abstract methods are defined within the Abstract Class.</p>
<p>So an Abstract class will have these Abstract methods and these Abstract methods define the skeleton structure of the method. It would have the method name, the return type, any arguments that go past to the method. But it doesn&#39;t actually have the body of the code, doesn&#39;t specify what the method does, but it does tell any class that inherits an Abstract Class with an Abstract method that it needs to implement this specific method with this specific return type, and these specific arguments.</p>
<p>But how you do it is up to you. Abstract Classes can also have Regular methods, they&#39;re not restricted to only having Abstract methods. And basically, what these Abstract Classes are doing is they&#39;re making a promise. If you inherit from an Abstract Class, you&#39;re promising to adhere to the structure laid out in the Abstract Class. And it&#39;s a way of creating more formal, defined program structures within your code.</p>
<p>Some of the things to keep in mind when we&#39;re dealing with Abstract Classes, they can have Constructors and the Constructor gets called whenever a Class that has inherited an abstract Class is used to instantiate an object. And then the Constructor defined in the Abstract Class will be called. You can have Static methods within an Abstract Class, but you can&#39;t have methods that are both Static and Abstract at the same time, so you need to have one or the other.</p>
<p>You can&#39;t have a Static Abstract method. Similarly, with Final keyword. You can have Final methods and you can have Abstract methods, but you can&#39;t have a Final Abstract method. To make a class Abstract, the abstract keyword has to be placed in front of the class keyword. So if you had a paper class, your declaration would be public, abstract, class, paper.</p>
<p>If you wanted to make a Method Abstract, it goes in front of the return type so you would have public abstract int, for example, as a return type. And it&#39;s important to get the order correct, otherwise Java won&#39;t recognize that you are trying to make an Abstract Class and you&#39;ll get an error. Methods within an Abstract Class, as we mentioned, can be either Abstract or Non-abstract. You have the choice. And object instantiation has to be done from a Class that&#39;s inherited from the Abstract Class, not the Abstract Class itself.</p></div></div></div><div class="section"><a name="section_3" /><h2 class="section_title">4. Video: Programming Java Classes ( it_sdjcfa_06_enus_04)</h2><img src="https://cdn2.percipio.com/public/b/5c853227-b845-46d9-904a-36faaa6f6086/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/5c853227-b845-46d9-904a-36faaa6f6086/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the features and components of Java classes</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Classes. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this video, we&#39;re going to demonstrate the features and components of Java classes. I&#39;ll be working within an IDE, which is a development environment. The one that I&#39;m using is IntelliJ, but there are many different options available on the market.</p>
<p>So take a look around and see what one you like the best before deciding on which one you want to go with. You don&#39;t need to use an IDE. You could also do your development in a plain text editor like Notepad, but you&#39;ll find an IDE makes your life a lot easier. So the first thing we&#39;re going to do is create a Java class to look at what kind of features it has.</p>
<p>So I have a project started. We can see the Project tree on the left-hand side of my screen and within the src folder, I&#39;m going to create a new &#34;Java Class&#34;. [Video description begins] <em>The host right-clicks on the folder labeled src and chooses New which is the first option on the menu that appears. This option opens a further submenu to the right where the host clicks on the first option: Java class. A dialog window appears with a required field to specify a name for the New Java Class.</em> [Video description ends]</p>
<p>And we&#39;ll call this Employee.java. And I&#39;m giving my file name a capital E for the first word, and that convention with classes is to capitalize every word in the name. So now I have an Employee class created. Now, I created a Java class using the IDE, but there&#39;s nothing special going on yet right now. This is the same as if you created a normal text file, saved it as Employee.java and typed in the text you see on the screen. [Video description begins] <em>Line 1 reads: public class Employee {.</em> [Video description ends]</p>
<p>So here we see some of our first features of a class. When we&#39;re defining a class, there are certain keywords we need to put in. The first one defines the visibility of the class to our overall Java project or package. In this case, it&#39;s public. Classes will almost always be public. You may run into some niche scenarios that require you to use a different visibility, but in general, public will be suitable for almost all of your purposes.</p>
<p>Once we define the visibility as public, that means that other classes within our Java package can utilize this class and make objects from this class, which we&#39;ll talk about a little bit more later on. The next keyword is class. And this is what tells Java that we are defining a Java class. So we put it in public class and then the name of our class, which we have defined as Employee. Once again following the naming convention, which is capitalized for every word in a class name.</p>
<p>An important feature of a class name, it can be anything that you want it to be, but it must match the name of your file. So because I&#39;ve called my file Employee.java, my class name has to be Employee. If I were to add EmployeeTest, now we can see that there&#39;s a red line underneath my class name because Java has detected that there&#39;s a mismatch between the class name and the file name. And then we have the curly braces: an open curly brace and a closed curly brace, which defines the boundaries within where I can define features of the class.</p>
<p>So everything that I put into the class will be between these curly braces. Now, let&#39;s go over some of the things that we can put into a class. And don&#39;t worry too much if some of them seem a little unfamiliar, we&#39;ll go over in more detail in future videos, everything that I&#39;m talking about here now. The first thing that we can put in is called an instance variable or a field. And this is simply a variable that we define within the class.</p>
<p>So, for example, if I wanted to have an employee number, I could define a private int employeeNum &#61; 5; [Video description begins] <em>The host types in line 2: private int employeeNum &#61; 5;.</em> [Video description ends] and now I have to find an instance variable within my class. Instance variables don&#39;t necessarily have to have a value. We could have a private String representing the employee&#39;s name and we could just leave it as null, which is the default assignment if I don&#39;t give it a specific value. [Video description begins] <em>The host types in line 3: private String employeeName;.</em> [Video description ends]</p>
<p>The next feature that a class can have is a class method. And class methods are used to manipulate or return the values associated with our class fields, among other different operations that you might want to carry out. So, for example, we might have a class method called setEmployeeNum, and within that method, we would manipulate the class field or instance variable by setting our instance variable to the argument that we pass into this set class method. [Video description begins] <em>Line 5 reads: public void setEmployeeNum (int n){. Line 6 reads: this.employeeNum &#61; n;. Line 7 reads: }.</em> [Video description ends]</p>
<p>So that&#39;s another feature that we can have in a class, is a class method. Class methods don&#39;t have to necessarily interact with instance variables. They can be completely standalone, operate on the argument passed to them and return a different value. It all depends on the functionality you want, but that&#39;s what we use class methods for. Another feature of a class is its constructor. A constructor is a special class method that runs when an object is created out of that class. And this method just runs automatically on creation.</p>
<p>The key to a class method that is a constructor is that a constructor doesn&#39;t have a return type. So we can see our class method setEmployeeNum has a return type of void. When we make a constructor, we won&#39;t have any return type. We&#39;ll still have the public visibility, [Video description begins] <em>The host types in line 5: public.</em> [Video description ends] but all we&#39;ll have is the name of the method. And the other special part about a constructor in a class is that the constructor name is going to be the same as the class. It must be the same as the class.</p>
<p>So we will say public Employee(){. [Video description begins] <em>Line 5 reads: public Employee(){.</em> [Video description ends] Now we&#39;ve defined a constructor and we&#39;ve defined the constructor because there is no return type and the name of the method is the same as the name of the class. So when an object is created, this will run automatically by default. So let&#39;s say we wanted our Employee class to have a default name and we didn&#39;t define it in an instance variable.</p>
<p>We could manipulate it here by saying this.employeeName &#61; &#34;default&#34;; [Video description begins] <em>The host types in line 6: this.employeeName &#61; &#34;default&#34;;.</em> [Video description ends] and now when an object is created out of this class, this constructor will run automatically and our employeeName instance variable will have the value of default. The next feature that I want to talk about of Java classes is how we use them. So let&#39;s keep that public class Employee here and now we&#39;ll create a new Java class. And we&#39;re going to call this one Employer.java.</p>
<p>Now we have a new class, which is called Employer. And we want to, within our Employer class, make use of that set employee number class method that we defined in our Employee class. So in order to do that, we need to create an object out of the Employee class. And that&#39;s the feature that I want to talk about now, is, classes are used to create objects out of them. So we are going to create an object of type Employee, called obj1. And we&#39;re going to set it equal to a new instance of Employee.</p>
<p>So this is telling Java, [Video description begins] <em>Line 2 reads: Employee obj1 &#61; new Employee();.</em> [Video description ends] I want to create an object out of the Employee class and the key items to look at here are the type, which is type Employee, which matches the class name. And the key word new, which tells Java that I want to create a new object out of the class. There&#39;s no limit to how many objects can be created out of the same class, so if I wanted a second Employee object, I could define obj2 &#61; new Employee(); once again. [Video description begins] <em>The host types in line 3: Employee obj2 &#61; new Employee();.</em> [Video description ends]</p>
<p>And these will be two distinct objects, even though they&#39;re created out of the same class. And now object one and object two will have access to all of the various class methods that I&#39;ve defined within the Employee class. So they&#39;ll have the ability to setEmployeeNum, they&#39;ll have the ability to run this constructor, which will be run by default on creation. And the advantage to this is that classes allow us to save a lot of code reuse. We want to have many different employees and now I can create many different employees.</p>
<p>I never have to touch or modify the Employee.java class. And the final class feature that I want to talk about is abstract classes. So let&#39;s create a new class called Color.java. And we&#39;re going to make this an abstract class. And we do that by adding the keyword abstract between the visibility identifier and the class keyword. [Video description begins] <em>Line 1 reads: public abstract class Color {.</em> [Video description ends] So we come up with public abstract class.</p>
<p>And abstract classes are special because you can&#39;t create an object directly out of them. Other classes need to inherit these abstract classes in order to create objects using those classes. So you can think of an abstract class like a promise. We&#39;re going to define certain class methods within this abstract class and any other class that makes use of it is promising to implement these specific methods that we define here. So let&#39;s make an abstract method that we want every class that uses this Color abstract class to have.</p>
<p>So now we have an abstract method within our abstract class, [Video description begins] <em>Line 2 reads: public abstract void temperature();.</em> [Video description ends] and what this is saying is when we create another class that inherits this abstract class, we are promising that class will have this void method. So let&#39;s see that in action. Let&#39;s create one more class. We&#39;ll call it Blue.java. Now we want Blue.java, our class Blue, to inherit the abstract color class. We do that with the keyword extends.</p>
<p>And we provided the name of the abstract class. [Video description begins] <em>The host types in line 1: public class Blue extends Color {.</em> [Video description ends] And we can see that there is a red line underneath my first line here because I have not fulfilled my promise yet. I haven&#39;t implemented the abstract method temperature in my Color class. So before Java will let me continue, I need to fulfill that promise. And I do that by implementing the class method that I had defined in the abstract Color class.</p>
<p>And within this class, I can do whatever I want to do. [Video description begins] <em>The host types in line 2: public void temperature () {.</em> [Video description ends] But the important thing is that I have implemented this method and that this method does something. Color.java doesn&#39;t force me to do anything particular, within this method, but it does force me to have this method. So I could do something as simple as System.out.println to print to the terminal &#34;warm&#34; or in this case, since we&#39;re blue, it would be &#34;cold&#34;. [Video description begins] <em>The host types in line 3: System.out.printIn(&#34;cold&#34;);.</em> [Video description ends]</p>
<p>And now everything is okay. So this is how abstract classes work, they force a certain structure to your classes that inherit from them. And we use inheritance with this extends keyword. And in Java, you can only inherit from one class, so a single inheritance. We can&#39;t extend from multiple different classes now that we&#39;ve extended from Color, that&#39;s it, that&#39;s all we can inherit from. And that covers the main features and components of Java classes. So the important points are that we use classes to prevent code reuse and the primary use of a class is to create an object out of that class. And that gives us a lot of power in terms of object-oriented programming.</p></div></div></div><div class="section"><a name="section_4" /><h2 class="section_title">5. Video: Java Class Attributes ( it_sdjcfa_06_enus_05)</h2><img src="https://cdn2.percipio.com/public/b/6907cc16-39d6-4d31-9e85-0a434d279999/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/6907cc16-39d6-4d31-9e85-0a434d279999/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the features and components of Java class attributes</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Class Attributes. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Now we&#39;re going to take a deep dive into Java Class Attributes. Java Class Attributes are known by a few different names, and the differences between them are largely semantic. And we use the different names to refer to how the attributes are actually being used at that given time. Some names that you might see for attributes within a class are Variables or instance Variables, Fields, Attributes, and Properties.</p>
<p>They&#39;re all referring to the same type of data. It&#39;s just differences in how they&#39;re being used at the given time. So let&#39;s take a look at each one of these in turn and see what they&#39;re referring to in terms of Class Attributes. The first term that we have when talking about Java Class Attributes is Java Variables. Java Variables are the basic storage unit in Java. They contain a value of some sort and that value can be modified or overwritten or reassigned in some way.</p>
<p>The most common type of variable and what often comes to mind first when we talk about Java Variables are the Primitive data types. These are things like your integers, your booleans, your string values, doubles, longs, anything that represents a basic number or a string or a true/false value. We aren&#39;t limited to only these when we&#39;re talking about Variables, though. Our Variables can also refer to Objects. So we could assign a Variable to contain a certain Object and all of the different states that that Object contains.</p>
<p>But at the end of the day, it&#39;s still a value stored in memory. And it&#39;s a value that we can change and overwrite. The next term we have is Java Fields. Now, Fields is still referring to a type of variable or a class attribute, but the difference between a field and a variable is that a field is a variable specifically defined within a class. So once a variable or an instance variable is defined inside of a class, it becomes a field.</p>
<p>Oftentimes, fields are obtained using data access objects, which is a framework that allows you to access underlying persistent storage, which is what these fields are, they&#39;re persistent states or storage of some sort of value in a class. And these fields will have access modifiers. And these access modifiers are telling Java who can modify these fields and how can they modify them. So these are where we get into things like public, private, and protected. Public means that a field can be accessed by anybody.</p>
<p>I can freely modify or update the field to my heart&#39;s content if it&#39;s public. Private means that the field can only be accessed by the class in which is defined. So outside of that class, I don&#39;t have any access to that field if it&#39;s private. And protected is somewhere between the two. It&#39;s available to any piece of code within the Java package, but anything outside of the Java package won&#39;t be able to access that field. And we can also apply the static and non-static modifier to fields. Now, this behaves a little bit differently than if we have static and non-static methods.</p>
<p>The static modifier doesn&#39;t behave the same between the two. When we&#39;re talking about a static field, we&#39;re talking about how many versions of that field get created. So in a non-static field, the field is created new every time the class is instantiated. So if you have an integer i and it&#39;s equal to two by default in the class, then whenever that class is instantiated, a new version of that i field will be instantiated along as a state within that object. And it will always be equal to two. But if you were to make that field static, then only one instance of that field will ever be created.</p>
<p>So if you wanted to have, say, a counter to count how many times an object is created using a class, then you could have a static field within that class and it could be a count field and you could have it set so that in the constructor, every time an object is created, you add one to that field. And then in every object, you will have the most recent version of that field because there&#39;s only one instance of it. Our third term is Java Attributes, and a Java Attribute is a field that has a public access modifier on it.</p>
<p>So once we define something as, say, public int i, now that field is an attribute because it&#39;s public. And to access Java Attributes, we use the Dot syntax. So let&#39;s say that we have an object called phone and phone has a attribute or public field called screen. If we wanted to change the value from flat to curved, we could do that by saying phone dot screen equals curved. And that&#39;s how we access a Java Attribute. So Java Attributes are readable and writeable.</p>
<p>We could also assign a variable to the current value of that phone screen by saying: public string screen equals phone dot screen. And then it would return us the current value of that phone&#39;s screen. If you don&#39;t want an attribute to be writeable, you only want it to be readable, you can use the Final modifier. So maybe we&#39;re making phones that are only ever flat. So we would put our string with the final modifier: public final string screen &#61; flat. And now we can&#39;t change the value of the screen. We can still read it with the Dot syntax, but we can&#39;t change it with the Dot syntax.</p>
<p>And finally, we have Java Properties. A Java property is a field with a private access modifier. So once we have something with the private access modifier on it, it becomes a Property. Let&#39;s take, for example, our phone example again. In this case, for whatever reason, we don&#39;t want our screen field to be accessible outside of our class. In that case, we would have a private string screen &#61; flat, for example. Now, what do we do with these properties or private fields?</p>
<p>We can&#39;t access them outside of the class. So how do we get them? Well, that&#39;s where we implement something like a Getter method. A Getter method is a method that returns the private field or the property to us outside of the class. So what we would do is we would have a get method, something like public get screen. But we have to make sure that the return type of that method matches the type of the property that it&#39;s returning. So in this case, we need to return a string so it&#39;d become: public string get screen.</p>
<p>It doesn&#39;t need to take any arguments because we know it&#39;s just going to return the screen property. So we, just in the body of the method, have return screen or return this dot screen. Similarly, we have Setter methods and these do the opposite of the Getter method. These allow us to manipulate Java properties or private fields. In this case, this would be a void method because it doesn&#39;t return anything.</p>
<p>So we would have something like public void set screen and it would take an argument of a string and then it would assign whatever string is passed to it as the variable to the screen. So if we wanted to change the screen from flat to curved, we would pass curved as a string to the Setter method and then the Setter method would set this dot screen equal to the argument, in this case curved. Let&#39;s take a look at a concrete example of these attributes in use.</p>
<p>On the screen, we have a class called Account, so we can see on line 2 the class declaration, public class Account, telling us what our class is. [Video description begins] <em>Line 2 reads: public class Account {. Line 3 reads: //Account Type Field.</em> [Video description ends] And then on line 4, we have a field, and this field has a couple of different modifiers on it. [Video description begins] <em>Line 4 reads: final static String AccountType &#61; &#34;USD Checking&#34;;.</em> [Video description ends]</p>
<p>First, we have the final modifier, so that means whatever value is assigned to the field, which in this case is called Account Type, that&#39;s the value it&#39;s always going to have. We can&#39;t overwrite it or change it. So the value that&#39;s assigned to AccountType is a String called &#34;USD Checking&#34; and that&#39;s the way it&#39;s going to stay. The next modifier is static. So that means that no matter how many times this class is instantiated or an object is created out of it, there will only ever be one instance of this AccountType. And then we have the type of AccountType which is string.</p>
<p>The next field, which is on line 7, is defined as private, which makes this a property. So we have private BigDecimal balance; we know that it&#39;s type BigDecimal and the name of it is balance, and since it&#39;s private, it&#39;s only accessible within the class that it&#39;s defined in, the Account class. [Video description begins] <em>Line 6 reads: //Property with getter and setter methods. Line 7 reads: private BigDecimal balance;.</em> [Video description ends] So below the property, on lines 9 to 11, we have the getter and on lines 13 to 15, we have the Setter.</p>
<p>So looking at the getter first, it&#39;s public, then it returns type BigDecimal and it&#39;s called getBalance. It doesn&#39;t make any arguments, but it returns this.balance. [Video description begins] <em>Line 9 reads: public BigDecimal getBalance () {. Line 10 reads: return this.balance;. Line 11 reads}.</em> [Video description ends] If we wanted to set the value of balance, we would look at our setter and it&#39;s also public. It doesn&#39;t have a return type, it&#39;s void. [Video description begins] <em>Line 13 reads: public void setBalance (BigDecimal num) {. Line14 reads: this.balance &#61; num; and line 15 reads }.</em> [Video description ends]</p>
<p>And it&#39;s called setBalance. And as an argument, it takes (BigDecimal num) and it will set this.balance &#61; num. And then finally, from line 17 to 19, we have our main method and it prints out whatever the value of AccountType is. So in this case, it will print out &#34;USD Checking&#34;. [Video description begins] <em>Line 17 reads: public static void main (String [ ] args) {. Line 18 reads: System.out.println (AccountType) ;. Line 19 reads} and line 20 reads }.</em> [Video description ends]</p></div></div></div><div class="section"><a name="section_5" /><h2 class="section_title">6. Video: Programming Java Class Attributes ( it_sdjcfa_06_enus_06)</h2><img src="https://cdn2.percipio.com/public/b/52c538f0-b1a9-4a9e-8ce8-25b288d27593/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/52c538f0-b1a9-4a9e-8ce8-25b288d27593/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the features and components of Java attributes</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Class Attributes. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this video, we&#39;re going to show the features and components of Java attributes. To get started, we&#39;ll create a Java class and start to create our attributes within that class. So we&#39;ll go to our IDE or text editor and create a new Java class. And I&#39;m going to call my Java class Att.java. So here we have the skeleton of a Java Class. Now we want to add some attributes to it. And then we&#39;ll talk about what we can do with those attributes.</p>
<p>So when we refer to attributes or class attributes, what we&#39;re really talking about is variables or fields that are defined within that class. So let&#39;s make our first attribute within our Att class. And we&#39;re going to define it as an integer and we&#39;ll call it public int firstAttribute. And now we have our first attribute. [Video description begins] <em>The host types in line 2: public int firstAttribute;.</em> [Video description ends] Now, there&#39;s no limit to how many attributes we can define within a class, so let&#39;s go ahead and define a few more before we start to talk more about these.</p>
<p>We&#39;ll define a second integer. And we&#39;ll say this one &#61; 5. [Video description begins] <em>The host types in line 3: public int secondAttribute &#61; 5;.</em> [Video description ends] Now, let&#39;s define a String. And we&#39;ll define another String. And we&#39;ll give that one a value of &#34;default&#34;. [Video description begins] <em>The host types in line 5: public String thirdAttribute;, and in line 6: public String fourthAttribute &#61; &#34;default&#34;;.</em> [Video description ends] So at this point, we have four attributes within our class. Now, let&#39;s take a look at the various features of each declaration line for the attribute. So the first thing that we&#39;ll notice is in each attribute, we&#39;ve defined the word public.</p>
<p>This defines the visibility of our attribute to the rest of our Java package. There are three different declarations that we can make in terms of visibility. Public is one of them. We could also have a private attribute. [Video description begins] <em>The host types in line 8: private int fifthAttribute;.</em> [Video description ends] And we can have a protected attribute. [Video description begins] <em>The host types in line 9: protected int sixthAttribute;.</em> [Video description ends] What do these visibility modifiers mean? Well, a public visibility modifier means that attribute is visible to anybody.</p>
<p>Anybody that wants to access it and modify that variable or that attribute can do so from anywhere within the code base. A private visibility modifier means that attribute is only accessible within the class that it&#39;s defined in. So I could make a class method within this Att class and it would be able to access a private attribute, but an object created out of the Att class would not be able to directly access a private attribute. Protected is kind of a hybrid between public and private. It refers to an attribute that can be used by the package as a whole, and any subclasses within the package as well.</p>
<p>But generally, you don&#39;t use protected that often, so we&#39;re going to ignore it for now. The important ones are public and private. Those are the main ones that you&#39;ll be using. More often than not, attributes for best coding practices are defined as private. It&#39;s generally better to have your attributes defined as private and then provide what we call getters and setters, which are class methods that will allow other parts of the program to set your attribute values and retrieve your attribute values, rather than allow other objects or other classes to access these attributes directly.</p>
<p>But if you have a need to, you can set the attributes as public and then other classes will be able to access these attributes directly. The next thing that I want to point out is certain attributes, such as secondAttribute here, I&#39;ve defined with a default value of 5, but other attributes like firstAttribute, I haven&#39;t given a value. That&#39;s because you don&#39;t necessarily need to assign a value to an attribute. You can leave it like my firstAttribute or my thirdAttribute, which will just have null values. Or you can have them like my secondAttribute and my fourthAttribute, which have default defined values. And either is suitable.</p>
<p>It just depends on whether you want to have your attribute start with a value of null, or if you&#39;d rather have it start with a certain value. Now, let&#39;s take a look at how we can access these attributes from other classes. So we&#39;ll create a second Java class and let&#39;s call this one Access.java. And within Access.java, our goal is going to be to access and make use of those attributes in Att.java. The first thing that we&#39;ll need is a class method from which we&#39;ll create an object and access these attributes.</p>
<p>In this case, we&#39;re going to use the main method, which is public static void main(String[] args). [Video description begins] <em>The host types in line 2: public static void main(String[] args){.</em> [Video description ends] And it&#39;s within this method that we&#39;ll be creating an object and accessing the attributes. So our first step is to create an object of the Att class. So we will say Att myObj &#61; new Att() and this creates us an object of the Att class. [Video description begins] <em>The host types in line 3: Att myObj &#61; new Att();.</em> [Video description ends] And now let&#39;s access our first attribute.</p>
<p>We&#39;re going to access secondAttribute, and what we&#39;re going to do is simply print it to the command line. And we do that by calling System.out.println and then we&#39;ll say (myObj) to tell it we&#39;re accessing it out of this object and then we use dot which will tell it that I&#39;m going to access an attribute. And I say .secondAttribute. And what this will do is Print 5. It&#39;s just the value of secondAttribute. [Video description begins] <em>The host types in line 4: System.out.printIn(myObj.secondAttribute); // Print 5.</em> [Video description ends] Similarly, I could do the same thing with the string, by calling println(myObj.fourthAttribute), which will be default.</p>
<p>So that&#39;s how I can access public attributes. If I were to try and do the same thing for a private attribute, such as fifthAttribute, we can see that my IDE is not happy with me, and that&#39;s because fifthAttribute has private visibility, which is going to prevent me from directly accessing the attribute like this. So in this case, I would need a class method to access the attribute, which I don&#39;t have. So that makes this attribute inaccessible to me. We could also change the value of the attribute by calling myObj.secondAttribute &#61; 6.</p>
<p>And then if I used the same print line, once again, [Video description begins] <em>The host types in line 7: myObj.secondAttribute &#61; 6; and in line 8: System.out.printIn(myObj.secondAttribute); // Print 6.</em> [Video description ends] now, this would Print 6. The attributes that have no values, I could assign a value to them. I could call myObj.firstAttribute, which currently has no value. I could make that &#61; 10. And then I could once again print out that attribute. And that would print the value of 10. [Video description begins] <em>The host types in line 11: System.out.printIn(myObj.firstAttribute); // Print 10.</em> [Video description ends]</p>
<p>I could create a second object of the same class [Video description begins] <em>The host types in line 13: Att myobj2&#61; new Att();.</em> [Video description ends] and all of the modifications that I&#39;ve made to my first object won&#39;t be made to my second object. So if we remember, I have overwritten in my first object the value of secondAttribute to 6, but if I were to now print out the secondAttribute of my second object, this value is unaffected by my previous change to my first object. So this value is still 5.</p>
<p>So we can have any number of objects and they will all have their own attributes and these attributes are unaffected by changes made in other objects. So that&#39;s how we can access objects and manipulate them and overwrite them. If I wanted to access this private fifthAttribute, I would have to define within my Att class a public class method [Video description begins] <em>The host returns to the previous Java class by clicking the tab with the class name on the top left of the panel.</em> [Video description ends] a getter, which won&#39;t take any arguments, but will just return fifthAttribute. [Video description begins] <em>The host types in line 10: public int getFifthAttribute(){, and in line 11: return fifthAttribute;.</em> [Video description ends]</p>
<p>Similarly, I could define a setter that takes in an integer and assigns fifthAttribute to that value. [Video description begins] <em>The host types in line 14: public void setFifthAttribute(int n) {.</em> [Video description ends] And with these setters and getters, I can now access and manipulate the value of that private attribute. So I could come back to my Access class and define an integer called setTo. And I will say the value of 5 and then I could call that class method on myObj.setFifthAttribute(setTo);.</p>
<p>And then if I were to do another print line, I could use the getFifthAttribute getter and this will Print 5. So that&#39;s how we can access and work with private attributes. The final point that I want to make about attributes is the key word final. [Video description begins] <em>The host returns to the Att.java class and types in line10: private final int sixthAttribute &#61; 10;.</em> [Video description ends] So I&#39;ve defined a sixth attribute and I&#39;ve defined it as an integer equal to 10 and I&#39;ve used the key word final.</p>
<p>Now, what final does is it means that this integer cannot be overwritten. So if I were to try to modify the attribute like I did in Access.java to say, myObj.sixthAttribute &#61; 8, that won&#39;t work because this is a final attribute. It is defined as 10 and it will stay as 10. With final variables or final attributes, there are generally naming conventions. One naming convention is to give it an all uppercase name to indicate that it is a final attribute. So that&#39;s how we can define and use attributes in Java.</p></div></div></div><div class="section"><a name="section_6" /><h2 class="section_title">7. Video: Java Class Methods ( it_sdjcfa_06_enus_07)</h2><img src="https://cdn2.percipio.com/public/b/c3cfb91f-2351-49fd-8401-b340470a5dc9/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/c3cfb91f-2351-49fd-8401-b340470a5dc9/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the features and components of Java methods</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Class Methods. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Let&#39;s take a closer look at Java Class Methods. Java Class Methods are methods that are defined within the body of a class, and you can think of them as blocks of code that perform some sort of functionality and they can perform them over and over again. It&#39;s a routine the class can continually call to perform repeatedly. So an example of a Class Method could be something like print blank spaces. And you would call this Class Method when you wanted to print out a bunch of blank lines to the console in order to format your output to look a certain way.</p>
<p>Just like fields or class attributes, Class Methods also have Access modifiers. So we can have a public Class Method, which means it&#39;s accessible to anybody who wants to call that method. We could have a private Class Method, which means it&#39;s only accessible within the class that it&#39;s defined. And we can have a protected Class Method, which means that it&#39;s accessible within the Java package, but not outside of your Java package. Methods can be Static or non-static, and this is not the same as when we define a field as Static or non-static. The behavior here is different.</p>
<p>A static class method means that we can call that method without actually instantiating an object. We don&#39;t need to create an instance of the class with an object to call that method. Instead, what we could do is if we had a class called pencil and we had a static method within the pencil class called write, we could just use the DOT syntax and say pencil dot write. We don&#39;t need to first create an object, say, yellow equals an instance of that class pencil. We can just call the method directly. A non-static method means that an object has to be instantiated before we can call it.</p>
<p>So if we had a non-static method called erase, we could not just say pencil dot erase. We would have to instantiate an instance of that pencil class, so we could have brown equals a new instance of the pencil class and then we could have brown dot erase. So that&#39;s the difference between static and non-static methods. And our class methods can be either Abstract or concrete. An abstract method is a method that&#39;s defined within an Abstract class with the Abstract modifier, and it defines the name of the method, the return type, any arguments it might take, but it doesn&#39;t define the body of the code.</p>
<p>But it does require that any class inheriting or implementing that abstract class with that abstract method implement that method with some sort of body of code doing something. Whereas a concrete method is the standard declaration of a class method. And in that case, you have all the same things as the abstract method, plus the body of the code defining what the method does without the abstract modifier. In Java, we have what we call Polymorphism, and there are two types of Polymorphism in Java. We have Method overriding and Method overloading.</p>
<p>So let&#39;s take a closer look at both of these to see what they are and what they do. We&#39;ll look at Method Overriding first. Method Overriding is where we have an implementation of a method and then down the line we redefine that method and change what it does, thereby overriding its functionality. This happens when we use inheritance. So if we have one class that&#39;s inheriting from another, we call that class the subclass. And a subclass can use the Super keyword.</p>
<p>And what this will do is it will call the constructor of the class that it&#39;s inheriting from, and that allows us to set up a subclass with its Super class. And once we have a subclass, we can reimplement any method that&#39;s implemented in our superclass in our subclass. And this happens at runtime. It&#39;s called Dynamic binding, and it means that any time we compile and run our program, it&#39;s in the running stage where the program will decide which method to use. And if we&#39;ve overridden a method that was present in our Super class, then it will use our subclasses&#39; implementation of that method.</p>
<p>The nice thing with this is that we can have a method in our Super class and it does one thing, and then in one subclass we wanted to do a different thing. So we override it there. But let&#39;s say in another subclass, we don&#39;t want it to do something different so we can just leave it as it is. And we haven&#39;t had to touch the original method at all in the Super class to have these two different implementations. If you remember, we talked about Abstract classes and interfaces and how we have abstract methods.</p>
<p>So whenever we implement an abstract class by extending it or inheritance, then we also have to implement all of the abstract methods that are within that abstract class. And that&#39;s a form of overriding. We&#39;re overriding the abstract methods with our concrete methods using the definition provided to us. There are some rules we have to follow, though, when we do Method Overriding. The first rule is that the parameter list has to match.</p>
<p>So if the first implementation of the method in the Super class has two parameters as arguments to its method and both parameters are strings, then in our overriding implementation in our subclass, we still have to have two strings as our parameter list. The access modifier that we applied to our method in the subclass that&#39;s overriding the Super classes method cannot be more restrictive than the access modifier in the Super class. So if we have the Super class method defined as public, we can&#39;t define the subclass implementation as private.</p>
<p>It has to be public as well. And finally, there are a select few methods that we can&#39;t override: private methods, static methods, and final methods cannot be overridden. Method Overloading is where we have two methods with the same name, but they perform a different function. So, for example, we might have two methods that have different numbers of parameters. So let&#39;s have our method be called stand. And in one definition of stand, we take in an integer, but we also want to have a behavior where we take in two integers.</p>
<p>So we could have the method defined twice, both times with the name of stand and in the first parameter list, we&#39;ll have one integer, and in the second parameter list we&#39;ll have two integers. And Java will polymorphically at runtime figure out any time this function is called, is it being called with one integer or two? If it&#39;s being called with one integer, it will take the method definition that only has one integer as a parameter. And if it&#39;s being called two, it will take the method signature that has two parameters. We could also have different parameter data types.</p>
<p>So let&#39;s use our stand method again and this time we&#39;ll have one method signature that takes an integer as a parameter. And then we&#39;ll have a second implementation of stand, which takes a string as a parameter. And once again, Java will polymorphically at runtime decide when this method is called, is it being called with a string as a parameter, in which case it will use the method signature that has a string, or is it being called with an integer or int? And in which case it will use the method implementation of int. So Method Overloading is where we have the same name for a method, but different parameters in terms of number or type.</p></div></div></div><div class="section"><a name="section_7" /><h2 class="section_title">8. Video: Programming Java Class Methods ( it_sdjcfa_06_enus_08)</h2><img src="https://cdn2.percipio.com/public/b/6ff2ca49-9e22-49d0-a2f8-a3771d5ee2f4/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/6ff2ca49-9e22-49d0-a2f8-a3771d5ee2f4/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the features and components of Java methods</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Class Methods. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this video, we&#39;re going to demonstrate the features and components of Java methods. So to get started, let&#39;s create a class in which we can define some methods. So I&#39;m going to create a new Java class called A.java. And within this class, we&#39;re going to define some methods that we can talk about.</p>
<p>So first we&#39;ll define a method called public void printThis. And it will take in a String called toPrint. And all it will do is print out the string that it&#39;s passed. Now we have a method that we can talk about. [Video description begins] <em>The host types in line 2: public void printThis(String toPrint) {, and in line 3: System.out.printIn(toPrint);.</em> [Video description ends] So here I&#39;ve created a method. Now let&#39;s go over the individual parts of what I&#39;ve stated. The first part is this keyword public. Now you might be familiar with the visibility of public and private when we&#39;re talking about fields or instance variables. When we&#39;re talking about methods, this public is a little bit different.</p>
<p>There are two different visibility modifiers that you can have on a method: there is public and static. We&#39;ll talk about static a little bit more later on. But for now, let&#39;s stick with public. Public means that in order to use this method, I&#39;ll need to create an object out of class A and then call this method on that object. So that&#39;s what we do when we&#39;re setting the visibility modifier to public. The next keyword is void and this is the return type of the method.</p>
<p>Now, since my method isn&#39;t returning anything, it&#39;s only printing something to the command line, we use the keyword void, and that tells Java this method doesn&#39;t return anything. We&#39;ll show a few other methods that actually have returned types and you&#39;ll see the difference between void and something like int or string. The next keyword is just the name of the method. I&#39;ve called it printThis. It can be anything you want. Method convention is that the start of the first word is lowercase, and then every subsequent word is capitalized to start with.</p>
<p>And that&#39;s called camelCase. Generally, you want to try and make the name somewhat descriptive of what the method is doing. And then we have what we call the method parameters. Method parameters are pieces of data that are passed along to the method, in order for that method to work with those pieces of data. In this case, I am passing a String called toPrint as my parameter. And then I am printing that string to the command line.</p>
<p>We could have any number of parameters. There&#39;s no limit. So I could have another string called toPrint2, [Video description begins] <em>The host adds the second string in line 2 separating it with a comma from the first string.</em> [Video description ends] and we could use that parameter and print it out as well. So we have multiple parameters separated by commas. [Video description begins] <em>Line 4 reads: System.out.printIn(toPrint2);.</em> [Video description ends] And then we have the open braces and the closed braces, which tell the method its starting and ending point. So anything in between those braces is the contents of the method. And then within the method is the code that we want to execute.</p>
<p>So if we wanted to do a method that had a return type of, say, integer instead of void, we could have public int addTwo. And it takes a parameter of n, which will be of type integer. [Video description begins] <em>The host types in line 7: public int addTwo(int n) {.</em> [Video description ends] And what this does is it will take n, which is an integer and add two to it and just return the value with two added to it. [Video description begins] <em>The host types in line 8: return n &#43; 2;.</em> [Video description ends]</p>
<p>And now we have a method that has a return type of int because it&#39;s returning an integer, which will be n &#43; 2. So the advantage of methods in Java is that it allows us to reuse the same code many times on different parameters. So if I wanted to say add two to many different numbers, I could in my code add two to each number individually, or I could call this method and have the method take care of it for me any number of times by simply passing in a different parameter to the method each time. In order to call these methods, since these are public methods, I&#39;ll need an object created out of the class.</p>
<p>So in order to do that, I&#39;m going to create a new Java class called B.java. And in B.java, we&#39;re going to make use of these methods. So in order to make use of these methods, I&#39;m going to create a method within B public void useCase. And this is where I&#39;m going to make use of the methods that I&#39;ve defined within A.java. [Video description begins] <em>The host types in line 2: public void useCase(){.</em> [Video description ends] So because my methods in A.java are public, I need an object to work off of and that object needs to be created using the A class.</p>
<p>So I&#39;ll create an object of type A called obj1, and that&#39;s going to be equal to a new instance of the A class. [Video description begins] <em>The host types in line 3: A obj1 &#61; new A();.</em> [Video description ends] And now I have an object that I can call these public methods on. So if I wanted to call the printThis method, I would say obj1.printThis and it takes two strings as arguments. [Video description begins] <em>Line 4 reads: obj1.printThis();.</em> [Video description ends] Now, I called them parameters earlier. They&#39;re called parameters when they&#39;re defined in the method.</p>
<p>When I actually send concrete pieces of data to the method, we call them arguments. So if I pass it &#34;default&#34; and &#34;default2&#34;, now, these are the arguments that I&#39;m passing to the method, and so what will happen is obj1 will use that printThis method to print out the words default and default2 to the command line, because that&#39;s what printThis does. Now, what about static methods? I talked about them earlier. So let&#39;s talk about those by creating a new static method.</p>
<p>Here we have a static method. [Video description begins] <em>The host returns to the A Java class and types in line 11: static void staticPrint(String print1) {.</em> [Video description ends] Once again, the static method is void because we&#39;re not returning anything. We&#39;re just doing a print statement to the command line. And I&#39;ve called the method staticPrint. It takes one parameter, which is a string called print1, and it prints that to the command line. [Video description begins] <em>Line 12 reads: System.out.printIn(print1);.</em> [Video description ends]</p>
<p>Now, because my method is static, I don&#39;t need an object instance to call this method. What I can instead do is I can call it directly off the class. So I could say A.staticPrint(&#34;static&#34;) and that&#39;s how I can call a static method. [Video description begins] <em>The host returns to the B Java class and types in line 5: A.staticPrint(&#34;static&#34;);.</em> [Video description ends] So we can see the difference here is that to call printThis, which is a public method, I&#39;ve had to create this object, obj1, and then call the method, whereas to use a static method, I&#39;ve simply called the class .staticPrint.</p>
<p>So that&#39;s the difference in how you use public and static methods. We can also do what we call overloading methods and this is where we define two methods with the same name, but they take different parameters. And that allows us to handle multiple different cases where we have different types of data with the same method call. So, for example, let&#39;s create two methods which are overloaded, which simply just return the data that they&#39;re passed.</p>
<p>So our first one will be public int returnValue [Video description begins] <em>The host returns to the A Java class and types in line 11.</em> [Video description ends] and it takes a parameter of int called p, and it simply returns that value. We could also have public float returnValue. And it takes a (float f) and returns f. [Video description begins] <em>The host types in line 15: public float returnValue(float f) {, and in line 16: return f.</em> [Video description ends] Now we have an overloaded method. We can see they both have the same name of returnValue, but they have different parameters.</p>
<p>One takes in an int and one takes in a float and they have different return types as well. One returns an int and one returns a float. I can return to my object where I&#39;m calling methods and I could define two new variables. Let&#39;s call the first one int anInt and we&#39;ll say it equals 5. And then we&#39;ll have a second one float aFloat &#61; 6.7f, to define that it&#39;s a float. Now, we could call that method to get ourselves a return type.</p>
<p>So if I wanted to print these variables, I could do it in a roundabout way by using these return methods, I could say System.out.println, and then I could use my object .returnValue and I could pass it anInt. [Video description begins] <em>The host types in line 8: System.out.printIn(obj1.returnValue(anInt));.</em> [Video description ends] I could use the exact same method call. But I could now pass it aFloat.</p>
<p>So in this case, I haven&#39;t changed the method call, but I&#39;ve passed it two different types of data. One is an integer and one is a float, and Java will decide polymorphically which method it&#39;s going to use based on the type that it&#39;s given. So this overloading of methods can be very useful when developing. So those are the features and components of Java methods and how we can make use of them.</p></div></div></div><div class="section"><a name="section_8" /><h2 class="section_title">9. Video: Java Constructors ( it_sdjcfa_06_enus_09)</h2><img src="https://cdn2.percipio.com/public/b/42d2f34d-920e-47fa-8fc3-79bbc5fe0751/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/42d2f34d-920e-47fa-8fc3-79bbc5fe0751/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the features and components of Java constructors</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Constructors. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Java Constructors are a special type of method in Java that are called automatically when an object is instantiated out of a Class. So class will have a constructor defined. And then when you create an object using that class, this code, whatever is defined in the constructor, is run automatically. behind the scenes for you. In terms of naming, the name of the constructor has to match the name of the class. It has to have a public access modifier.</p>
<p>It cannot be private and it can&#39;t have a return type. So if you have a class called pencil, then your constructor is also going to be pencil. It would be public pencil and then you can take any number of arguments. It doesn&#39;t have to take arguments, but it can if you want it to and then you have the code, to run whatever you want it to run after that. So that&#39;s how we run Java Constructors in our concrete Classes. Our Abstract Classes are exactly the same.</p>
<p>We can define a constructor in an abstract class if we want to, and then any class that makes use of our abstract class through inheritance will automatically call the abstract constructor when an object is instantiated out of it. Interfaces, on the other hand, cannot have constructors. That&#39;s because Interfaces are another special form of abstraction that define just a skeleton of the code but don&#39;t contain any code itself. So if there&#39;s no code there, there&#39;s nothing for the constructor to do. So we can&#39;t put a constructor into it. And just like any other method, we can overload constructors by having multiple different constructors.</p>
<p>And there&#39;s always a default constructor in any Java Class. Even if you don&#39;t define a constructor specifically, there is going to be one that Java will create for you behind the scenes. There are some considerations to keep in mind, when we&#39;re dealing with Java Constructors. The first is the Super keyword. Oftentimes in Java, we&#39;re dealing with inheritance where we have a Super class and a subclass. The subclass inherits from the Super class, and when we want to call the constructor of the Super class, we use the Super keyword. So the Super keyword allows us to invoke the constructor from the subclass.</p>
<p>And this is because constructors aren&#39;t inherited from the Super class. The subclass doesn&#39;t necessarily inherit that constructor, but it does have access to the constructor. So if we want to call it, we use the Super keyword. A slight deviation to that rule is with abstract class constructors, because abstract class constructors are invoked automatically as soon as any class that inherits from that abstract class is instantiated into an object. I mentioned at the beginning of the video that we can have multiple constructors and that they can be overloaded just like any other method. And we do that because constructors can take parameters or arguments.</p>
<p>They can take any number of them, including taking no arguments or no parameters, and so we could overload a method by using the same techniques that we overload other methods. We give it the same name, but we give it either a different number of parameters or different types of parameters. So defining one parameter as an int in one instance as a constructor and defining it as a string in another, or having one parameter in one instance of the constructor or having more than one in another instance. This is how we can overload constructors.</p>
<p>And let&#39;s examine what a constructor actually looks like by looking at a code snippet here. We have a class called Student, which is declared on line 1, and this class has two properties defined on lines 3 and 4. The first is private String firstName and the second is private String lastName. And both are initialized to null. So we&#39;re going to want to use a constructor somehow to give these actual concrete values. And our constructor we can see defined on lines 6 to 9.</p>
<p>It&#39;s defined as public Student. And that&#39;s our constructor declaration because it is public and the name of the method, or constructor, matches the name of the class telling Java, this is a constructor. In this case, our Student constructor takes two parameters: String first and String last. And it sets firstName &#61; first and it sets lastName &#61; last. So when you create an object using class Student, you would pass it two arguments and then the constructor would be invoked to initialize using the parameters to define firstName and lastName.</p>
<p>And let&#39;s look at another Java Constructor example, in this case showing how we can overload Java Constructors. So once again, we have our Student class and we&#39;ve defined three different properties in our class. We have a private String firstName, a private String lastName and a private int that represents the year of graduation called graduationYear. Both strings are initialized to null. So we&#39;re going to want to use our constructor to assign them a value.</p>
<p>And the graduationYear is set to 0. [Video description begins] <em>Line 3 reads: private String firstName &#61; null;. Line 4 reads: private String lastName &#61; null;. Line 5 reads: private int graduationYear &#61; 0;.</em> [Video description ends] And then we have our first constructor, which is from lines 7 to 11, which reads public Student, so there&#39;s our definition telling it to be a constructor because it&#39;s public and it matches the name of our class. And it takes three parameters: String first, String last, and int graduation. And in this Constructor, we use those parameters.</p>
<p>First initializes the String firstName, last initializes the String lastName and graduation sets the graduationYear. But we also have a second constructor as seen on line 13 to 15. So once again, we have the declaration public Student matching the name of the class and matching the name of the first constructor. But in this case, we only take two parameters: String first and String last. We don&#39;t take a graduation year.</p>
<p>And what it does is it calls its own constructor, but using a default graduation year of -1 and using the first and last name that&#39;s passed to the student. [Video description begins] <em>Line 14 reads: this(first, last, -1);.</em> [Video description ends] So the way this works is when you initialize an object, you can either initialize the object with three different arguments and it would use the first constructor or you could initialize it with two arguments and then the second constructor would be invoked, which actually in itself invokes the first constructor by providing a default graduation year value.</p></div></div></div><div class="section"><a name="section_9" /><h2 class="section_title">10. Video: Programming Java Constructors ( it_sdjcfa_06_enus_10)</h2><img src="https://cdn2.percipio.com/public/b/b14bcadd-a9d5-4fd2-98b1-9a1bdb365719/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/b14bcadd-a9d5-4fd2-98b1-9a1bdb365719/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the features and components of Java constructors</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Constructors. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this video, we&#39;re going to demonstrate the features and components of constructors. Constructors are a special type of method that are automatically executed when an object is created out of a class. So in order to take a look at constructors, let&#39;s first create a Java class. So I&#39;m going to create a new Java class called A.java. Now, constructors have to be named in a very specific way. The first rule of a constructor is that it must match the class name. And it has to have no return type.</p>
<p>So let&#39;s look at what a constructor for the A class would look like. We would assign it a visibility modifier like any other method, so we&#39;ll assign it a visibility modifier of public. The name of our constructor has to match the name of our class, so this will be public A and then we will have our open and closed parentheses, followed by our open and closed curly braces. So we can see here that we&#39;ve created a constructor with a name that matches the class name, the return type is absent.</p>
<p>Normally with methods you might be used to seeing something like public void or public int to define what the method is going to return. With a constructor, we don&#39;t have that. So that defines the skeleton of a constructor. Now what do we do with those constructors? Well, in order to demonstrate what the constructor will do, let&#39;s add a few instance variables to our class. We&#39;ll add int var1 &#61; 1; and we&#39;ll say int var2; but we&#39;ll leave it undefined. [Video description begins] <em>The host types in line 4: int var2;.</em> [Video description ends]</p>
<p>Now, we mentioned earlier that constructors are automatically called or executed when an instance of the class is used to create an object. So we might want to have certain variables set by default. So let&#39;s say that we want var2 to be equal to five. We can do it the way that I did at first with var1 where I defined it to be 1, or we can set it up in the constructor to be automatically defined when an object is created. So now when an object of type A is created, the constructor will set the value of var2 to be 5.</p>
<p>For simplicity, let&#39;s make these instance variables public so that we can access them directly, [Video description begins] <em>The host types public in the beginning of lines 3 and 4.</em> [Video description ends] and let&#39;s show how you could use this with another class. So I&#39;m going to create a second Java class called B.java. And we&#39;ll define a normal method, public void display within B. And what we&#39;ll do is create an object out of the A class of type A. So we&#39;ll say A testObj &#61; new A.</p>
<p>So now I will have created an object of class A and the constructor will have automatically run and assigned the value of 5 to var2. So now I could do system.out.println(testObj.var2). And this would print the value 5 to the command line [Video description begins] <em>In line 4 the host types: System.out.printIn(testObj.var2); // print the value &#34;5&#34;.</em> [Video description ends] because it&#39;s been set, even though it hasn&#39;t been explicitly set here on line 4, the constructor has been run and set it here on line 7. If we go back to class B, it might not look like it, but this class actually also has a constructor.</p>
<p>Even if you don&#39;t explicitly define a constructor, Java will automatically create a constructor for you. Now, it doesn&#39;t really do much. You could think of it as just an empty method being there. But the fact remains that class B does, by default, have a constructor. Constructors can also take parameters. So I could say in public A, I could give it a parameter int n. And instead of signing var2 to be equal to 5, I can assign it to be equal to n, and then when I go back to creating my test object, I could pass it a value of five.</p>
<p>And now, when it&#39;s created, the constructor is taking 5 as my argument to its parameters and instead setting var2 to be equal to that value. And now we&#39;ll have the same result, print the value &#34;5&#34; because var2 is still being set to 5, but I&#39;m setting it by passing an argument and in this way I could create more objects with different values for var2. So if I were to create a testObj2 now, [Video description begins] <em>The host types in line 4 of the B class: A testObj2 &#61; new A (6);.</em> [Video description ends] I could call the print line again on testObj2, [Video description begins] <em>The host copies line 5 and pastes it in line 6. He then adds a 2 after testObj.</em> [Video description ends] but this would print the value of 6.</p>
<p>There&#39;s no limit to the number of parameters that we can pass to a constructor, so I could have [Video description begins] <em>The host returns to the A Java class, and adds int i in line 6.</em> [Video description ends] a second integer which sets this.var1 &#61; i. And then I could pass more values into the constructor. And what that&#39;s going to do is set var2 to be 5 when I create this first testObj, and it will set var1 to be 10. Similarly, when I create the second testObj, it will create set var2 to be 6 and set var1 to be 7.</p>
<p>We can see that even though I&#39;ve defined in my A class, var1 &#61; 1, because I have this call in my constructor, this.var1 &#61; i, whatever value I&#39;ve set up here on line 3, will be overwritten by the constructor value of whatever argument is passed for this parameter. And constructors can also be overloaded just like any other method. So I can define a second constructor and let&#39;s make this constructor deal with floats. So I give it one float as a parameter and up on line 5, [Video description begins] <em>The host types in line 12 of class A: public A(float f) {.</em> [Video description ends] I&#39;ve defined a float var3. So with this constructor it will set var3 &#61; f.</p>
<p>Now I have an overloaded constructor. To use that, I can go back to my B class and define a new object. We&#39;ll call it testObj3. And I will pass it 8.7f. Now, because I&#39;ve passed only a single float, Java will use this constructor, the second constructor from lines 12 to 14, instead of my first constructor from lines 7 to 10. And if I were to do a third print statement on testObj3 with var3, it would print the value 8.7. And in this case, var1 would actually still be equal to one because it hasn&#39;t been overwritten by this constructor. So that&#39;s how we can use constructors and the features and components of constructors in Java.</p></div></div></div><div class="section"><a name="section_10" /><h2 class="section_title">11. Video: Java Modifiers ( it_sdjcfa_06_enus_11)</h2><img src="https://cdn2.percipio.com/public/b/e416a8c5-b7ec-43c4-ac85-f5fa75ddcb15/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/e416a8c5-b7ec-43c4-ac85-f5fa75ddcb15/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the features and components of Java modifiers</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Modifiers. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>We use Java modifiers to control the behavior of our data in the code. So, for example, this might restrict certain things like who has access to our data or our variables and how can they use that data? So the first type of modifier is an Access modifier. And these are the ones that are defining who can access our data. So these are things like public, private, and protected. We also have Non-access modifiers and these aren&#39;t concerned with how the data is accessed, but rather how the data behaves.</p>
<p>So these are modifiers like final and static. And we&#39;ll take a deeper look at what these modifiers mean later on in this video. Our access modifiers are private, protected, and public. The private modifier is the most restrictive, so anything defined with a private modifier, like a private method, or a private variable is going to be accessible only to the class in which it&#39;s defined. Other classes won&#39;t have access to whatever is defined as private. And any subclasses that inherit from that class will not have access to anything defined as private.</p>
<p>Protected means that the method or variable defined as protected is accessible to anything within the same Java package as well as any subclass. So if a class inherits from a class with a protected modifier, then anything that is protected will be also available to the subclass. And finally, we have the public modifier, which is the least restrictive modifier. Anything defined as public will be available to any other Java class.</p>
<p>And we have one other access modifier that&#39;s not in this list called package private, and this is the default modifier that&#39;s given to anything that doesn&#39;t have a modifier explicitly defined. So if you define a method as neither private, protected nor public, then it will by default be given the package private modifier. And what this means is that method or variable is accessible to anything within the same Java package.</p>
<p>Let&#39;s examine a very typical Java code framework using Java Data Encapsulation. It&#39;s generally good practice to define your variables within a class as Private. You don&#39;t necessarily want other classes to be able to directly modify your variables. Instead, you want to be able to control how those variables are modified. So just because we have a private variable doesn&#39;t mean it can&#39;t be modified in any way, it just means it can&#39;t be modified directly.</p>
<p>And what we use are public defined methods, and in this case, we&#39;d use something like a Public setter and a Public getter method. And what these do is they allow other classes to set your variables value and retrieve your variables value. And the advantage to this is you can control within those methods how they&#39;re set. So within your Public setter method, you could add checks, first to make sure that the variable is as you expect it to be.</p>
<p>So let&#39;s say you have a Private variable that is of type integer. Well, you might want to check in your setter method before you assign the value to that variable. Am I dealing with the correct type? Is this an integer? And maybe you also only want to allow a range of integers from, say, 10 to 20, so you could also add a check, is this value that you&#39;re trying to set my variable to within the acceptable range?</p>
<p>And if it is, then I&#39;ll allow it. If not, then I&#39;m going to throw back an error and say you can&#39;t set this variable to that value. So it adds this layer of protection by setting up a private variable with these Public methods. We also have a list of some of the Non-access modifiers that are present in Java. So some of the more common ones that you&#39;ll see are abstract, which indicates that there is no body contained within a method or a class. It&#39;s just a skeleton that you&#39;re going to have to implement yourself once you inherit from this class.</p>
<p>Final, which in the case of a variable, means that the value contained by that variable cannot be overridden or modified. Static, which means that the attribute is part of the class itself. So for a method, it means that you can call that method without having to instantiate an instance of that class as an object. These are three of the very common Non-access modifiers that you&#39;ll see.</p>
<p>We also have a few less common Non-access modifiers, things like strictfp, which we use to restrict the rounding and precision of floating point calculations, synchronized, which we use when we&#39;re dealing with multi-threading operations so that we can make thread safe operations in terms of telling Java how many threads can access a certain method or a certain class at a given time. And transient, which restricts data serialization on a class.</p>
<p>Here&#39;s a code snippet showing the use of a Non-access modifier in Java. So we have our public class HelloWorld defined on line 1. And within that we have two fields. We have a final int r &#61; 10 and a final double PI &#61; 3.14159. And since they&#39;re both defined as final, that means that those values can&#39;t be modified or overridden or changed in any way. Below that on line 5, we have our main method declaration, which the body runs from line 6 to 9.</p>
<p>And what it does is it first instantiates an object out of the HelloWorld class called myObj. And then it tries to directly manipulate our two final fields: myObj.r &#61; 50 on line 7 and myObj.PI &#61; 25 on line 8. And we can see in the comments both of these will generate an error. And then finally it tries to do a print statement System.out.println(myObj.r).</p>
<p>But we can see down at the bottom of the screen where it says $javac HelloWorld.java, this program doesn&#39;t compile and that&#39;s because it&#39;s throwing us this error: cannot assign a value to final variable r at myObj.r &#61; 50. And the same error cannot assign a value to final variable PI. So we can see in action the use of the final modifier, preventing our fields from being modified.</p></div></div></div><div class="section"><a name="section_11" /><h2 class="section_title">12. Video: Programming Java Modifiers ( it_sdjcfa_06_enus_12)</h2><img src="https://cdn2.percipio.com/public/b/f0ea291d-8d43-4f32-af01-972567202327/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/f0ea291d-8d43-4f32-af01-972567202327/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the features and components of Java modifiers</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Modifiers. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this video, we&#39;re going to demonstrate the features and components of Java modifiers. Java modifiers are keywords that we can place before classes, fields, methods in order to apply certain effects to them. So in order to take a look at what these modifiers are and what they do, let&#39;s create a couple classes. I&#39;m going to create one Java class called A.java. And I&#39;m going to create a second Java class called B.java.</p>
<p>There are two basic types of modifiers. We have modifiers that are responsible for controlling who can access a certain class or attribute and how they can access that. And we call those access modifiers and we have a second type of modifier that is responsible for defining the functionality of the data. So what is the actual class doing or what is the actual instance variable doing and how is it doing that? We&#39;re going to start by looking at access modifiers and we actually have an access modifier present already in the skeleton of our A.java class on line 1.</p>
<p>That access modifier is public. So let&#39;s start by talking about access modifiers on classes. For classes, we only have two options. We have the default option, which is where no modifier is explicitly defined. And by default, if you don&#39;t explicitly define an access modifier, then a class will only be able to be accessed by other classes in the same Java package. Alternatively, if you define a class as public, then that means that the class can be accessed by any class, no restrictions there. Almost always your classes are going to be public.</p>
<p>Very rarely will you be not explicitly defining them as public. But there might be some niche cases where you don&#39;t want your class to be public. Now, when it comes to things like instance variables or methods, we have a few more options. So let&#39;s define a public int mod &#61; 5. The name and the value aren&#39;t necessarily important for this demonstration. What&#39;s important is, again, this keyword public. But I mentioned that we have a few more options when it comes to things like methods and instance variables. So let me make a few more instance variables using the different options and then we&#39;ll look at what each of them does in turn.</p>
<p>My second option will be private int mod2. And then I will just define a variable or an instance variable without any modifier at all; mod3 will be equal to 7. And it will be type int. And then finally, we&#39;ll have a protected int mod4 &#61; 8. So these are the different options that we have when we&#39;re looking at instance variables or methods. A public modifier means that this variable is accessible to all classes directly. A private modifier means that this variable is only accessible within the class in which is defined.</p>
<p>When I don&#39;t define a modifier that means that Java will use the default behavior, which will make this variable only accessible in the same package in which it&#39;s defined. Protected is the same as without declaring a visibility modifier in that it&#39;s only accessible in the same Java package, but it&#39;s also accessible to any subclasses. So any class that inherits class A will also be able to access this protected variable. So to see how we would use each variable differently, I will create an object of type A in class B. [Video description begins] <em>In line 2 the host types: A obj &#61; new A();.</em> [Video description ends]</p>
<p>And now I have an object that I can access the variables in different ways. So to access mod, because it&#39;s public, I could do System.out.println(obj.mod). [Video description begins] <em>In line 3 the host types: System.out.println(obj.mod);.</em> [Video description ends] And I will encapsulate this within a method to make it functional. [Video description begins] <em>The host clicks Enter in line 1 and in line 2 types: public testMethod() {.</em> [Video description ends] So this will print out the value of mod.</p>
<p>Now, if I were to try to do the same thing for a private variable, this will give me an error. Because I can&#39;t access mod2 directly. [Video description begins] <em>In line 5 the host types:System.out.printIn(obj.mod2);.</em> [Video description ends] I&#39;m no longer inside of the class in which mod2 is defined and mod2 is private. So in order to access mod2, I would have to have some sort of getter and setter available to me, which would be a method inside of class A that would allow me to access mod2.</p>
<p>But as it stands, I have no way of accessing mod2 outside of the A class. For mod3, it will still work. I can print out the value of mod3 by accessing it directly because I am working in the same Java package that mod3 was defined in. And similarly, I can print out the value of mod4, because once again, I&#39;m working in the same package as the mod4 was defined in. Access modifiers on methods work exactly the same as they do on fields or instance variables. So if I wanted to provide a method that would allow me to get the value of that private variable that we have, I could do that by defining a public int getMod2.</p>
<p>That would return mod2. And now because this method is public, I can use it to get access to this private instance. And I could do that by going back to my B class and calling System.out.println(obj.getMod2()), and this will print the value of mod2. [Video description begins] <em>Line 8 reads: System.out.println(obj.getMod2()) // print the value of mod2.</em> [Video description ends] So that&#39;s how we can use these modifiers in tandem. We can use these public modifiers on methods in tandem with private modifiers, on variables to work together. If I have a method that I don&#39;t want to be able to access outside of class A, I can define it as private.</p>
<p>So, for example, private int getMod could return mod. And in this case, I can only use this method within class A. If I tried to go to class B and call System.out.println(obj.getMod()), this will give me an error because that method is private and not public. I mentioned at the start of this video that there are two types of modifiers. Up till now we&#39;ve been talking about access modifiers. The second type of modifiers, where the modifiers that control more of how the data is handled rather than how it can be accessed and these are called non-access modifiers.</p>
<p>Non-access modifiers can actually be used in tandem with access modifiers. So I&#39;ll be adding our non-access modifiers onto our existing variables that already have access modifiers applied to them. The first non-access modifier that I want to talk about is final. So I can add to my instance variable mod the key word final to make it public final int mod &#61; 5. And what this will do is set mod in such a way that it cannot be overridden or changed or modified in any way. The value that it is assigned right now, of 5, is the value that it will stay.</p>
<p>So in my B class, if I were to say obj.mod &#61; 6, that will give me an error because I&#39;m trying to modify a final variable and I&#39;m not allowed to do that. And we can see my IDE is telling me there&#39;s a related problem because I&#39;m trying to modify a final variable. The next non-access modifier that I want to talk about is static. So we&#39;ll use static in a method by defining public static int returnAnInt. And this will just return the value 7. So we have defined here by using this non-access modifier static, that this method is a static method.</p>
<p>And what that does is tell Java I can access this method on an instance of a class directly. I don&#39;t need to create an object first to access that method. To see that in action, over here in the B class, up until now, I&#39;ve been accessing all of my methods on an object, but now that A has a static method, I can print out A.returnAnInt directly. And this will print the value 7. And I didn&#39;t need to create an object first, I can do it directly on the class. Going back up to our class A, there are non-access modifiers we can use on classes as well. One of those is final.</p>
<p>Now, this behaves a little bit differently than when we defined final on an instance variable. Final on a class means that this class cannot be inherited. So if I was to try and inherit A on class B, it will give me an error because A is a final class and I&#39;m not allowed to inherit from it. The final modifier that we&#39;re going to talk about is abstract. In order to talk about that we&#39;ll create a third class, C.java and this will be an abstract class. And we define it as an abstract class using the non-access modifier abstract.</p>
<p>So we have public abstract class. And what this means is that C as a class cannot be used to create objects out of it directly. So if I were to go back to B.java and try to create an object of type C, it will give me an error because C is abstract and cannot be instantiated. So I can&#39;t use it directly like that. Instead abstract classes are inherited and when we inherit an abstract class, we have to implement all of the things defined within the abstract class. What gets defined within an abstract class? Well, usually we define an abstract method.</p>
<p>So I might have public abstract int absMethod. And this uses a non-access modifier abstract on a method to create a framework within this abstract class saying if you inherit this abstract class, you have to implement this method. Now you&#39;ll see an abstract method doesn&#39;t have a body of code after it. It&#39;s just a framework defining in the name of the method and saying that it&#39;s abstract. When we implement the abstract class C through inheritance, we would have to define our own code within the absMethod. What we define absMethod as doing is up to us, but it has to be there. And that covers the features and components of Java modifiers.</p></div></div></div><div class="section"><a name="section_12" /><h2 class="section_title">13. Video: Compiling Java Programs ( it_sdjcfa_06_enus_13)</h2><img src="https://cdn2.percipio.com/public/b/731e8449-24e3-43fe-8622-7794d8a5e811/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/731e8449-24e3-43fe-8622-7794d8a5e811/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">compile and run a basic Java program from the command line</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Compiling Java Programs. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this video, we&#39;re going to put together everything that you&#39;ve learned so far in order to create a basic Java program and show how we can go from code to compiled code with a Java program that we can run. The first thing that we need is code that we can run, so let&#39;s create a few Java classes in order to create our code package. We&#39;re going to create a simple Java program that will ask for user input to give us a sentence or a word or a string of any sort, and then our Java program will read that word in, reverse it and print out the reversed word or string back to the command line.</p>
<p>So our first class will be a class designed to get user input. So we&#39;ll create UserInput.java. And in this class, we&#39;re going to import the scanner package from Java in order to use it to get user input. So at the top we&#39;ll do import java.util.Scanner. Now we can utilize that scanner class to get user input. So within our user input class we&#39;ll define an instance variable to store the user input. So we&#39;ll define a private String. And leave it as null. And now we&#39;ll create a method that will ask the user to input a string and then we&#39;ll assign that inputted value to inp.</p>
<p>Now we&#39;re going to create a class method that will read in the user input and assign the user input into our string value inp. So the method will be public void, because we&#39;re not going to return anything, getUserInput, and it takes no parameters because it does not need to take any parameters. And now within our method, we&#39;re going to create a new Scanner object. We&#39;ll call it sc &#61; new Scanner and as a parameter, or an argument, we&#39;ll pass it System.in. Next we&#39;ll print out a line to the console to let a user know what they&#39;re supposed to do.</p>
<p>And then we will read the next line that the user types in and assign that value to inp. [Video description begins] <em>In line 9 the host types: this.inp &#61; sc.next();.</em> [Video description ends] So now we have a class that will get user input and assign it to a value. We also want to have a way to retrieve this value from our main class. So we&#39;ll have a public String getInp And this will return the value of inp. Now, our second class will be a string reverser class, so let&#39;s create a new class called StringReverser.java.</p>
<p>And we&#39;re going to use a static method within the StringReverser class, which will return a String called reverser. And it takes as a parameter a String s. [Video description begins] <em>In line 2 the host types: public static String reverser(String s){.</em> [Video description ends] To reverse the string, we&#39;re going to use the string builder class, so we&#39;ll create a new StringBuilder called sb. [Video description begins] <em>In line 3 the host types: StringBuilder sb &#61; new StringBuilder();.</em> [Video description ends] And then we will append our parameter to our StringBuilder class. [Video description begins] <em>Line 4 reads: sb.append(s);.</em> [Video description ends]</p>
<p>And we will return the reversed string. [Video description begins] <em>In line 5 the host types: return sb.reverse() . toString();.</em> [Video description ends] And that&#39;s all we need there. So finally, we&#39;ll create a third class and this will be our main class. This will be our driver. So this will be called Main.java and within our Main class we&#39;ll define our Main method. And this is where our Java program will start its execution. [Video description begins] <em>In line 2 the host types: public static void main(String[] args) {.</em> [Video description ends] So the first thing that we want is an instance of the UserInput class. [Video description begins] <em>In line 3 the host types: UserInput ui &#61; new UserInput();.</em> [Video description ends]</p>
<p>And then we&#39;ll set the inp value by calling ui.getUserInput. [Video description begins] <em>In line 4 the host types:ui.getUserInput();.</em> [Video description ends] And then we&#39;ll define a new string to get the value that the user has input. [Video description begins] <em>In line 5 the host types: String input &#61; ui.getInp();.</em> [Video description ends] Now, our instance variable input contains the value from our user, so we will create the reversedString by using our static method, and we&#39;re passing as a value to that static method the forward input from the user and then we&#39;re storing the output into a new string called reversedString, which houses the reversed string from our method. [Video description begins] <em>Line 6 reads: String reversedString &#61; StringReverser.reverser(input);.</em> [Video description ends]</p>
<p>And finally we&#39;ll print that to the command line. Now we have our code, we&#39;re ready to compile and run our Java program. To do this, I&#39;m going to open up a Terminal in the directory with our Java code, specifically our main class. So we can see I&#39;m not in the directory that I want to be in right now, so I&#39;m going to change directory into src. And now we have the files that I want. You can compile each file individually or if you compile your Main class with the Main method, it will compile every other class that it uses and needs along with it.</p>
<p>To compile, I&#39;m going to use the command javac and I&#39;m doing this in a terminal. You could do it in PowerShell or any other Terminal emulator, whatever you prefer. If you&#39;re on Linux or Mac, odds are you&#39;ll use Terminal. If you&#39;re on Windows, you could use command prompt or PowerShell. The command is going to be the same either way. It&#39;s going to be javac and then I pass it, my Main.java. And now the command is completed. And if I do another directory, we can see some new classes have been created.</p>
<p>Previously, all I had was Main.java, StringReverser.java, UserInput.java. Now, I have Main.class, StringReverser.class and UserInput.class. So Java has compiled all my code into Java compiled bytecode. And now I&#39;m ready to run my program by calling java Main. And it&#39;s asked me to Please type a string: Thisisastring. And we can see the next line right below Thisisastring has printed out a reversed value of my string. So those are the basics of how we create a Java program, compile a Java program and run a Java program.</p></div></div></div><div class="section"><a name="section_13" /><h2 class="section_title">14. Video: Course Summary ( it_sdjcfa_06_enus_14)</h2><img src="https://cdn2.percipio.com/public/b/b5e59a26-232b-4d79-afa7-a9fcf50af582/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/b5e59a26-232b-4d79-afa7-a9fcf50af582/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">summarize the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Summary.</em> [Video description ends]
<p>So in this course, we&#39;ve examined the components of a basic Java program.</p>
<p>We did this by exploring basic Java programming features, Java classes, attributes, and methods, features and programming, Java constructor and modifier features and programming, compiling and running a basic Java program from the command line.</p>
<p>In our next course, we&#39;ll move on to explore the Java programming basics and the Java programming style guide.</p></div></div></div><div class="copyright-container"><span class="copyright-text">Â© 2022 Skillsoft Ireland Limited - All rights reserved.</span></div></div><div id="lb-overlay"><div class="lb-header"><button onclick="(()=>{const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'hidden';const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 1.0;curtain.style.backgroundColor = 'white';curtain.style.pointerEvents = 'auto';})();">X</button></div><div id="lb-image-container"><img id="lb-image" alt onload="(()=>{const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 0.5;curtain.style.backgroundColor = 'grey';curtain.style.pointerEvents = 'none';const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'visible';window.scrollTo(0, 0);})();"/></div><div class="lb-footer" /></div></div></body></html>