<!doctype html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-style-type" content="text/css2"><title>Course Transcript</title><link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css"><style>:root {
    --title-text: #243038;
    --toc-link: #0073C4;
    --section-title-text: #243038;
    --section-title-border: #bababa;
    --grid-caption-text: #164794;
    --grid-border: #c0c0c0;
    --grid-hdr-text: #973131;
    --grid-hdr-background: #f7f7f7;
    --missing-data: #767676;
    --text-color: #343434;
    --lightbox-border: #a0a0a0;

    --bold-font-weight: 700;

    font-family: Lato;
}

.report {
    margin: 24px;
}

.container {
    position: relative;
}

#lb-curtain {
    background-color: white;
    opacity: 1.0;
}

#lb-overlay {
    position: absolute;
    top: 40px;
    left: 20px;
    right: 20px;
    background-color: white;
    border: solid 1px var(--lightbox-border);
    visibility: hidden;
}

.lb-header, .lb-footer {
    height: 40px;
    line-height: 40px;
}

.lb-header {
    display: flex;
    justify-content: flex-end;
    padding-right: 20px;
}

#lb-image-container {
    margin: 0 40px;
}

#lb-image {
    width: 100%;
}

.report_title {
    font-size: 22px;
    font-weight: var(--bold-font-weight);
    color: var(--title-text);
}

.toc_link {
    font-size: 14px;
    color: var(--toc-link);
    margin-top: 6px;
    margin-bottom: 0;
}

.section {
    margin-top: 40px;
    margin-left: 16px;
}

.section.inner {
    margin-top: 20px;
}

.section.inline {
    margin-top: 20px;
    margin-left: 0;
}

.section_title {
    font-size: 18px;
    font-weight: var(--bold-font-weight);
    width: 100%;
    color: var(--section-title-text);
}

h2.section_title {
    border-bottom-color: var(--section-title-border);
    border-bottom-style: solid;
    border-bottom-width: thin;
}

h3.section_title {
    margin: 8px 0;
}

h3.list_title {
    margin: 8px 0;
    font-size: 14px;
    color: var(--title-text);
}

.section_text {
    font-size: 14px;
    color: var(--text-color);
    margin: 12px 0;
    width: 90%;
}

.section_link {
    font-size: 14px;
    margin: 12px 0;
    width: 90%;
}

.grid {
    border-collapse: collapse;
}
.grid_caption {
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    color: var(--grid-caption-text);
    margin: 12px 0;
    text-align: left;
    white-space: nowrap;
}
.grid_hdr_row {

}
.grid_col {
    font-size: 13px;
    color: var(--text-color);
    border-collapse: collapse;
    padding: 2px;
    text-align: left;
    vertical-align: top;
}
.grid_col_hdr, .grid_row_hdr {
    font-size: 12px;
    font-weight: var(--bold-font-weight);
    white-space: nowrap;
}
.grid_row_hdr {

}

.empty_grid {
    border-collapse: collapse;
    border-color: var(--grid-border);
    border-style: solid;
    border-width: 2px;
    padding: 4px;
    text-align: center;
}

.htmlbox {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    padding: 8px;
}

.list {
    font-size: 14px;
    font-style: italic;
}

.missing_data {
    color: var(--missing-data);
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    font-style: italic;
}

.copyright-container {
    margin-top: 24px;
    text-align: center;
}
.copyright-text {
    color: var(--text-color);
    font-size: 12px;
}

/* Transcript Questions CSS */

.question {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    display: flex;
    flex-direction: column;
    padding: 8px;
}

.question_content {
    display: flex;
    justify-content: space-between;
}

.question_details {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.question_images {
    display: flex;
    flex-direction: column;
    margin-left: 16px;
}

.question_image {
    margin-bottom: 8px;
}

.question_title {
    font-weight: var(--bold-font-weight);
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
    padding-bottom: 8px;
    margin-bottom: 8px;
}

.question_label, .question_stem {
    font-weight: var(--bold-font-weight);
    margin-top: 8px;
    margin-bottom: 8px;
}

.question_data_row {
    display: flex;
}

.question_data_col1 {
    padding: 8px;
    white-space: nowrap;
}

.question_data_col2 {
    padding: 8px;
    display: flex;
    flex-direction: column;
}

.question_answer_key {
    margin-top: 8px;
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
}

.feedback {
    font-style: italic;
}
</style></head><body class="report"><div class="container"><div class="content" id="lb-curtain"><h1 class="report_title">Java Certified Foundations Associate: Math & Random Classes</h1><div class="section_text">Mathematical operations are used to perform calculations of numeric data types and being able to generate random numbers is an important aspect of Computer Science. Java provides full functionality for mathematical operations and random number generation. In this course, you&#39;ll learn to use the Java Math and Random number generator classes.

First, you&#39;ll explore the various methods provided by the Java Math and the Java Random class. Next, you&#39;ll learn about and review demonstrations of the use of the java.util.Random, the Java Math.random, and the Java ThreadLocalRandom classes. 

This course is one of a collection of courses that prepares learners for Oracleâ€™s 1Z0-811: Java Certified Foundations Associate certification.</div><div class="section"><h2 class="section_title">Table of Contents</h2><div class="toc"><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_0">1. Video: Course Overview ( it_sdjcfa_10_enus_01)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_1">2. Video: Java Math Class ( it_sdjcfa_10_enus_02)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_2">3. Video: Java Basic Math Class ( it_sdjcfa_10_enus_03)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_3">4. Video: Programming Java Basic Math Classes ( it_sdjcfa_10_enus_04)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_4">5. Video: Java Advanced Math Classes ( it_sdjcfa_10_enus_05)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_5">6. Video: Programming Java Advanced Math Classes ( it_sdjcfa_10_enus_06)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_6">7. Video: Java Random Classes ( it_sdjcfa_10_enus_07)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_7">8. Video: java.util.Random Class ( it_sdjcfa_10_enus_08)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_8">9. Video: Programming the java.util.Random Class ( it_sdjcfa_10_enus_09)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_9">10. Video: Java Math.random  ( it_sdjcfa_10_enus_10)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_10">11. Video: Programming Java Math.random  ( it_sdjcfa_10_enus_11)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_11">12. Video: Java ThreadLocalRandom Class ( it_sdjcfa_10_enus_12)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_12">13. Video: Programming the Java ThreadLocalRandom Class ( it_sdjcfa_10_enus_13)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_13">14. Video: Course Summary ( it_sdjcfa_10_enus_14)</a></p></div></div><div class="section"><a name="section_0" /><h2 class="section_title">1. Video: Course Overview ( it_sdjcfa_10_enus_01)</h2><img src="https://cdn2.percipio.com/public/b/01687068-a07e-4b96-8a2a-ca28fe14a70f/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/01687068-a07e-4b96-8a2a-ca28fe14a70f/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">discover the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Overview.</em> [Video description ends] Hi, I&#39;m Sven Batalla, I&#39;m a software management professional with 20 plus years [Video description begins] <em>He is a product owner and scrum master.</em> [Video description ends] of experience in managing multi-million dollar projects for Fortune 500 clients. My entire career is centered around team communication and efficiency. With Agile certifications and Agile methodologies, I&#39;ve proven adept at all aspects of the software development lifecycle, including design, architecture and managing people, budgets, schedules, quality, and other deliverables. [Video description begins] <em>Screen title: Learning Objectives.</em> [Video description ends] <br /><br />Oracle&#39;s 1Z0-811 Java Certified Foundations Associate Certification is targeted to audiences seeking foundational knowledge of the Java Programming Language in concepts. Individuals tackling this certification will demonstrate that they can write and execute a Java program. Work with the Java Development Kit and the Java Runtime Environment. Mathematical operations are used to perform calculations of numeric data types, as well being able to generate random numbers are an important aspect of computer science. Java provides full functionality to perform mathematical operations and to generate random numbers. In this course, you&#39;ll learn how to use the Java math and random number generator classes. First I&#39;ll describe the various methods provided by the Java math and the Java random class. And next I&#39;ll demonstrate the Java.util.Random class, the Java math random method and the Java ThreadLocalRandom classes.</div></div></div><div class="section"><a name="section_1" /><h2 class="section_title">2. Video: Java Math Class ( it_sdjcfa_10_enus_02)</h2><img src="https://cdn2.percipio.com/public/b/32fbd303-0548-4bce-aa6f-8639950c6eb4/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/32fbd303-0548-4bce-aa6f-8639950c6eb4/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe Java Math class methods, advantages, and capturing exceptions</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Math Class. Presented by: Sven Batalla.</em> [Video description ends] When it comes to programming, there is no escaping the fact that sooner or later, you&#39;re gonna have to do some math. The good news is that Java has some built in packages to help you make that a lot easier. In particular, Java includes a built in math class. The math class allows you to perform mathematical actions against numeric values by using static methods. Of course, if it&#39;s standard math you&#39;re looking to do, you can always use the standard operators like plus, minus, asterisk for multiply, and forward slash for divide. But for slightly more complex math, the math class is best. <br /><br />The math class includes all sorts of methods to help you take a number or multiple numbers and calculate additional values, just to name a few. The math class has methods to perform calculations like square root, power, min and max, rounding and absolute. At the same time, you can also use the math class to perform standard trigonometry, hyperbolic trigonometry, or even inverse trigonometry. Exponential methods are even included in the math class. And of course, there&#39;s also logarithmic functions. So you can look at standard e based log, base 10 log, and so on. The biggest advantage of the math class over some conventional operator based math is how it works under the hood. <br /><br />Most of the math class methods use the underlying Java strict math package to perform their operations. And that means that some math is performed in the most accurate bit for bit way possible. However, not all math methods used a strict math packet. It attempts to be less strict and more relaxed. And that relaxed methodology means that the math class is actually much better performing than standard mathematical operations. The math class also provides methods that allow you to perform certain calculations or actions and capture exceptions if you overrun certain datatype limits. For example, the addExact() method allows you to add two numbers together. Sounds pretty normal, right? Well, let&#39;s pretend you wanted to add one to the maximum size of an integer. What would happen? <br /><br />Well, with the addExact() method you can capture an exception so you can take the appropriate action. The same is true for the multiplyExact() method. And of course, the subtractExact() method allows you to capture the same types of exceptions in the same way. The toIntExact() method can be used to convert long values to an integer, but a long value can be significantly larger than an integer. So once again, the method allows you to capture exceptions in the case that you&#39;ll overrun the integer side. So how should you go about using the math class anyways? Should you always use it? Well first, as I said earlier, it&#39;s worth remembering that many of the math class methods generally use the equivalent method in StrictMath anyways. <br /><br />StrictMath is another package in Java that ensures bit for bit results when it&#39;s run so it can be very accurate. Now that being said, Java themselves suggest using platform specific native libraries to achieve higher performance implementations in the environments that you plan to run in.</div></div></div><div class="section"><a name="section_2" /><h2 class="section_title">3. Video: Java Basic Math Class ( it_sdjcfa_10_enus_03)</h2><img src="https://cdn2.percipio.com/public/b/d04f1939-8ed3-487f-9672-20a98d6d704b/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/d04f1939-8ed3-487f-9672-20a98d6d704b/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe basic Math class functions in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Basic Math Class. Presented by: Sven Batalla.</em> [Video description ends] As you work on code, you&#39;ll find yourself inevitably doing a lot of different types of math. You can do most basic math functions using Java&#39;s math class, and some of the most common basic methods in the math class are, Math.min(), Math.max(), Math.abs() for absolute. Math.round(), Math.sqrt(), Math.exp() which stands for exponent. Math.expm1(), Math.addExact(), Math.subtractExact() and Math.multiplyExact(). Let&#39;s dig into these a little bit. Let&#39;s take a peek at an example of how you would use the Math.min() method. <br /><br />[Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the smaller value of two given arguments */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: int a &#61; 100; int b &#61; 5;. Line 7 is: System.out.println(&#34;Smaller value out of &#34; &#43; a &#43; &#34; and &#34; &#43; b &#43; &#34; is: &#34; &#43; Math.min(a, b));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] In this code snippet we create two integer values, a &#61; 100 and b &#61;5. In the print line command below our variable declaration, we call the Math.min() method and pass in those two integers. The purpose of the Math.min method is to examine two numbers and return the smaller one. In this case, we would expect the output to be 5 since 5 is smaller than 100. <br /><br />Now, let&#39;s take a look at an example of how you would use the Math.max() method. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the larger value of two given arguments */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: int a &#61; 100; int b &#61; 5;. Line 7 is: System.out.println(&#34;Larger value out of &#34; &#43; a &#43; &#34; and &#34; &#43; b &#43; &#34; is: &#34; &#43; Math.max(a, b));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] Actually, we can use it in exactly the same way as the Math.min() method. In fact, this code snippet is exactly the same as the snippet we examined for the Math.min() method. Once again, we have a variable a set to 100 and a variable b set to 5. This time though we call the Math.max() method with those two variables. <br /><br />The purpose of the Math.max() method is to examine two numbers and return the larger one. In this case, we would expect the output to be 100 because 100 is larger than 5. Next, let&#39;s take a peak at an example of how you would use the Math.abs() method. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the absolute value of a given argument */. Line 4 is: public static void main(String args[] ). Line 5 is: {. Line 6 is: int a &#61; 125; int b &#61; -125;. Line 7 is: System.out.println(&#34;The absolute value of &#34; &#43; a &#43; &#34; is &#34; &#43; Math.abs(a));. Line 8 is: System.out.println(&#34;The absolute value of &#34; &#43; b &#43; &#34; is &#34; &#43; Math.abs(b)); . Line 9 is: }. Line 10 is: }.</em> [Video description ends] In this code snippet we&#39;ve created two integer variables. a is set to 125 and b is set to -125. <br /><br />In the following two lines of code we call the Math.abs() method against each of those variables. The purpose of the Math.abs() method is to determine the absolute value of a given number. So in both cases, the output is 125. Lets keep it going. In this code snippet we&#39;re gonna look over an example of how you would use the Math.round() method. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the rounded value of a given value*/. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: double a &#61; 100.659843; . Line 7 is: System.out.println(&#34;The rounded value of &#34; &#43; a &#43; &#34; is:&#34; &#43; Math.round(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] There are actually several different types of rounding methods in the Math class but the round method is the most common. In this snippet we&#39;ve created a double value that is set to 100.659843. <br /><br />In the next line we call the Math.round() method and pass it that variable. When no additional parameters are passed in, the Math.round() method will round a given number to the nearest integer. In this case, the number would be rounded up to 101. So if we run the code, that&#39;s exactly the output we&#39;d see. Now, let&#39;s look at an example of how you would use the Math.sqrt() method. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the square root of a given arguments */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: int a &#61; 100; . Line 7 is: System.out.println(&#34;The square root of &#34; &#43; a &#43; &#34; is:&#34; &#43; Math.sqrt(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] In this code snippet, we&#39;ve created an integer variable called a. a is set to 100. <br /><br />Then in the next line, we pass that variable to the Math.sqrt() method. The purpose of the Math.sqrt() method is to calculate the square root of the given value. In this case, if we run the code, the Math.sqrt() method would accept the value of 100, and output a calculated result of 10. Next, let&#39;s look at an example of how you use the Math.exp() method. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns exponent of a given value*/. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: int a &#61; 2; . Line 7 is: System.out.println(&#34;The exponent of &#34; &#43; a &#43; &#34; is:&#34; &#43; Math.exp(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] In this code snippet, we&#39;ve created yet another integer called a, and its value is set to 2. <br /><br />Then in the next line of code we call the Math.exp() method and pass in variable a. The purpose of the Math.exp() method is to calculate Euler&#39;s number e raised to the power of the given value. e is roughly around 2.72. So in this case, e is being raised to the power of 2 and the result is roughly 7.39, and that sounds about right, doesn&#39;t it? Now, a similar method to Math.exp() is method Math.expm1(). The purpose of Math.expm1() is to calculate Euler&#39;s number e again [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Return (power of 2) -1 for a given argument*/. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: int a &#61; 2; . Line 7 is: System.out.println(&#34;The expm1 of &#34; &#43; a &#43; &#34; is:&#34; &#43; Math.expm1(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] raised to the power of the given value and then subtract 1. <br /><br />So, in this code snippet, we&#39;ve used the exact same code as last time but this time we&#39;re calling the Math.expm1() method. In our last example, the return value is around 7.39. This time when we use the expm1() method, we get a value of 6.39. Next, let&#39;s take a look at an example of how we might use the Math.addExact() and Math.subtractExact() methods. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the smaller value of two given arguments*/. Line 4 is: public static void main(String [] args). Line 5 is: {. Line 6 is: int a &#61; 100; int b &#61; 5;. Line 7 is: System.out.println(a &#43; &#34; &#43; &#34; &#43; b &#43; &#34; &#61; &#34; &#43; Math.addExact(a,b));. Line 8 is: System.out.println(a &#43; &#34; - &#34; &#43; b &#43; &#34; &#61; &#34; &#43; Math.subtractExact(a,b)); . Line 9 is: }. Line 10 is: }.</em> [Video description ends] In this code snippet we created two integer variables. <br /><br />Variable a has been set to 100 and variable b has been set to 5. In the next line of code we call the Math.addExact() method with the two values, and in the line after that we call the Math.subtractExact() method with the same two values. The purpose of the addExact() method is to sum two given parameters. While the purpose of the subtractExact() method is to subtract the second value from the first. So, why use these methods instead of just using the plus and minus operators? Well, the main reason is because these methods can throw exceptions that can be caught if they overrun the data types that are being used. For example, if you add 1 to the maximum size of an integer, you would get an exception that you can catch an manage. In this case when we add 100 to 5, we get the expected 105, and then when we subtract 5 from 100, we get the expected 95. <br /><br />And finally, let&#39;s take a look at an example of how we might use the Math.multiplyExact() method. In this code, we yet again create two integer variables that are set to 100 and 5. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Multiplies two given arguments*/. Line 4 is: public static void main(String [] args). Line 5 is: {. Line 6 is: int a &#61; 100; int b &#61; 5;. Line 7 is: System.out.println(a &#43; &#34; x &#34; &#43; b &#43; &#34; &#61; &#34; &#43; Math.multiplyExact(a,b));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] In the next line of code, we call the multiplyExact() method and pass in the two variables. The purpose of the multiplyexact() method is to multiply the two given parameters together. While we could use the asterisk symbol instead of this method. This method allows us to catch exceptions if we&#39;re gonna overrun the data type. But in this case when we multiply 100 and 5, we get 500.</div></div></div><div class="section"><a name="section_3" /><h2 class="section_title">4. Video: Programming Java Basic Math Classes ( it_sdjcfa_10_enus_04)</h2><img src="https://cdn2.percipio.com/public/b/2ab48e97-1dfc-40d3-8211-eb9ab1e9e49e/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/2ab48e97-1dfc-40d3-8211-eb9ab1e9e49e/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the use of basic Math class functions in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Basic Math Classes. Presented by: Sven Batalla.</em> [Video description ends] In this demo, we&#39;re gonna look at some of the basic functions available in Java&#39;s Math class. We&#39;ll use the Math class to find the minimum and maximum number between two values, the square root of a value, and the absolute value of a number. To do all that, we&#39;re gonna create a project in Eclipse and then create and display strings in a couple of way. All right, so as I said, we&#39;re gonna use the free Eclipse IDE in this demo. You can use any other kind of Java IDE and it&#39;ll work perfectly fine. Anyway, let&#39;s go ahead and open the Eclipse IDE now. Okay, so the first thing we&#39;re gonna do is create a new project. <br /><br />[Video description begins] <em>An Eclipse IDE opens. It has a menu bar and a tool bar. A pane titled Package Explorer is open on the left. It has a project named demo1. On the right, there is a pane titled Outline. At the bottom, the following tabs are present: Problems, Javacode, Declaration, Console, etc. The Console tab is open.</em> [Video description ends] In Eclipse, that&#39;s as simple as opening the File menu and selecting New; Java Project. [Video description begins] <em>A pop-up titled New Java Project opens. It has an input field for Project name. Below it there are options to select JRE, Project layout, and Working sets.</em> [Video description ends] Now, when you create a project, you need to give it a name, and for the sake of this demo, I&#39;m just gonna call my project demo10. <br /><br />Now, that Math class is very common and has been around since the very beginning. So, there&#39;s really nothing special beyond setting the name that we have to do. So, let&#39;s just leave all the defaults as they are and click Finish. Good, now it asks us for a module name. [Video description begins] <em>A pop-up titled New module-info.java opens. It has an input field for Module name. It is set as demo10.</em> [Video description ends] Now, this isn&#39;t super important for what we&#39;re gonna be doing in this course, so, let&#39;s just leave it as the default and click Create. [Video description begins] <em>In the Package Explorer, a project named demo10 opens. It has a file named module-info.java. It is selected and tab for it is open in the center. It has a set of code lines.</em> [Video description ends] <br /><br />Perfect, now our project is created and we&#39;re just about ready to get started with the Math class. But before we can actually start coding with the Math class, we need a file to code in. So, let&#39;s go ahead and do that. Now, first, let&#39;s close the module tab that opened up on our screen. All right, so now in order to be able to play with code, you first need to have an entry point into the project. So, let&#39;s do that by creating a Main class. From the File menu, let&#39;s select New Class. [Video description begins] <em>A pop-up titled New Java Class appears. It has input fields for Source folder, Package, Name, etc.</em> [Video description ends] Perfect, now in the pop-up we&#39;re being asked for information about our class. The source folder and the package are pointed to the root of our project by default, and that&#39;s fine for our purposes. <br /><br />So, let&#39;s give our class a name. In this case, let&#39;s call it Main, with a capital M. Good, and we&#39;ll leave all the modifiers to superclass and interfaces as the defaults. But let&#39;s make sure we check the public static void main method stub checkbox and leave the others unchecked. Good, now let&#39;s click Finish. Excellent, we have our class. [Video description begins] <em>In the Eclipse IDE, a tab titled Main.java opens. It has a set of code lines.</em> [Video description ends] Now, we&#39;re gonna be spending a lot of time in this class, so we&#39;re gonna try to make our lives a bit easier. Let&#39;s create a method that will output the results of our math to the screen. Now, below the Main method, let&#39;s create a new method. Let&#39;s type the following code, private static void log(String method, Object result) {} [Video description begins] <em>He enters the code in line 10.</em> [Video description ends] <br /><br />Now, this method takes in two parameters, a method name and a result. What we want to do with this method is output text to the console. So, let&#39;s add some code to the body of the method. Now, let&#39;s type the following code inside our method. System.out.println, which stands for print line, (String.format(&#34;%s: %s&#34;, method, result));. [Video description begins] <em>He enters the code in line 11.</em> [Video description ends] Excellent, now what this code does is it creates a formatted string that outputs the method name and the result to the console. Good, now we&#39;re finally ready to get started. Now, there are a few basic static methods available in the Math class. A static method is a method that you can access from the class definition without creating an instance of the class. <br /><br />The first methods we&#39;re gonna look at are the min and max methods. Now, before we get started, let&#39;s remove the comment on line 6. Good, now, where that comment was, let&#39;s type the following code, log(&#34;min&#34;, Math.min(-10, 10));. [Video description begins] <em>He enters the code in line 6.</em> [Video description ends] Good, now in the next line, let&#39;s type the following code. log(&#34;max&#34;, Math.max(-9, 9));. [Video description begins] <em>He enters the code in line 7.</em> [Video description ends] Now, in these two lines of code, we&#39;re calling the Math classes min and max methods. The min method takes two numbers and gives us back whichever value is the smallest. In this case, we expect the answer to be -10, right? <br /><br />Then the max method takes in two numbers and gives us back whichever value is the biggest, and in that case, we&#39;re expecting the result to be 9, right? Well, why don&#39;t we find out? Let&#39;s save the file with a Ctrl&#43;S and then run the project with a Ctrl&#43;F11. Excellent, now if you look down at the bottom of the screen in the console window, you can see that two numbers have been output, and the output says our min value is -10 and our max value is 9, and that&#39;s right, that&#39;s fantastic. Next, let&#39;s take a look at the square root method. We know the square root of 64 is 8. So, let&#39;s run some code where we know that that&#39;s the answer we&#39;re gonna get. Now, in the line below our min and max values, let&#39;s add this code. Log(&#34;root&#34;, Math.sqrt , which stands for square root, (64)); [Video description begins] <em>He enters the code in line 8.</em> [Video description ends]<br /><br />Now, once again we&#39;re wrapping our math command in our log method so that we can see the result. But as you can see, the square root method accepts a single value and then returns its square root, or at least it should. Let&#39;s save this file and run the project to find out. Nice, now as you can see in the console at the bottom of the screen, the value of 64 was square rooted and a value of 8 was returned and output to the screen. All right, now let&#39;s take a look at one last basic Math class method. Let&#39;s take a look at the absolute method. The absolute method takes any numeric value and returns its positive equivalent. So, we know that the absolute value of, say, -5.2 is just 5.2. So, let&#39;s see if the Math class agrees with that. Now, in the line below our latest square root call, let&#39;s add this code. Log(&#34;abs&#34;, Math.abs, which stands for absolute, (-5.2));. [Video description begins] <em>He enters the code in line 9.</em> [Video description ends] <br /><br />Now, just like we&#39;ve done every time so far, we&#39;ve wrapped our math command in our log method so that we can see the result. Now, as you can see, the absolute method accepts a single value and then returns its absolute value. So, let&#39;s give it a try and find out if that&#39;s true. Save and Run. Perfect, now, as you can see in the console at the bottom of the screen, the value of 5.2 is returned from the negative variable. So there you go, those are the basic static methods available in the Math class. There are many more advanced methods available in the Math class, and we&#39;ll get to those in a later talk.</div></div></div><div class="section"><a name="section_4" /><h2 class="section_title">5. Video: Java Advanced Math Classes ( it_sdjcfa_10_enus_05)</h2><img src="https://cdn2.percipio.com/public/b/154e9650-85d2-4114-a382-886032bfed40/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/154e9650-85d2-4114-a382-886032bfed40/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe advanced Java Math class methods such as Math.log(), Math.log10(), Math.log1p(), Math.toRadians(), Math.sin(), Math.cos(), Math.tan(), Math.asin(), Math.acos(), Math.sinh(), Math.cosh(), and Math.tanh()</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Advanced Math Classes. Presented by: Sven Batalla.</em> [Video description ends] Not all the math you&#39;ll do in Java will be basic and simple. In some cases, you need to perform some advanced math too, but don&#39;t worry, Java&#39;s math class has lots of advanced methods built in right alongside the basic methods. Some of the most common advanced methods in the math class are Math.log(), Math.log10(), Math.log1p(), Math.toRadians(), Math.sin(), Math.cos(), Math.tan(), Math.asin(), Math.acos(), Math.sinh(), Math.cosh(), and Math.tanh(). So, let&#39;s dig into these a little bit. <br /><br />Let&#39;s take a look at an example of how we&#39;d use the Math.log method. In this code snippet, we create a double variable called a and set it to 100. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the logarithm of a given argument */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: double a &#61; 100;. Line 7 is: System.out.println(&#34;logarithm of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.log(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] Then, in the line of code below that, we call the Math.log method with that variable. The purpose of the Math.log method is to retrieve the base e log value for the given numeric parameter. In this case, with an input of 100, the method would return a value of about 4.61, but base e log is not the only thing you can do. <br /><br />Let&#39;s take a look at an example of how we would use the Math.log10 method. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the base 10 logarithm of a given argument */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: double a &#61; 100;. Line 7 is: System.out.println(&#34;Base 10 logarithm of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.log10(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] In this code snippet, we once again create a double variable with the value of 100, then this time we call the Math.log10 method. Now, the purpose of the Math.log10 method is to retrieve the base 10 log value for the given numeric parameter. Now in this case, it&#39;s pretty easy. With an input value 100, the method would return a value of 2. <br /><br />In fact, there&#39;s even another log method, this time let&#39;s take a look at an example of how we would use the Math.log1p method. In this code snippet, we use the same familiar double variable set to 100, and [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the logarithm of a (given argument &#43; 1) */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: double a &#61; 100;. Line 7 is: System.out.println(&#34;log1p value of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.log1p(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] this time we pass it to the Math.log1p method. The purpose of the Math.log1p method is to calculate natural log of the given input plus 1. So in reality, with an input of 100, the method is actually returning the natural log of 101. <br /><br />So in this case, we get an output of about 4.62. Now, when we start doing trigonometry, we start needing to know about degrees and radian. The methods in the math class that calculate trigonometry values need an input [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the radian of a given argument */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: double a &#61; 100;. Line 7 is: System.out.println(&#34;radian of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.toRadians(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] in radians, but generally we think of values in degrees, so enter the Math.toRadians method. In this code snippet, we create a double variable called a and set it to 100, now that value is in degrees. <br /><br />Then, in the line below we call the Math.toRadians method. The purpose of that method is to convert the value in degrees to radians. In this case, the radian value of 100 degrees is about 1.76. Next, let&#39;s take a look at an example of how we would calculate the sine value of a given input. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the trigonometric sine of a given argument */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: double a &#61; 100;. Line 7 is: System.out.println(&#34;sine of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.sin(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] In this code snippet, we create our familiar value of 100 then in the line below, we call the Math.sin method and pass in the value.<br /><br />The purpose of the Math.sin method is to calculate the sine value for an input angle in between 0 and Pi. Now, remember that the input for this method is generally considered to be in radians, so really we&#39;re passing in 100 radian. In this case the sine value for 100 radians is about -0.51. Now, let&#39;s take a look at an example of how we would calculate the cosine value of a given input. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the trigonometric cosine of a given argument */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: double a &#61; 100;. Line 7 is: System.out.println(&#34;cosine of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.cos(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] <br /><br />You&#39;ll notice that this code snippet is remarkably similar to our sine example that we just looked at and that&#39;s because these methods are almost exactly the same, and once again, we create a value of 100 and once again that&#39;s considered to be in radian. We then pass that value into math.cos method, so that we can calculate the cosine value for an input angle between zero and Pi. In this case, the cosine value for 100 radians is about 0.86. Now, in trigonometry, we can&#39;t talk about sine and cosine without talking about tangents. Just like sine and cosine, [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the trigonometric tangent of a given argument */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: double a &#61; 100;. Line 7 is: System.out.println(&#34;tangent of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.tan(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] the math class also includes a method for handling tangents.<br /><br />In fact, once again, you&#39;ll find this code snippet to be virtually identical to the last two that we did. So yet again, we create a double value and set it to 100, and yet again, it&#39;s considered to be a value in radian. This time, we pass that value into the Math.tan method so that we can calculate the tangent value for the input angle. In this case, the tangent value for 100 radians is about negative 0.59. Now be careful though, you technically can&#39;t calculate a tangent for values at 90 degrees. Again, that&#39;s not 90 radians, but rather 90 degrees. That would technically result in infinity. So while we can calculate the regular sine, cosine, and tangent, we can also calculate their inverse arc angles. <br /><br />[Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the trigonometric arc sine of a given argument */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: double a &#61; 0.2;. Line 7 is: System.out.println(&#34;arc sine of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.asin(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends]<br /><br />In this code snippet, we create a double value called a and set its value to 0.2. Then in the next line, we call the Math.asin method and pass in the value. Now, just like in our other examples, the arc methods still expect an input in radian. So our value 0.2 is technically considered to be in radian. The purpose of the Math.asin method is to calculate the arc sine value for an input angle between 0 and Pi. Now, let&#39;s take a look at an example of how we would calculate the arc cosine value of a given input. <br /><br />You notice that this code is once again remarkably similar to [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the trigonometric arc cosine of a given argument */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: double a &#61; 0.75;. Line 7 is: System.out.println(&#34; arc cosine of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.acos(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] our arc sine example that we just looked at, and that&#39;s again because these methods are almost exactly the same, so once again we create a value and once again that value is in radian. <br /><br />We then pass that value into a Math.acos method so that we can calculate the arc cosine value for an input angle between zero and Pi. So while we can calculate the regular sine, cosine and tangent and we can calculate the arc sine, arc cosine and arc tangent, we can also calculate their hyperbolic value. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the hyperbolic sine of a given argument */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: int a &#61; 10;. Line 7 is: System.out.println(&#34;hyperbolic sine of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.sinh(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] In this code snippet, we create a double value called a, then in the next line we call the Math.sinh method and pass in the value. Now once again, just like all the other trigonometry methods, the hyperbolic methods still expect an input in radian. <br /><br />Now, the purpose of the Math.sinh method is to calculate the hyperbolic sine value of the input angle. Now, let&#39;s take a look at an example of how we would calculate the hyperbolic cosine value of a given input. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the hyperbolic cosine of a given argument */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: int a &#61; 10;. Line 7 is: System.out.println(&#34;hyperbolic cosine of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.cosh(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] You&#39;ll notice again that this code snippet is again remarkably similar to our hyperbolic sine example that we just looked at, and again, that&#39;s because they&#39;re almost exactly the same. <br /><br />So once again, we create a value and once again that values is in radian. We then pass that value into Math.cosh method so that we can calculate the hyperbolic cosine value for an input angle, and finally, let&#39;s take a look at an example of a hyperbolic tangent implementation. Just like hyperbolic sine and hyperbolic cosine, the math class also includes a method for handling hyperbolic tangents. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class JavaMathClass. Line 2 is: {. Line 3 is: /* Returns the hyperbolic tangent of a given argument */. Line 4 is: public static void main(String[] args). Line 5 is: {. Line 6 is: int a &#61; 10;. Line 7 is: System.out.println(&#34;hyperbolic tangent of &#34; &#43; a &#43; &#34; is: &#34; &#43; Math.tanh(a));. Line 8 is: }. Line 9 is: }.</em> [Video description ends] <br /><br />In fact, once again, you&#39;ll find that this code snippet is virtually identical to the last two that we did. So once again, we create a value and once again that value is in radian. This time we pass that value to a Math.tanh method so that we can calculate the hyperbolic tangent value for the input angle. In this case the hyperbolic tangent value for an input of 10 radians is about 1.</div></div></div><div class="section"><a name="section_5" /><h2 class="section_title">6. Video: Programming Java Advanced Math Classes ( it_sdjcfa_10_enus_06)</h2><img src="https://cdn2.percipio.com/public/b/139bcd05-f615-41d0-9d15-484ac3342c9a/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/139bcd05-f615-41d0-9d15-484ac3342c9a/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the use of advanced Math class methods</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Advanced Math Classes. Presented by: Sven Batalla.</em> [Video description ends] In this demo, we&#39;re gonna look over some of the advanced methods available in Java&#39;s math class. In particular, we&#39;re gonna look over some of the logarithmic methods, trigonometry methods, hyperbolic methods, and some other common math class methods. Then we&#39;ll output the results to the console to validate our results. All right, so to do all that, we&#39;re gonna piggyback off our previous demo which we built in Eclipse. So let&#39;s head over to the Eclipse IDE now. [Video description begins] <em>In the Eclipse IDE, a tab titled Main.java is open. It has a set of code lines.</em> [Video description ends]<br /><br />Alright, so I already have our project open from the previous demo, but if you don&#39;t go ahead and open the project now. Okay, so in our last demo we created a logging method so that we could output the results of a few basic math class methods that we invoke. In this demo, we&#39;re gonna call some advanced mathematical methods in the math class, so that we can see their output. Alright, so let&#39;s skip back to our main class. We can do that by double clicking on the Main.java file in the package Explorer panel on the left-hand side of the screen. Now, I&#39;ve already got mine open. Good, now in our last demo we called some of the basic math class methods and wrapped them in our call to our log method. So let&#39;s do that again, but this time we&#39;re gonna use some logarithmic methods. <br /><br />Let&#39;s drop a couple of lines down from our last block of calls and type the following code. Log(&#34;log&#34;, Math.log(100));. [Video description begins] <em>He enters the code in line 11.</em> [Video description ends] Now, the log() method returns the natural log base e of whatever value we pass in. In this case 100, but there are other log() method. So let&#39;s go down to the next line and invoke one more. On the next line, let&#39;s type the following code. Log(&#34;log10&#34;, Math.log10(100);. Good. [Video description begins] <em>He enters the code in line 12.</em> [Video description ends] Now, the log10 method returns the base 10 log of whatever number we pass in. And again, in this case 100. So let&#39;s save the file and run the project to see what we get. Now remember, you can save the file with a Ctrl&#43;S and run the project with the Ctrl&#43;F11. <br /><br />Excellent, in our console output at the bottom of the screen, we can see that the log calls output some values, nice. Now, I won&#39;t bother going to detail about how we can validate some of the advanced math here, but we know that the log10 method works by order of magnitude. And we can plainly see that the input of 100 output the correct value of two. So great job so far. Now, let&#39;s try some trigonometry. Now, there are three main trigonometry methods sine, cosine, and tangent. So on the next few lines, let&#39;s write out some trigonometry, shall we? Now on the next line, let&#39;s type the following code. Log(&#34;sin&#34;, Math.sin(90));. Good. [Video description begins] <em>He enters the code in line 13.</em> [Video description ends] Now, what we&#39;ve done here is we&#39;ve called a method that returns the sine value of a number, in this case 90. <br /><br />Now, the sine method actually accepts a value in radian. So, what we&#39;re actually seeing is that the value of 90 is in radians, but that&#39;s not quite right. That&#39;s a value in degrees. So let&#39;s just adjust this code a bit. Let&#39;s replace the number 90 with this code, Log(&#34;sin&#34;, Math.toRadians(90));. Good, now we&#39;re passing in the radian version of the number 90, and then getting the sine value for that. Now of course, a 90 degree value means that you&#39;ve reached the top of the sine wave. So that means that we should expect to get a value of one back. So let&#39;s save the file and run the project to see. Perfect, we got a value of 1. Now we know that the cosine is the inverse of a sine. So let&#39;s copy and paste the code that we just made for sine and replace it with cosine. [Video description begins] <em>He enters the code in line 14.</em> [Video description ends]<br /><br />And now we should expect a value of 0 for the same 90 degrees. So let&#39;s try it. Perfect, we got 0, or at least close enough it makes no difference. Now, let&#39;s copy and paste the code one more time. And now let&#39;s update the code for tangent. Now, we know that at 90 degrees, you can&#39;t have a tangent, so let&#39;s change it to 45 degrees instead. [Video description begins] <em>He enters the code in line 15.</em> [Video description ends] And let&#39;s save, and run the project. Good at 45 degrees, we get attention of about 1. Very nicely done. Now, in addition to the base trigonometry methods, there are also some arc versions and the hyperbolic version. Now to illustrate let&#39;s implement the hyperbolic version. Let&#39;s copy and paste our three trigonometry lines and then, update them to sinh, cosinh, and tangenth. <br /><br />[Video description begins] <em>He enters the code in lines 16-18.</em> [Video description ends] And let&#39;s give this a run. Alright, nice. Now, I won&#39;t bother going into the math of how this actually works. But if you&#39;re familiar with hyperbolic curves, then those same degrees that we passed into the base trigonometry methods should yield the numbers that we&#39;re seeing in the console. Fantastic, now the advanced methods of the math class, aren&#39;t all about trigonometry. There are also some additional calculation methods. For example, let&#39;s take a look at rounding. Now, on the next line, let&#39;s type the following code. Log(&#34;floor&#34;, Math.floor(6.5));. [Video description begins] <em>He enters the code in line 19.</em> [Video description ends] Good, now in the next line, let&#39;s write something very similar. Let&#39;s write Log(&#34;ceil&#34;, Math.ceil, which stands for ceiling, (6.5));. [Video description begins] <em>He enters the code in line 20.</em> [Video description ends] <br /><br />And next in yet another line let&#39;s add this, Log(&#34;round&#34;, Math.round(6.5));. [Video description begins] <em>He enters the code in line 21.</em> [Video description ends] And finally, let&#39;s add one more line like this, Log(&#34;rint&#34;, Math.rint, which stand for round int, (6.5));. Perfect. [Video description begins] <em>He enters the code in line 22.</em> [Video description ends] So, now these four methods are all taking the same numbers 6.5, and rounding them in their own way. The floor method rounds down to the nearest integer and here we would expect a value of 6. The ceiling method rounds up to the nearest integer. So, since it&#39;s the opposite of floor, we would expect a result of 7. The round method rounds up or down to the nearest integer. <br /><br />Here, we would expect a result of 7 since 5 typically rounds upwards. And finally, the rint() method rounds to the nearest mathematical integer. In other words, it rounds up or down to the nearest number unless the decimal is 5. In that case, it rounds to the nearest even number. So, here we expect a value of 6. So to recap, we expect the values 6, 7, 7 and 6. So, let&#39;s run this and see what we get. Nice, 6, 7, 7 and 6. Okay, so let&#39;s do one more method. Let&#39;s take a look at the power() method. In the next line, let&#39;s write this code, Log(&#34;pow&#34;, Math.pow, it stands for power, (8, 2));. Good. [Video description begins] <em>He enters the code in line 23.</em> [Video description ends] Now, in this method, we&#39;re asking for the value of 8 to be raised to the power of 2. <br /><br />So we know that 8 squared is 64, so if we run this code, then that&#39;s what we should expect as a result. So let&#39;s do that. Nice, we got the answer we expected. So, that&#39;s the advanced methods of the math class in a nutshell. There are several variations of some of the methods along with some others that we didn&#39;t go over. But for the most part, this should give you a good glimpse into how the math class is organized and how it works. Great job.</div></div></div><div class="section"><a name="section_6" /><h2 class="section_title">7. Video: Java Random Classes ( it_sdjcfa_10_enus_07)</h2><img src="https://cdn2.percipio.com/public/b/5af5dac3-2421-4a4a-9dee-c9b467f0981e/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/5af5dac3-2421-4a4a-9dee-c9b467f0981e/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe and compare the various classes that can be used to generate random numbers such as the java.util.Random class, the ThreadLocalRandom class and the Math.random method 
</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Random Classes. Presented by: Sven Batalla.</em> [Video description ends] Sometimes we need to use random values. There are all kinds of use cases for that. The good news is that Java has us covered there. In fact, in Java there are three main ways to create random values. First is the Random class in the java.util package. Then there&#39;s the random static method in the Math class. And finally, there&#39;s the ThreadLocalRandom class. Let&#39;s dig into these a little bit. The Random class is probably one of the easiest and most common ways to generate random values in Java. To use the Random class you need to import the java.util.Random package. <br /><br />And once you do, you then need to create an instance of the Random class to gain access to its method. Now, once you&#39;ve generated an instance of the Random class, you can then start generating random value. The cool thing about the Random class is you can generate random values of virtually any data type. That includes integers, doubles, Booleans, and even byte. To generate random values, all you have to do is call the appropriate method. In some cases, like with integers, you can even set the upper boundary for random number. For example, you can ask to generate a random number between 0 and 10 rather than anywhere between the minimum and maximum size of an integer, which is about 2 billion to -2 billion, by the way. Now, let&#39;s take a look at an example of how you would use the Random class. <br /><br />In this code snippet, we import the java.util.Random package right at the very top of the code. [Video description begins] <em>A set of code appears on the screen. Line 1 is: importjava.util.Random;. Line 2 is: public class randomNumbers{. Line 3 is: public static void main(String args[]) {. Line 4 is: /* generate random integer between 1 and 50 */. Line 5 is: Random randNo &#61; new Random();. Line 6 is: System.out.print(randNo.nextlnt(50));. Line 7 is: }. Line 8 is:}.</em> [Video description ends] Then, in the main method, we create an instance of the Random class and assign it to the randNo variable. Then, we call the nextInt method and pass in a value of 50. Now, the purpose of the nextInt method is to generate a random integer value anywhere in the integer spectrum, which means it can even be negative. <br /><br />When a value is passed in, it will generate a value between 0 and that value. So in this case, we&#39;re generating a random value between 0 and 50. Each time we run this code, we would get a new value. In the example here, the output was 42. Next let&#39;s take a look at an example of how we would use the Math.random method. In this code snippet you&#39;ll see that, unlike the Random class, there&#39;s no need to import a package, and there&#39;s no need to create an instance of any class. [Video description begins] <em>A set of code appears on the screen. Line 1 is: public class randomNumbers{. Line 2 is: public static void main(String args[] ){. Line 3 is: /*create random integer*/. Line 4 is: System.out.println(&#34;random double: &#34; &#43; Math.random());. Line 5 is: }. Line 6 is: }.</em> [Video description ends]<br /><br />In fact, the only line of code here is just to call the random static method in the Math class. The purpose of the Math.random method is to generate a random number between 0 and 1. The downside of the Math.random method is that it can&#39;t generate random values of any other data type. Finally, let&#39;s take a look at an example of how we would use the ThreadLocalRandom class. In this code snippet, we import the java.util.concurrent. ThreadLocalRandom package right at the very top of the code. <br /><br />Now, unlike the Random class, [Video description begins] <em>A set of code appears on the screen. Line 1 is: Import java.util.concurrent.ThreadLocalRandom;. Line 2 is: public class randomNumbers{. Line 3 is: public static void main(String args[] ){. Line 4 is: /*create random integer using ThreadLocalRandom */. Line 5 is: int randInl &#61; ThreadLocalRandom.current().nextInt();. Line 6 is: System.out.println(&#34;integer: &#34; &#43; randInt.);. Line 7 is: }. Line 8 is: }.</em> [Video description ends] the ThreadLocalRandom class doesn&#39;t require an instance to be created, but unlike the Math.random method, the ThreadLocalRandom class can generate random values of different data types. Effectively, the ThreadLocalRandom class is the best of both worlds. In fact, Java recommends using this class because it&#39;s optimized for thread usage.<br /><br />In this code snippet, we generate a random integer value by calling the current().nextInt() method. The current portion of the command reaches a pointer to the current thread. Now, that&#39;s not super important for this course, so let&#39;s just leave it at that. The nextInt method then generates a new random integer somewhere between the minimum and the maximum possible values of an integer.</div></div></div><div class="section"><a name="section_7" /><h2 class="section_title">8. Video: java.util.Random Class ( it_sdjcfa_10_enus_08)</h2><img src="https://cdn2.percipio.com/public/b/a40f5dd3-21e2-4b0a-8cbb-f17173347364/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/a40f5dd3-21e2-4b0a-8cbb-f17173347364/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe features and methods of the java.util.Random class
</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: java.util.Random Class. Presented by: Sven Batalla.</em> [Video description ends] Java&#39;s random class is one of the easiest and most common ways to generate random values in Java. It has a few characteristics worth noting. First, it&#39;s thread safe or more appropriately, the random class is built in such a way that you can use it in multiple threads without worry of collision. However, it&#39;s worth understanding that the random class is not cryptographically secure. That means that the random values are generated in such a way that they can technically be guessed, and that means they&#39;d be really bad to use for security ciphers, but one of the best perks of the random class is that it can generate random values of multiple different data type. <br /><br />The random class has two constructors. First is the default empty constructor. Using this constructor provides you with an instance of the random class and you can go ahead and get started. Next is the constructor that accepts a seed. With this constructor, you can specify the starting seed for your random class and that can be useful but it&#39;s not very common. Now, I mentioned earlier that the random class includes the ability to generate random values for lots of different data types. To do that you simply need to call the right method once you have an instance of the random class. For example, the ints() method will generate and return multiple random integer values all at once. The doubles() method will generate and return multiple double values all at once. <br /><br />And you guessed it, the longs() method will generate and return multiple random long values all at once. Next, you have the nextInt(), nextDouble(), nextFloat(), nextBoolean(), and nextByte() methods, which generate a single random value for the next data type that the method references. The nextGaussian() method generates a random Gaussian value between zero and a standard deviation of one and returns the result as a double. And finally, we have the ability to update the seed value by calling the setSeed() method. Now, let&#39;s take a look at an example of how we might generate some random integers with the random class. In this code snippet, we create an instance of the random class. Then we enter into a loop that executes ten times.<br /><br />[Video description begins] <em>Eleven code lines appear. Line 1 is: import java.util.Random;. Line 2 is: public class randomNumbers {. Line 3 is: public static void main(String args[]) {. Line 4 is: /* instance of Random class */. Line 5 is: Random rand1 &#61; new Random();. Line 6 is: for (int j &#61; 0; j&lt;10; j&#43;&#43;) {.</em> [Video description ends] In each iteration of the loop, we ask our random class to generate an integer value between 0 and 50 by calling the nextInt method, and passing in a parameter of 50. [Video description begins] <em>Line 7 is: int randomNo&#61; rand1.nextInt(50);.</em> [Video description ends] We then output the generated value to the console using the print line command. [Video description begins] <em>Line 8 is: System.out.print(randomNo &#43; &#34; &#34;); }. Line 9 is: }. Line 10 is: }.</em> [Video description ends] <br /><br />Now, notice how the random class is created outside of the loop. That&#39;s an optimization step that prevents us from creating a new random class every time the loop iterates. Anyway, each time you run this code you would get a new set of ten random integer values between 0 and 50 output to the console. So, what if we wanted to generate a random value between a different range? Well, let&#39;s take a look at an example of how we might do that. In this code snippet, we&#39;re trying to generate a random value between 5 and 25. [Video description begins] <em>Eight code lines appear.</em> [Video description ends] This code snippet shows that the next int method is being called again, but a parameter of 20 is being passed in, and that means that a random value between 0 and 20 is being generated.<br /><br />[Video description begins] <em>Line 1 is: import java.util.Random;. Line 2 is: public class randomNumbers {. Line 3 is: public static void main(String args[]) {. Line 4 is: /* generate random number between 5 and 25 */. Line 5 is: Random randNo &#61; new Random();. Line 6 is: System.out.println(&#34;between 5 and 25:&#34; &#43; (randNo.nextInt(20)&#43; 5));. Line 7 is: }. Line 8 is: }.</em> [Video description ends] Then 5 is merely added to the result. So, while the random number generation is still technically calculating as a 0 base. Our little trick makes it look like it&#39;s generating a value between 5 and 25 instead. Now, with the random class, generating random double values means getting a value between 0 and 1. So what if we wanted a different upper bound for our doubles? <br /><br />What if we wanted to generate a random double value between 0 and 50 instead of 0 and 1? Well, let&#39;s take a look at an example of how we might do that. [Video description begins] <em>Ten code lines appear. Line 1 is: import java.util.Random;. Line 2 is: public class randomNumbers {. Line 3 is: public static void main(String args[]) {. Line 4 is: /* instance of Random class */. Line 5 is: Random randNo &#61; new Random();.</em> [Video description ends] In this code snippet, we once again create an instance of the random class. Then we enter into a loop that executes ten times. In each iteration of the loop, [Video description begins] <em>Line 6 is: for (int i &#61; 0; i&lt;10; i&#43;&#43;) {.</em> [Video description ends] we ask our random class to generate a double using the nextDouble() method, and then we simply multiply the results by 50.<br /><br />[Video description begins] <em>Line 7 is: double randomNo&#61; randNo.nextDouble() * 50;. Line 8 is: System.out.print(randomNo &#43; &#34; &#34;); }. Line 9 is: }. Line 10 is: }.</em> [Video description ends] Then the results are output to the console. So if we ran this code, we&#39;d get ten random double values between 0 and 50. Next, let&#39;s take a look at an example of how we would use the random class to generate a random float value. In this code snippet, we once again create an instance of the random class and then we call the nextFloat() method. [Video description begins] <em>Eight code lines appear. Line 1 is: import java.util.Random;. Line 2 is: public class randomNumbers {. Line 3 is: public static void main(String args[]) {. Line 4 is: /* generate random number using nextFloat() */. Line 5 is: Random randNo &#61; new Random();.</em> [Video description ends] <br /><br />The purpose of the nextFloat() method is to generate a random float value between 0 and 1. The code snippet then outputs the results to the console. So each time we run this code we&#39;ll get a new value output to the console between 0 and 1, [Video description begins] <em>Line 6 is: System.out.println(&#34;using nextFloat():&#34; &#43; randNo.nextFloat());. Line 7 is: }. Line 8 is: }.</em> [Video description ends] and finally, let&#39;s take a look at an example of how we would use the random class to generate random Gaussian values. In this next code snippet, we once again create an instance of the random class, then we call the nextGaussian() method. [Video description begins] <em>Eight code lines appear. Line 1 is: import java.util.Random;. Line 2 is: public class randomNumbers {. Line 3 is: public static void main(String args[]) {. Line 4 is: /* generate random number using nextGaussian() */. Line 5 is: Random randNo &#61; new Random();.</em> [Video description ends] <br /><br />The purpose of the nextGaussian() method is to generate a random normally distributed value between 0 and a standard deviation of 1 from the random class&#39;s current sequence. Now, if that sounds complicated, it&#39;s because it&#39;s meant to be. Regardless, the output will be a double value that&#39;s between 0 and 1. [Video description begins] <em>Line 6 is: System.out.println(&#34;using nextGaussian():&#34; &#43; randNo.nextGaussian());. Line 7 is: }. Line 8 is: }.</em> [Video description ends]</div></div></div><div class="section"><a name="section_8" /><h2 class="section_title">9. Video: Programming the java.util.Random Class ( it_sdjcfa_10_enus_09)</h2><img src="https://cdn2.percipio.com/public/b/ead15fd3-1915-4ef5-845f-5885d577b398/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/ead15fd3-1915-4ef5-845f-5885d577b398/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the features and methods of the java.util.Random class
</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming the java.util.Random Class. Presented by: Sven Batalla.</em> [Video description ends] In this demo, we&#39;re gonna go over some of the features of Java&#39;s random class. In particular, we&#39;re gonna look at how to create an instance and then generate random values of various data types. All right, to do all that, we&#39;re gonna piggyback off of our previous demos which we built in Eclipse. So, let&#39;s head over to the Eclipse IDE now. All right, so I already have our project open from the previous demo, but if you don&#39;t, you can go ahead and open it now. <br /><br />[Video description begins] <em>An Eclipse IDE opens. It has a menu bar at the top with the following options: File, Edit, Source, etc. A tool bar is present with the following options: New, Run, etc. A Package Explorer is open on the left. It contains a folder named demo10. On the right side, an Outline pane is open. An editor is open in the center. It has a tab named Main.java which contains several lines of code. A Console pane is present at the bottom.</em> [Video description ends] <br /><br />Okay, so in our previous demo, we created a logging method so that we can output the results of a few basic commands to the console. In this demo, we&#39;re gonna call that same logging method to output some random values of various data types to the console. So, that means that we need to navigate to our main class, and we can do that by double clicking on the Main.java file in the Package Explorer on the left hand side of the screen, and I&#39;ve already got mine open. Good, now in this demo, we&#39;re gonna make use of Java&#39;s random class, and that means that we need to import a package into the file. So, let&#39;s go up to the very top of our code file, and between the package definition and our class definition, let&#39;s add the following code. import java.util.Random; [Video description begins] <em>He enters the mentioned code in line 3.</em> [Video description ends] <br /><br />Good, now what we&#39;ve done here is we&#39;ve imported the package that contains Java&#39;s random class, and that means that we can now use the random class in this class. In fact, the first thing we&#39;re gonna do is create an instance of the random class. So, let&#39;s go down to the bottom of our main method. Underneath the latest block of code we wrote, let&#39;s drop down a couple of lines and type the following. Random rand &#61; new Random(); [Video description begins] <em>He enters the mentioned code in line 27.</em> [Video description ends] Nice, now what we&#39;ve done here is we&#39;ve created an instance of our random class in our method, and we&#39;ve named that instance rand. So, now let&#39;s use it. Now, the random class can create all kinds of random values in all kinds of different data types. So, let&#39;s start with the most basic of all, the Boolean. <br /><br />A Boolean value can be true or false, and that&#39;s it. So, let&#39;s test out just how random this random class is. In the line below our random variable type this code, Log(&#34;random boolean&#34;, rand.nextBoolean());. [Video description begins] <em>He enters the mentioned code in line 28.</em> [Video description ends] Now, in this code, we&#39;re asking the random class to generate a random boolean value. So, let&#39;s save this file with a Ctrl&#43;S and then run the project with a Ctrl&#43;F11. Nice, so in the console output at the bottom of the screen, it&#39;s generated a value of false. Let&#39;s run the project a few more times and see what it outputs. Good, and notice that the result wasn&#39;t always the same. Sometimes I got true and sometimes I got false. It didn&#39;t just switch back and forth either. <br /><br />It randomly decided between the values. Okay, so that&#39;s boolean values, but what about floats and doubles? Well, let&#39;s give it a try. Let&#39;s add a new line below our code and type this, Log(&#34;random double&#34;, rand.nextDouble());. [Video description begins] <em>He enters the mentioned code in line 29.</em> [Video description ends] Good, now what this method and the nextFloat() method does is generate a value somewhere between 0 and 1, and that means that if you wanted a random number between 0 and 100, let&#39;s say, you&#39;d have to multiply the output by 100. Anyway, let&#39;s save this file and run the project to see what we get. Nice, pretty simple, isn&#39;t it? [Video description begins] <em>The output reads: random double: 0.446.</em> [Video description ends] <br /><br />Well, we seen now that we can do booleans and doubles and they&#39;re pretty simple, but there&#39;s also integers, and integers are pretty easy but they do have a twist. So, let&#39;s start with the simple method. Let&#39;s drop to the next line and type this, Log(&#34;random int&#34;, rand.nextInt());. [Video description begins] <em>He enters the mentioned code in line 30.</em> [Video description ends] Good, now let&#39;s give this a run. Perfect, now the interesting thing about the random integer is [Video description begins] <em>The output reads: random int: 1222180501.</em> [Video description ends] that it can also be negative. It&#39;s limited to the bounds of the integer itself. So, it can be anywhere between about 2 billion and -2 billion. So, let&#39;s run it a couple times so that we can see negative values. Right away, we got one. But with this method, there&#39;s a twist.<br /><br />One of the overloads allows you to put a bounding number in. So, let&#39;s do that. Let&#39;s put the number 10 inside the nextInt() method call. Good, now what this means is that the random class will generate a random integer value between 0 and 10. So, let&#39;s run it and find out. Perfect, now if we run it a few more times, we&#39;ll see a new value each time. [Video description begins] <em>The output reads: random int: 6.</em> [Video description ends] Great, so let&#39;s explore one more feature of the random class. You can actually use the random class to generate multiple random values at once. Rather than generating one at a time, you can ask the random class to generate a set of number values at random. So, let&#39;s give it a try. In the next line, let&#39;s type the following code, double doubles[] &#61; rand.doubles(5).toArray();. <br /><br />[Video description begins] <em>He enters the mentioned code in line 31.</em> [Video description ends] Good, now what we&#39;re doing in this line of code is that we&#39;re asking the random class to generate five random double values. Then we&#39;re converting the results to a standard array of doubles. Now let&#39;s output the results to the console. In the next line, type the following code, for(int i &#61; 0; i; doubles.length; i&#43;&#43;) { }. [Video description begins] <em>He enters the mentioned code in line 32.</em> [Video description ends] Perfect, now this is a simple for loop and it will iterate over all of the values in the array. So, now we&#39;re going to output each individual value to the console. So, inside the for loop squiggly brackets, let&#39;s type the following code, Log(&#34;random double &#34; &#43; (i &#43; 1), doubles[i]);. [Video description begins] <em>He enters the mentioned code in line 33.</em> [Video description ends] <br /><br />Good, now I won&#39;t bother explaining the indexing and labeling here. Suffice it to say that each of the five generated double values will be output to the screen this way. In fact, let&#39;s run the code and find out. Hey, perfect, each of our five values have been generated and output. In fact, you can run the code again and you&#39;ll see a different set of random values each time. Excellent, so that&#39;s Java&#39;s random class in a nutshell, as you can see, you can generate random values of virtually any data type, and you can even generate multiple random values at once. Great job.</div></div></div><div class="section"><a name="section_9" /><h2 class="section_title">10. Video: Java Math.random  ( it_sdjcfa_10_enus_10)</h2><img src="https://cdn2.percipio.com/public/b/1b8383fe-e7b4-4aad-aef9-1be5424b1269/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/1b8383fe-e7b4-4aad-aef9-1be5424b1269/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe features and methods of the Math.random class
</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Math.random . Presented by: Sven Batalla.</em> [Video description ends] An easy to use mechanism for generating random values in Java is to use the random method in the math class. The random method generates a Pseudorandom double value in much the same way that the random class does, when you call the next double method. The value that&#39;s generated is always between zero and one. Now, underneath the hood, the random method actually generates an instance of a random number generator. But it doesn&#39;t do it every time you call the method. Instead, the very first time it&#39;s called, the behind the scenes instance will be created, and then every new call after that, we&#39;ll just use that instance. <br /><br />In fact, the random number generator that gets generated is an instant of the random class. The Math.random method has one key aspect. It only generates double values, and it only generates those values between zero and one. So, if you wanted to generate a value within a certain range, you&#39;ll have to be clever about it. In fact, generally speaking, if you want to use the Math.random method to create random values between a range, you may have to create your own user defined method, like a random with range method, that accepts your desired range. Then, in your method, you would call the Math.random method with multipliers and offsets to generate values within the desired range. So let&#39;s take a look at an example of how we would use the Math.random method to generate a random value. <br /><br />In this code snippet, you can see that there&#39;s no need for any package import. And we don&#39;t have to create an instance of any classes. [Video description begins] <em>Nine code lines appear. Line 1 is: public class randomNumbers {. Line 2 is: public static void main(String[] args). Line 3 is: {. Line 4 is: // generate a random number.</em> [Video description ends] In fact, all we do in this code is call the Math.random method and assign the result to a double variable called x. [Video description begins] <em>He highlights code line 5.</em> [Video description ends] Then, the output is written to the console using the print line command. [Video description begins] <em>Line 7 is: System.out.println(x);. Line 8 is: }. Line 9 is: }.</em> [Video description ends] So in this case, each time we run the code, will generate a new random value between zero and one. <br /><br />But what if you wanted to generate a random integer in a certain range? Let&#39;s say we wanted to generate a random integer between 5 and 55. In this code snippet, we do just that. In fact, we use a few the math class methods to achieve it. [Video description begins] <em>Eight code lines appear. Line 1 is: public class randomNumbers {. Line 2 is: public static void main(String args[]) {. Line 3 is: // generate a range between 5 and 55 */.</em> [Video description ends] First, we placed all our code in a for loop so that we can generate 10 random values. [Video description begins] <em>Line 4 is: for (int i &#61; 0; i&lt;10; i&#43;&#43;) {.</em> [Video description ends] The first thing of note is that we call the Math.random method. As you know, this generates a random value between 0 and 1. <br /><br />Then we multiply the results by 50. Now this means that we&#39;re effectively generating a random double value between 0 and 50. Then, to make sure that the results are an integer without any decimal points, we use the Math.round method to round the results to the nearest integer. Now, this means that we will now have a random integer between 0 and 50. And finally we can take the result and add 5. [Video description begins] <em>Line 5 is: int randNo&#61; Math.round(Math.random() * 50.0) &#43; 5;.</em> [Video description ends] This gives us the final result of a random integer between 5 and 55.</div></div></div><div class="section"><a name="section_10" /><h2 class="section_title">11. Video: Programming Java Math.random  ( it_sdjcfa_10_enus_11)</h2><img src="https://cdn2.percipio.com/public/b/e6624855-f750-4047-ae1c-d8ea935ab76f/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/e6624855-f750-4047-ae1c-d8ea935ab76f/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the features and methods of the Math.random class
</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Math.random. Presented by: Sven Batalla.</em> [Video description ends] In this demo, we&#39;re gonna implement the random method in Java&#39;s Math class to replicate the capabilities of Java&#39;s Random class. In this demo, we&#39;ll be able to see what&#39;s possible with the Random method. But we&#39;ll also see that while it can be useful, it can be more difficult in other situation. All right, to do all of that, we&#39;re gonna piggyback off of our previous demo which we built in Eclipse. So, let&#39;s head over to the Eclipse IDE now. All right, so I already have our project open from the previous demo. If you don&#39;t, you can go ahead and open it now. [Video description begins] <em>An Eclipse IDE opens. A file named Main.java is open in the editor. It contains several lines of code.</em> [Video description ends] <br /><br />All right, so in our first demo, we did create a logging method so that we could output the results of a few basic commands to the console. In this demo, we&#39;re gonna call that same logging method to output our new random values to the console. So that means that we need to navigate to our Main class. And we need to do that by double clicking on the Main.java file in the Package Explorer panel on the left hand side of the screen, but I&#39;ve already got mine open. Good, now in our last demo, we made use of Java&#39;s random class. In this demo, we&#39;re gonna try to generate the same outputs but using the Random method in Java&#39;s Math class. The big advantage to the Random method in the Math class is that we don&#39;t have to import any packages, and we don&#39;t have to create a class instant. It also means that we can get right to coding. <br /><br />So let&#39;s start off with the easiest bit of code. In our Main method, let&#39;s drop down a couple of lines from our last code block and type the following code. Log(&#34;random double&#34;, Math.random());. [Video description begins] <em>He enters the mentioned code in line 36.</em> [Video description ends] Now, the random method generates a random double value between 0 and 1. And this is exactly the same as the next double method that we call in the Random class. But notice that we don&#39;t need to create a class this time. So let&#39;s run this code and see what we get. And remember, that&#39;s a Ctrl&#43;S and then a Ctrl&#43;F11. Perfect, now in the console log at the bottom of the screen, we now see our random double value. Okay, so now things get a bit tricky. What we want to do now is replicate what we did with the Random class. And to do that, we&#39;re gonna to use some tricks that we learned from using the Math class so far. <br /><br />Now, let&#39;s start with the boolean value. Let&#39;s keep things in the same order as before, so we&#39;re gonna add a line above the line that we just typed. So let&#39;s type this code, Log(&#34;random boolean&#34;, Math.rint(Math.random()) &#61;&#61; 1);. [Video description begins] <em>He enters the mentioned code in line 36. The subsequent code lines shift one line down.</em> [Video description ends] Cool, now what this line of code is doing is it&#39;s generating a random value between 0 and 1. Then we&#39;re using the rint method to round that value to 0 or 1, whichever one is closest. Then we&#39;re using a simple equals operator to decide if the value is equal to 1 or not. Basically what&#39;s happening here is that we&#39;re saying that any value generated at or above 0.5 will be considered true and all other values will be considered false. So let&#39;s run this and see what it says. <br /><br />Excellent, we got false. Now, let&#39;s run it a few times and make sure it works. False, false, true, false, nice. All right, so the next thing that we did with the random class is to create a random integer. Now this one&#39;s a bit tougher. In the end, we bounded our integer to a max of 10, but let&#39;s just start with a random integer. To do that, we&#39;re gonna write something lengthy. So stay with me on this. Here we go, Log(&#34;random int&#34;, Math.round(Math.random() * Integer.MAX_VALUE) * (Math.rint(Math.random())&#61;&#61;1?1:-1));. [Video description begins] <em>He enters the mentioned code in line 38.</em> [Video description ends] Now, that&#39;s quite a piece of code. Now all right, let me review it and tell you what&#39;s going on. Remember that the Random method generates a random number between 0 and 1. <br /><br />Well, the integer value is anywhere from about two billion to negative two billion. So the first thing we need to do is multiply that random value by the maximum size of an integer. So that means if we got the random value of 1, it would be converted to the maximum size of an int. But what it also means is that if we got the minimum random value of 0, then it would be converted to 0. Then, no matter the result, the value is rounded to the nearest integer, so that we don&#39;t have any decimal. Now remember that the random class is able to give us a random value all the way down to negative minimum of an integer. So the second part of the call does the same thing as a random boolean that we did before, except in cases where the random value is less than 0.5, it will multiply our result by -1. So in the end, this is using two calls to the Random method to generate a positive or negative random integer value. <br /><br />So let&#39;s see if it works, we&#39;ll save and run. I had a typo. Now we&#39;ll save and run. Fantastic, we&#39;ve generated an integer value. Now, let&#39;s run it a few times to make sure we&#39;re getting both positive and negative values. Perfect, now with the Random class, we&#39;re able to bound our random integer. Well, the good news is that we can do that here too without too much pain. In fact, it might even be easier. In our last demo, we bounded the result to between 0 and 10. Well, to do that here, all we have to do is replace the Integer.MAX_VALUE code with the number 10. And then we can remove the code that multiplies by 1 or -1. Perfect, now that&#39;s way less code, isn&#39;t it? [Video description begins] <em>He edits code line 38.</em> [Video description ends] Let&#39;s save this and run it. Perfect, we got a random integer between 0 and 10. Let&#39;s run it a couple times. <br /><br />Excellent, now finally, the last thing we did with the Random class is that we generated multiple double values at once. Well, sadly, the Random method in the Math class can&#39;t do that. The call to the Random method is for one value at a time. Now, we could simulate that by creating our own class or method, but if you do that, then you may as well just use the Random class. And in fact, you can see from the work that we&#39;ve done here that the Random class is quite a bit easier to use if you want to generate multiple random values, or random values of different data types other than double. Now regardless, that&#39;s the Random method in the Math class in a nutshell, great job.</div></div></div><div class="section"><a name="section_11" /><h2 class="section_title">12. Video: Java ThreadLocalRandom Class ( it_sdjcfa_10_enus_12)</h2><img src="https://cdn2.percipio.com/public/b/ef855e01-3f1a-4263-836a-f42a68092253/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/ef855e01-3f1a-4263-836a-f42a68092253/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe features and methods of the ThreadLocalRandom class
</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java ThreadLocalRandom Class. Presented by: Sven Batalla.</em> [Video description ends] Java&#39;s ThreadLocalRandom Class is one of the best ways to generate random values in Java. In fact, it&#39;s Java&#39;s best practice is to use this class wherever possible. It has a few characteristics worth noting. First compared to the thread local random class, the random class underperforms. And the reason that the random class doesn&#39;t work as well as the thread local random class generally has to do with its use in threads. If there are multiple threads, then each thread may use the same shared instance of the random class and this can result in Contention. And that&#39;s the key threading. In a Multi-threaded environment, it&#39;s much better to use the thread local random class. <br /><br />Now when the thread local random class was created, it was optimized to work in threaded environments. It&#39;s much faster and more efficient than the random class in multi-threaded scenarios. Now the ThreadLocalRandom and the Random class are very similar in usage almost identical actually. So let&#39;s compare them a bit. The ThreadLocal random class is actually combination of the thread local class and the Random class, hence its name. Well, it&#39;s been heavily optimized, it still does all of the same stuff as the random class under the hood. So they operate similarly because they&#39;re effectively the same class. Now, one difference between the classes is that Explicit initial seed setting is not supported in the thread local random class. However, you can update it before calling any of the random value generation methods. <br /><br />However, one of the major benefits of the thread local random class is that random value generation in the current thread, is not affected by other threads generating their own random values. Now like the random class, the ThreadLocalRandom class includes the ability to generate random values of lots of different data types. To do that you simply need to call the right static method. For example, the first method that you&#39;ll have to call before calling any of the rest of the methods is the current static method, and this returns a pointer to the current threads instance of a random value generator. Then, once you have the current thread, you can call the nextInt, the nextDouble, the nextfloat, and the nextboolean methods to generate a single random value of any data type and method reference.<br /><br />And finally, we have the ability to update the seed value by calling the setSeed method. Now, let&#39;s take a look at an example of how we might generate some random integers with the ThreadLocalRandom class. In this code snippet, we import the ThreadLocalRandom package right at the top of the coat. [Video description begins] <em>Seven code lines appear. Line 1 is: import java.util.concurrent.ThreadLocalRandom;. Line 2 is: public class randomNumbers {. Line 3 is: public static void main(String[] args). Line 4 is: {.</em> [Video description ends] Then you&#39;ll notice that we don&#39;t need to create an instance of the ThreadLocal Random class anywhere. In the code all we have to do is call the current method to get the current threads random value generator, and then call the nextInt method to generate a random value anywhere in the integer spectrum.<br /><br />[Video description begins] <em>Line 5 is: System.out.println(&#34;ThreadLocalRandominteger result:&#34; &#43; ThreadLocalRandom.current().nextInt());. Line 6 is: }. Line 7 is: }.</em> [Video description ends] The result is then output to the console. So in this case, each time we run this code we&#39;ll get a new random value somewhere between negative two billion and positive two billion. Now, let&#39;s take a look at an example of how we might generate some random doubles with the ThreadLocalRandom class. In this code snippet, we once again import the ThreadLocalRandom package right at the top of the code. [Video description begins] <em>Six code lines appear. Line 1 is: import java.util.concurrent.ThreadLocalRandom;. Line 2 is: public class randomNumbers {. Line 3 is: public static void main(String[] args).</em> [Video description ends] <br /><br />Then in the main body of the code, we call the current method to get access to the current threads random value generator. And then finally, we call the next double method to generate a random double value between zero and one. [Video description begins] <em>Line 4 is: System.out.println(&#34;ThreadLocalRandomdouble result:&#34; &#43; ThreadLocalRandom.current().nextDouble());. Line 5 is: }. Line 6 is: }.</em> [Video description ends] Pretty simple really. And finally, let&#39;s take a look at something a little bit different. Let&#39;s take a peek at an example of how we might generate some random Boolean values with a ThreadLocalRandom class. <br /><br />In this code snippet, you&#39;ll see that we&#39;re running the same type of code that we ran in the last couple of examples, except in this case, [Video description begins] <em>Six code lines appear. Lines 1, 2, 3, 5, and 6 are the same as the previous slide.</em> [Video description ends] we&#39;re calling a method called nextBoolean. [Video description begins] <em>Line 4 is: System.out.println(&#34;ThreadLocalRandom Boolean result:&#34; &#43; ThreadLocalRandom.current().nextBoolean());.</em> [Video description ends] The purpose of the nextBoolean method is to generate a random boolean value. That&#39;s it. So each time we run this code, we&#39;ll get a random true or false value. Now, they don&#39;t alternate in other words, if I got true this time it doesn&#39;t mean I&#39;ll get false next time. <br /><br />That wouldn&#39;t be very random would it? In fact, I&#39;ve run demos in the past to show this off and I get the result of false ten times in a row. Unlikely as it was, it is pretty common for a demo.</div></div></div><div class="section"><a name="section_12" /><h2 class="section_title">13. Video: Programming the Java ThreadLocalRandom Class ( it_sdjcfa_10_enus_13)</h2><img src="https://cdn2.percipio.com/public/b/a066c4b1-c7a5-47c8-bf93-c89357de1e6e/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/a066c4b1-c7a5-47c8-bf93-c89357de1e6e/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the features and methods of the ThreadLocalRandom class
</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming the Java ThreadLocalRandom Class. Presented by: Sven Batalla.</em> [Video description ends] In this demo, we are gonna implement Java&#39;s ThreadLocalRandom class to replicate abilities of Java&#39;s Random class. In this demo, we&#39;ll able to see what&#39;s possible with the thread local random class. And we&#39;ll see that it can be just as useful if not better than the random class. All right, now one last time, we&#39;re gonna piggyback off of our previous demo which we built in Eclipse. So let&#39;s head over to the Eclipse IDE now. [Video description begins] <em>An Eclipse IDE opens. A file named Main.java is open in the editor. It contains several lines of code.</em> [Video description ends] <br /><br />All right, so I already have our project open from the previous demo, and again, if you don&#39;t, go ahead and open it now. Okay, so as you&#39;ve come to see in this course, in our first demo, we created a logging method, so that we could output the results of a few basic commands to the console. In this demo, we&#39;re gonna keep calling that method to output our new random values to the console too. So that means that we need to navigate to our main class, and we can do that by double clicking on it in the package explorer on the left hand side of the screen. Mine&#39;s already open. Good, now in our last demo, we tried to use the random method in Java&#39;s math class to replicate the capabilities of Java&#39;s random class, which we implemented in the demo before. Now in this demo, we&#39;re gonna try to replicate the capabilities of Java&#39;s random class again, but this time with Java&#39;s thread local random class. <br /><br />Now, one of the advantages of the thread local random class is that we don&#39;t have to create a class instance. But we do have to import a package. So let&#39;s do that first. Now at the top of the file in a new line below our import for the random package, let&#39;s add the import command, import java.util.concurrent.ThreadLocalRandom;. [Video description begins] <em>He enters the mentioned code in line 4. The subsequent code lines shift one line down.</em> [Video description ends] Good, now this imports the Thread Local Random class into our project so that we can use it in our class. I&#39;m gonna start calling it TLR. Now, as you may be able to guess from the name, the TLR class is primarily used for thread safety. In fact, Java recommends using this class instead of sharing an instance of the random class. <br /><br />Remember that when we use the random class, we have to create an instance. Well, if we shared that between threads, the concurrency could cause collisions. The TLR class is intended to handle that for you behind the scenes. All right, so if that&#39;s all true, then let&#39;s see if we can use it just like we did with the random class. So let&#39;s go down to the bottom of our main method. Drop down a couple of lines from our latest code block and type the following code. Log(&#34;random boolean&#34;, ThreadLocalRandom.current().nextBoolean());. [Video description begins] <em>He enters the mentioned code in line 41.</em> [Video description ends] Now, in this code we&#39;re asking the TLR class to generate a random boolean value. Now, notice how the code is identical to the code that we wrote for the random class. The only difference is that in this case, you didn&#39;t need to create an instance of the TLR class. The other thing you&#39;ll see is the current method. <br /><br />Now that&#39;s a reference to the current thread. It&#39;s really the only static method so let&#39;s not worry too much about that. Anyway, let&#39;s save the file with a Ctrl&#43;S and run the project with a Ctrl&#43;F11 to see what it tells us. Nice, so in the console output at the bottom of the screen it generated a value of true. Now, let&#39;s run the project a few more times and see what it outputs. True, true, false. True, false. Good, now notice how the result wasn&#39;t always the same and behave just like the random class. So far, so good. Okay, so we know that we can replicate the random Boolean values correctly, but what about floats and doubles? Well, let&#39;s give it a try. Let&#39;s add a new line below our code and type this, log(&#34;random double&#34;, ThreadLocalRandom.current().nextDouble());. [Video description begins] <em>He enters the mentioned code in line 42.</em> [Video description ends] Good, now once again, this method is exactly the same syntax as the random class. <br /><br />This method also generates a random value somewhere between 0 and 1. Anyways, let&#39;s save the file, run the project, and see what we get. Perfect, that&#39;s pretty simple, isn&#39;t it? [Video description begins] <em>In the Console pane, the following output appears: random double: 0.781.</em> [Video description ends] Great, so now we can replicate the random classes Boolean and Double methods, but let&#39;s not forget about that tricky integer and it&#39;s bounding. But let&#39;s start with the unbounded random integer. Let&#39;s drop in the next line and type this, log(&#34;random int&#34;, ThreadLocalRandom.current().nextInt());. [Video description begins] <em>He enters the mentioned code in line 43.</em> [Video description ends] Good, now let&#39;s give that a run. <br /><br />Perfect, now just to make sure that this is the same as the random class, let&#39;s run this a few times to make sure that we&#39;re getting values that are both positive and negative. After all, remember that an integer can technically be anywhere between roughly 2 billion and negative 2 billion. Good, now let&#39;s see if we can bound the random number generation like we did with the random class. Let&#39;s put the number 10 inside nextInt. [Video description begins] <em>He edits code line 43.</em> [Video description ends] Good, now what this should mean is that the TLR class will generate random integer between 0 and 10. So let&#39;s run it and find out. 4, perfect, and if we run it over and over again, we should get different values between 0 and 10 each time. Good job. <br /><br />Okay, so now in our previous demo, we tried to replicate the random classes ability to generate multiple random values at once, and we quickly discovered that, that wasn&#39;t possible. Now is the TLR class able to do it? Well, yes, it is. In fact, let&#39;s give it a try. In the next line, let&#39;s type the following code, double doubles2[] &#61; ThreadLocalRandom.current().doubles(5).toArray();. [Video description begins] <em>He enters the mentioned code in line 44.</em> [Video description ends] Now, what we&#39;re doing in this line of code is that we&#39;re asking for the TLR class to generate five random dummy values. Then just like we did with the random class, we&#39;re converting the results to a standard array of doubles, which we&#39;ve called doubles2 this time. Now, let&#39;s output the results to the console. In the next line, let&#39;s type the following code. for(Int i &#61; 0; i ; doubles2.length; i&#43;&#43;) {}. <br /><br />[Video description begins] <em>He enters the mentioned code in line 45.</em> [Video description ends] Perfect, now this is a simple for loop and it will iterate over all the values in the array. So now, we&#39;re gonna output each individual value to the console. So inside the for loops squiggly brackets, let&#39;s type this code, log(&#34;random double &#34; &#43; (i &#43; 1), doubles2[i]);. [Video description begins] <em>He enters the mentioned code in line 46.</em> [Video description ends] Good, now once again, I&#39;m not gonna bother explaining the indexing and labeling here. Suffice it to say that each of the five generated double values will be output to the screen. In fact, let&#39;s run the code and find out. Save, Ctrl&#43;F11. Hey, perfect. Each of our five values has been generated and output. In fact, you can run the code again and you&#39;ll see a different set of random values each time. <br /><br />Excellent, so that&#39;s Java&#39;s Thread Local Random class in a nutshell. As you can see, it perfectly mimics the random class, so you can generate random values of virtually any data type, and you can even generate multiple random values at once. The advantage is that it&#39;s more thread safe and doesn&#39;t require an instance to be created. Great job.</div></div></div><div class="section"><a name="section_13" /><h2 class="section_title">14. Video: Course Summary ( it_sdjcfa_10_enus_14)</h2><img src="https://cdn2.percipio.com/public/b/b065fb4e-b6ee-4db9-9fe0-de908881e10d/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/b065fb4e-b6ee-4db9-9fe0-de908881e10d/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">summarize the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Summary.</em> [Video description ends] So in this course, we&#39;ve examined the Java Math and Random number generator classes. We did this by exploring Programming Java Math and Basic Math classes, Advanced Math classes and programming, Programming with Java Random classes and the java.until.Random class, and Programming with the Math.random and ThreadLocalRandom classes. In our next course, we&#39;ll move on to explore various types of Java decisions statements.</div></div></div><div class="copyright-container"><span class="copyright-text">Â© 2023 Skillsoft Ireland Limited - All rights reserved.</span></div></div><div id="lb-overlay"><div class="lb-header"><button onclick="(()=>{const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'hidden';const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 1.0;curtain.style.backgroundColor = 'white';curtain.style.pointerEvents = 'auto';})();">X</button></div><div id="lb-image-container"><img id="lb-image" alt onload="(()=>{const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 0.5;curtain.style.backgroundColor = 'grey';curtain.style.pointerEvents = 'none';const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'visible';window.scrollTo(0, 0);})();"/></div><div class="lb-footer" /></div></div></body></html>