<!doctype html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-style-type" content="text/css2"><title>Course Transcript</title><link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css"><style>:root {
    --title-text: #243038;
    --toc-link: #0073C4;
    --section-title-text: #243038;
    --section-title-border: #bababa;
    --grid-caption-text: #164794;
    --grid-border: #c0c0c0;
    --grid-hdr-text: #973131;
    --grid-hdr-background: #f7f7f7;
    --missing-data: #767676;
    --text-color: #343434;
    --lightbox-border: #a0a0a0;

    --bold-font-weight: 700;

    font-family: Lato;
}

.report {
    margin: 24px;
}

.container {
    position: relative;
}

#lb-curtain {
    background-color: white;
    opacity: 1.0;
}

#lb-overlay {
    position: absolute;
    top: 40px;
    left: 20px;
    right: 20px;
    background-color: white;
    border: solid 1px var(--lightbox-border);
    visibility: hidden;
}

.lb-header, .lb-footer {
    height: 40px;
    line-height: 40px;
}

.lb-header {
    display: flex;
    justify-content: flex-end;
    padding-right: 20px;
}

#lb-image-container {
    margin: 0 40px;
}

#lb-image {
    width: 100%;
}

.report_title {
    font-size: 22px;
    font-weight: var(--bold-font-weight);
    color: var(--title-text);
}

.toc_link {
    font-size: 14px;
    color: var(--toc-link);
    margin-top: 6px;
    margin-bottom: 0;
}

.section {
    margin-top: 40px;
    margin-left: 16px;
}

.section.inner {
    margin-top: 20px;
}

.section.inline {
    margin-top: 20px;
    margin-left: 0;
}

.section_title {
    font-size: 18px;
    font-weight: var(--bold-font-weight);
    width: 100%;
    color: var(--section-title-text);
}

h2.section_title {
    border-bottom-color: var(--section-title-border);
    border-bottom-style: solid;
    border-bottom-width: thin;
}

h3.section_title {
    margin: 8px 0;
}

h3.list_title {
    margin: 8px 0;
    font-size: 14px;
    color: var(--title-text);
}

.section_text {
    font-size: 14px;
    color: var(--text-color);
    margin: 12px 0;
    width: 90%;
}

.section_link {
    font-size: 14px;
    margin: 12px 0;
    width: 90%;
}

.grid {
    border-collapse: collapse;
}
.grid_caption {
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    color: var(--grid-caption-text);
    margin: 12px 0;
    text-align: left;
    white-space: nowrap;
}
.grid_hdr_row {

}
.grid_col {
    font-size: 13px;
    color: var(--text-color);
    border-collapse: collapse;
    padding: 2px;
    text-align: left;
    vertical-align: top;
}
.grid_col_hdr, .grid_row_hdr {
    font-size: 12px;
    font-weight: var(--bold-font-weight);
    white-space: nowrap;
}
.grid_row_hdr {

}

.empty_grid {
    border-collapse: collapse;
    border-color: var(--grid-border);
    border-style: solid;
    border-width: 2px;
    padding: 4px;
    text-align: center;
}

.htmlbox {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    padding: 8px;
}

.list {
    font-size: 14px;
    font-style: italic;
}

.missing_data {
    color: var(--missing-data);
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    font-style: italic;
}

.copyright-container {
    margin-top: 24px;
    text-align: center;
}
.copyright-text {
    color: var(--text-color);
    font-size: 12px;
}

/* Transcript Questions CSS */

.question {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    display: flex;
    flex-direction: column;
    padding: 8px;
}

.question_content {
    display: flex;
    justify-content: space-between;
}

.question_details {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.question_images {
    display: flex;
    flex-direction: column;
    margin-left: 16px;
}

.question_image {
    margin-bottom: 8px;
}

.question_title {
    font-weight: var(--bold-font-weight);
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
    padding-bottom: 8px;
    margin-bottom: 8px;
}

.question_label, .question_stem {
    font-weight: var(--bold-font-weight);
    margin-top: 8px;
    margin-bottom: 8px;
}

.question_data_row {
    display: flex;
}

.question_data_col1 {
    padding: 8px;
    white-space: nowrap;
}

.question_data_col2 {
    padding: 8px;
    display: flex;
    flex-direction: column;
}

.question_answer_key {
    margin-top: 8px;
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
}

.feedback {
    font-style: italic;
}
</style></head><body class="report"><div class="container"><div class="content" id="lb-curtain"><h1 class="report_title">Java Certified Foundations Associate: Java Methods</h1><div class="section_text"><p>Java is an object-oriented programming language that uses classes to store data and provide methods to access and manipulate this data. In this course, you will learn how to create and use methods to manipulate the data inside a class. First, you will learn about Java methods, accessor methods, and mutator methods and how they are used in Java classes. Next, you will learn about describe overloading in Java and when to use it should be used. Next, you will learn about interfaces and how they are used to specify the behavior that a Class must implement. Finally, you will learn about the static keyword and how it can be applied to a method in a Class. This course is one of a collection of courses that prepares learners for Oracle’s 1Z0-811: Java Certified Foundations Associate certification.</p></div><div class="section"><h2 class="section_title">Table of Contents</h2><div class="toc"><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_0">1. Video: Course Overview (it_sdjcfa_17_enus_01)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_1">2. Video: Java Methods (it_sdjcfa_17_enus_02)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_2">3. Video: Programming Java Methods (it_sdjcfa_17_enus_03)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_3">4. Video: Java Accessor Methods (it_sdjcfa_17_enus_04)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_4">5. Video: Programming Java Accessor Methods (it_sdjcfa_17_enus_05)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_5">6. Video: Java Mutator Methods (it_sdjcfa_17_enus_06)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_6">7. Video: Programming Java Mutator Methods (it_sdjcfa_17_enus_07)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_7">8. Video: Java Method Overloading (it_sdjcfa_17_enus_08)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_8">9. Video: Programming Java Method Overloading (it_sdjcfa_17_enus_09)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_9">10. Video: Java Interfaces (it_sdjcfa_17_enus_10)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_10">11. Video: Programming Java Interfaces (it_sdjcfa_17_enus_11)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_11">12. Video: Java Static Methods (it_sdjcfa_17_enus_12)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_12">13. Video: Programming Java Static Methods (it_sdjcfa_17_enus_13)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_13">14. Video: Course Summary (it_sdjcfa_17_enus_14)</a></p></div></div><div class="section"><a name="section_0" /><h2 class="section_title">1. Video: Course Overview (it_sdjcfa_17_enus_01)</h2><img src="https://cdn2.percipio.com/public/b/91a8348d-1ae8-41d2-9101-2807c18015ed/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/91a8348d-1ae8-41d2-9101-2807c18015ed/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about your instructor and this course. In this course, you’ll learn how to create and use methods to manipulate the data inside a class.</p>
<p>You’ll discover Java methods, Accessor methods, and Unitary methods and see how they’re used in Java classes. Next, you’ll learn about overloading in Java and when it should be used. Finally, you’ll learn about the static keyword and how it can be applied.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">discover the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Overview</em> [Video description ends]
<p>Hello and welcome to the course. My name is Peter Adamson and I&#39;m going to be your instructor for this Java methods course. A little bit about myself, I have a background in Computer Science as well as Engineering, and I&#39;ve spent most of my time working as a Security Software Developer.<br /><br />[Video description begins] <em>Your host for this session is Peter Adamson. He is a Security Software Developer.</em> [Video description ends] <br /><br />A lot of my career&#39;s focus has been on Cyber Security in conjunction with Software Development. Java is an object-oriented programming language that uses classes to store data and provides methods to access and manipulate this data. In this course, you will learn how to create and use methods to manipulate the data inside a class.</p>
<p>First, I&#39;ll discuss Java methods, Accessor methods, and Unitary methods and how they are used in Java classes. Next, I&#39;ll describe overloading in Java and when it should be used. Next, I&#39;ll cover interfaces and how they are used to specify the behavior that a class must implement. Finally, I&#39;ll move on to the static keyword and how it can be applied to a method in a class.</p></div></div></div><div class="section"><a name="section_1" /><h2 class="section_title">2. Video: Java Methods (it_sdjcfa_17_enus_02)</h2><img src="https://cdn2.percipio.com/public/b/9227885b-4982-44e8-b327-701eb6d80c6d/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/9227885b-4982-44e8-b327-701eb6d80c6d/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about what Java methods are. Java methods are also called functions. You’ll learn Java methods are a collection of code that performs an operation. You’ll look for operations you would have to carry out in your code repeatedly, and rather than writing in that operation over and over again, you put it into a method. You’ll see an example of this onscreen.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe Java methods and how they are used in Java classes</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Methods. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Let&#39;s begin by talking about what Java Methods are. You might also hear Java methods called functions, and you can use these terms pretty much interchangeably. A Java method or a Java function is effectively the same thing. Whether you refer to these things as Java methods or Java functions, it&#39;s all referring to the same type of thing, and what that thing is, is a collection of code that performs an operation. We&#39;re trying to look for operations that we would have to carry out in our code repeatedly, and rather than writing in that operation over and over again, we put it into a method which allows us to call that method repeatedly rather than having to duplicate code over and over again.</p>
<p>So an example of this could be the operation of adding five to a number. Let&#39;s say for whatever reason we have a piece of code, and we have to repeatedly add five to different numbers. So what we could do is have an add five method, and what that method would do is take a parameter, such as an integer, and it would return to you the result of adding five to that integer, and then we can continually add five to different integers by passing different integers as parameters to the method, and in general, these Java methods don&#39;t run automatically. There are a few exceptions that we&#39;ll get into down the road, but generally, methods are run when they&#39;re called.</p>
<p>So, if you have a method that&#39;s part of a class, and you create an object out of that class, in order to run a method, you would have to use the dot syntax to say object dot method name, and then that would tell Java now I want you to run this method, and as I alluded to, the real benefits of the use of Java methods is that we can write code once and then use it many times. We don&#39;t want to have to be writing any more code than we have to. So if you find yourself performing the same operation multiple times, that can be a trigger to you to think, oh, maybe I should be putting this into a method so I can be calling the method many times, rather than writing this code over and over again.</p>
<p>Now we can talk about some of the Features of Java methods. The first is that they have to be defined within the body of a class, whether they have to be members of that class, and that&#39;s because you have to have either an object to call the method on, or an actual instance of the class to call it on in some way, and we can pass parameters to a method. If our method was completely fixed in the values that it would had to work on, it wouldn&#39;t be very useful to us, we need to have it dynamic in some way. That&#39;s where parameters being passed to the method come in. Let&#39;s go back to our add five method. If our add five method was fixed, and it could only ever add five to the value seven.</p>
<p>That&#39;s not very useful to us, that would only be useful in the case where we wanted to add five to the value seven. But if instead we take a variable parameter as an argument to our method, now we can add five to that parameter, and we can add flexibility and dynamicism into our code by passing different parameters. Now we could pass the value four, and it would give us a value of nine, and then further on in our code, we could pass the value six, and it would give us a value of 11. And that&#39;s how we build this dynamic nature into our code by the use of parameters to our method. Another feature of the Java method is that it has the ability to return results to us.</p>
<p>When we call that add five method, it returns to us the result of adding five to our parameter. In that case, it&#39;s returning value is an integer. Java methods don&#39;t have to return anything, they can be void in their return type, which means they perform an operation, but don&#39;t necessarily return a value. So let&#39;s take a printing method, for example. Say we have a method that formats are statements for printing to the console, and that&#39;s all it does. Well, in that case, it can be void because it&#39;s just going to print to the console, but we don&#39;t care about any return values there. So, Java methods can return results, but they don&#39;t have to. Methods in Java can either be Static or Non-Static.</p>
<p>The difference between the two, Static methods don&#39;t require you to first instantiate an object of a class in order to call them. Whereas Non-Static methods do require you to call them on an object, you have to first create an object out of a class and then call the non-static method. So, to give you an example of what this kind of means in practice, let&#39;s say we have a class called example. An example has a static method called static example, and a non-static method called non-static example. Well, the static example, I can call directly on the class. So I could say example.static example, that&#39;s totally legitimate. But I couldn&#39;t do that with my non-static method. I couldn&#39;t say example.non-static example, I would have to create an object first.</p>
<p>So I could say, example object is now an object of my example class, and then, I could call my non-static method, I could say, object example.non-static example, and that&#39;s how I have to call a non-static method. At this point, we have a pretty good theoretical idea of what methods are and what we can do with them. So let&#39;s take a look at a practical example of how we could actually implement Methods. So first, how do we create a method? Well, we do it with a declaration, such as is on the screen static void myMethod(). Let&#39;s look at each of these parts of the declaration in turn.</p>
<p>First, we have static, and this is declaring whether a method is static or not. A method by default is non-static, so if you leave the static keyword out, that makes a non-static method, and if you put the static keyword in there, that makes a static method. Next, we have void, this is the return type. The return type of the method goes right before the method name, and it defines what the method is going to be returning. So if the method isn&#39;t returning anything, we would type void. If it&#39;s returning an integer, it would be int. If it&#39;s returning a double, it would be double, and so on.</p>
<p>Next, we have myMethod, which is the actual name of the method. It&#39;s convention in Java to do camel case, which means the first words starts with the lower case letter and the every other words starts with the upper case letter, and then we have an opening and closed round parenthesis, and this is where you would put any parameters. A method doesn&#39;t have to take parameters, so in this case it&#39;s not taking any parameters. But if it was, it would go within these parentheses, and then you have an open curly brace, and that open curly brace signifies where the code of your method starts, and then you have a closed curly brace to signify that your method code has finished.</p>
<p>If you want to call a method, we use the terminology myMethod, in the case if our method is called myMethod, followed by parentheses. So it&#39;s the name of the method, followed by parentheses, and then whatever parameters have to be given to the method. In this case, our method takes no parameters, so we don&#39;t pass it any parameters, and then we have a semicolon to signify our method call is over, and what goes in front of the method call depends on whether you&#39;re dealing with a static method or a non-static method. So if it&#39;s a static method, you can put the class name in front .myMethod, and if it&#39;s a non-static method, you could have the object name .myMethod. If our method did happen to take parameters, let&#39;s say between that parentheses and our declaration line it took an integer n, then we could pass it an integer, such as we see here with myMethod(10); and this would pass the value 10 to our method.</p>
<p>The code on screen here represents a Method Structure Without a Return Value, in this case using void methods. So we have two methods within our main class. So our class declaration is the first line with public class main, and then an open curly brace, and then near the bottom of the screen just above the output line is the closed curly brace signifying the end of that class, and within that class body, we have two defined methods. We have myMethod, and we have a main method. Let&#39;s look at myMethod first.</p>
<p>It&#39;s defined as public static void myMethod, and this follows the signature line that we looked at on the previous page, followed by an open curly brace, and then two lines of code, we define a string called myString, and we set it equal to Hello world, and then we print out the value of my string to the console, and then we have a close curly brace, which signifies the end of myMethod.</p>
<p>Then we have our main method, and our main method is sort of a special method in Java that gives our code an entry point, a starting point. So you can think of the main method as the point where all of our code is going to start, and it&#39;s defined as public static void main(String[] args) as parameters, and then an open curly brace, followed by a line of code saying myMethod with an open parentheses, and a closed parenthesis, and a semicolon, and then a closed curly brace below that to signify the end of our main method.</p>
<p>One thing that we haven&#39;t talked about is the public modifier in front of both of our methods, that public modifier defines who can see and use our methods. In the case of a public access modifier and our method, it can be used by any Java class. We could also have our methods as private and then the method can only be used by the class that it is defined within, and we can also have protected methods in which case the method can be used by any class within the same Java package. Now, going back to this, our main method is calling myMethod. So what will happen is all of the code within my method will get executed, so we will print out the value of my string to the console, and we see that at the bottom of our screen beside output, where it says Hello world, because that&#39;s what will get printed out by this method.</p>
<p>Here we have an example of Passing Parameters to a Method. So once again, we have a main class defined on the first line, and then within that we have two methods, our first is called public static void myMethod, and our second is our main method, public static void main, but our signature call for myMethod has changed a little bit. Now in the parentheses instead of being empty, we have two parameters, int i, and int j. So, this is telling Java is that anytime myMethod is called expect to also have two integers passed to myMethod, and what myMethod will do is print out the value of i multiplied by j, as seen on the code line between the open curly brace and the close curly brace, following my method, and then in our main method, we call myMethod, and in the parentheses, we have two values 5 and 10.</p>
<p>So, 5 will be the value of i when the method is run, and 10 will be the value of j when the method is run. So what will happen is myMethod would be called, and then we&#39;ll run that code line System.out.println(i * j), which will be 5 times 10, the result of which is 50, and we can see that on our output line at the bottom of the screen, 50. And finally, we have an example of Calling a Method on an Object. Once again, we have our main class defined on line 1, public class Main, and we have two methods defined within main. We have our first method, public static void breed and it takes one parameter of type string called dogBreed, and then we have our second method which is our main method, public static void main (String[] args).</p>
<p>Within our breed method, we simply print out the value of whatever is passed to it as a string. So System.out.println(dogBreed) is the code contained within the body of our breed method. Now within our main method, we first create an object called myDog, and that&#39;s on the code line. Main myDog &#61; new Main. So this is doing is instantiating an object out of the main class and assigning it to the variable myDog, and what we can then do near the bottom of our main method is call the method on that object, as seen with myDog.breed, and then we pass it the string value Labrador Retriever, and once that is called, the method breed will be run, and the value will be printed to the console, and we can see the output at the bottom of our screen, Labrador Retriever.</p>
<p>Essentially, it raises an interesting point, our breed method is static, so we don&#39;t actually have to create an object in order to call it, but we are allowed to call static methods on an object. So just because we can call static methods on classes directly, doesn&#39;t mean we have to we can still call static methods on objects.</p></div></div></div><div class="section"><a name="section_2" /><h2 class="section_title">3. Video: Programming Java Methods (it_sdjcfa_17_enus_03)</h2><img src="https://cdn2.percipio.com/public/b/dc58a9e1-7539-4201-80ab-84d1d92bc355/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/dc58a9e1-7539-4201-80ab-84d1d92bc355/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. In this demonstration, you’ll learn to create and use methods in Java classes. Onscreen, you’ll see the IDE on the left side in the project pane. You’ll right-click the source folder, navigate to New and click Java Class, and this will create a New Java Class.</p>
<p>You’ll call it MethodExample.java, and then hit Enter, and it creates the class.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate Java methods and how they are used in Java classes</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Methods. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this demonstration, I&#39;m going to show how we can create and use methods in Java classes. <br /><br />[Video description begins] <em>An IntelliJ IDE window displays. The menu bar contains the following options, including: File, Edit, View, Navigate, Code, and Analyze. The Project window is present on the left. It contains a project folder, titled: it_sdjcfa_17_enus_03. This folder contains various sub folders, including: .idea, src, and it_sdjcfa_17_enus_03.iml. The right pane displays the following information: Search Everywhere Double Shift, Go to File Ctrl&#43;Shift&#43;N, Recent Files Ctrl&#43;E, and Navigation Bar Alt&#43;Home.</em> <br />[Video description ends] <br /><br />So within my IDE, on the left side in the project pane, I&#39;m going to right-click on my source folder, navigate to New and click Java Class, and this will create a New Java Class for me.<br /><br />[Video description begins] <em>A context menu appears. It contains the following options, including: New, Cut, Copy, Paste, and Local History.</em> [Video description ends]<br /><br />[Video description begins] <em>A context sub menu appears. It contains the following options, including: Java Class, File, Scratch File, Package, and HTML File.</em> [Video description ends]<br /><br />[Video description begins] <em>A pop-up box titled: New Java Class opens. It contains an input field to enter the Name.</em> [Video description ends] <br /><br />In this case, I&#39;m going to call it MethodExample.java, and then I hit Enter, and it creates the class for me. <br /><br />[Video description begins] <em>The right pane displays a file titled: MethodExample.java. It contains the following lines of code. Line 1 reads: public class MethodExample {. Line 2 reads: }.</em> [Video description ends]<br /><br />I&#39;m going to hit Enter one time to create a space between my method declaration and the closing curly brace, and we can see the declaration automatically created for me on line 1, public class MethodExample. So here we have our class and we&#39;ll create our method in the body of that class.</p>
<p>Let&#39;s have a method within our method example that takes in an integer, and it will add five to the value of that integer, and then return the new value with five added on to the original value. So to start with, to declare a method, we need an access modifier. In this case, we&#39;re going to make our access modifier public so that our message can be accessed from outside of the class. Then we need a return type. In this case, since we&#39;re going to be taking in an integer and returning an integer, then our return type is going to be int, and then we need a name for our method, so we would call it addFive, and we&#39;ll do it in camel case, which means that the first word is lowercase with the first letter, and then every other word is capitalized at the start, and then we have our open parentheses and close parentheses. Between these, we&#39;re going to be putting in our parameters or arguments.</p>
<p>So we&#39;re going to be taking in one integer and we&#39;ll call it n, and then we need to define the body of our method, so we define an open brace and a closed curly brace, and now on line 2, you can see our full method declaration, public int addFive(int n){, and then on line 3, we have a blank line where we&#39;re going to start to put in our body of code, and on line 4, we have our closed curly brace indicating the end of the method, and in this case, the method is very simple. We&#39;re only going to have a single return statement and we&#39;re going to say return n&#43;5, and now on line 3, we have our return statement which will take in the value of n, add five to it and return that. <br /><br />[Video description begins] <em>Line 3 reads: return(n&#43;5);.</em> [Video description ends] <br /><br />So this is how we can create our Java method. Now let&#39;s look at how we can use our Java method.</p>
<p>So I&#39;m going to go back to my Project window pane on the left side, right-click my source folder, select New &gt; Java Class, and I&#39;m going to call this one simply Main.java, and Main.java is going to house our Main method which we&#39;re going to use to call our addFive method. <br /><br />[Video description begins] <em>The right pane displays a file titled: Main.java. It contains the following lines of code. Line 1 reads: public class Main {. Line 2 reads: }.</em> [Video description ends] <br /><br />Here we can see we now have a Main.java in my main project window. So on line 1, we have our class declaration with public class Main. On line 2, I have the main method declaration with public static void main String args, and now we&#39;re going to use the method that we created in our method example class. <br /><br />[Video description begins] <em>Line 2 reads: public static void main(String[] args) {.</em> [Video description ends] <br /><br />Because our method in method example is not static, we first need an object of MethodExample to work on. In order to do that, I&#39;m going to create MethodExample which is the type of my object. obj, which is the name of my object, &#61; new MethodExample, and now I have an object of type MethodExample that I can work on.<br /><br />[Video description begins] <em>Line 3 reads: MethodExample obj &#61; new MethodExample();.</em> [Video description ends] </p>
<p>What we&#39;re going to do is print out the result of our addFive method. So on line 4, I&#39;m going to type in System.out.println, and then we&#39;re going to call obj.addFive with the value 4, and if everything works as it should, this will take in the value of 4, add 5 to it to give us a result of 9 and print that to the command line. <br /><br />[Video description begins] <em>Line 4 reads: System.out.println(obj.addFive(4));.</em> [Video description ends] <br /><br />So let&#39;s see if that works the way that we expect it to. I&#39;m going to go to the bottom left corner of my IDE and click on the Terminal button to open up a terminal where I can compile and run my program. I&#39;m not in the directory that I need to be. So I&#39;m going to change directory into my source folder and then I&#39;m going to compile with javac my Main.java class, and now I can run my Main.java by saying java Main, and in our console window just below the line where I&#39;ve called java Main, we have the value 9, which is what we&#39;ve expected. <br /><br />[Video description begins] <em>He enters the following command, that reads: cd src.</em> [Video description ends] <br /><br />So this is how we can create methods and use methods in Java classes.</p></div></div></div><div class="section"><a name="section_3" /><h2 class="section_title">4. Video: Java Accessor Methods (it_sdjcfa_17_enus_04)</h2><img src="https://cdn2.percipio.com/public/b/997f1523-f004-4afc-b735-f78281f84aec/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/997f1523-f004-4afc-b735-f78281f84aec/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn about Java Accessor Methods. These are methods you can use to access the instance variables, or fields, or properties of a class. Java Accessor Methods are also called getters, because you can think of them as getting something for you. Typically, the use case for Java Accessor Method is to retrieve the values of private fields.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe Java accessor methods and how they are used in Java classes</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Accessor Methods. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Java Accessor Methods are methods that we can use to access the instance variables, or fields, or properties of a class. You might also hear Java Accessor Methods called getters. That&#39;s because you can think of them as getting something for you. You&#39;re asking the method to get me this value or get me this piece of data. Most commonly, the use case for Java Accessor Method is to retrieve the values of private fields. Since the private field can&#39;t be accessed by anything other than the class that it&#39;s defined in, we have to have a way to get that value somehow if we need that value, and that&#39;s where we have the Accessor Methods come in. So an Accessor Method has to have access to the value that you&#39;re trying to access.</p>
<p>So usually, your Accessor Method will be part of the same class that the instance variable that you&#39;re trying to retrieve is in. They are declared public, and that&#39;s because they&#39;re designed to be used by other classes. So in order to have the visibility such that another class can use your Accessor Method, we make sure that they are public, and then some sort of data, or value or property of an object is returned to you, and at that point, what you do with it is up to you, and there&#39;s a specific naming scheme that&#39;s generally followed by Accessor Methods in Java, and that&#39;s you preface the method name with the word get.</p>
<p>So you have something like get value, or get num, or get string. Whatever it is, you say get and then some sort of description of what it is that you&#39;re getting, and that&#39;s why they&#39;re often called getters. They don&#39;t have to follow this. That&#39;s just a convention that you&#39;ll see most commonly in code, and to conform and keep your code more manageable, it&#39;s good to follow that naming convention. Let&#39;s see what an Accessor would actually look like in Java code. So on the screen here, we have an example of an Accessor. It&#39;s defined within an AccessorExample class. So the class declaration is on the first line where it says, class AccessorExample, and then we have an instance variable which is defined underneath of that called private varType varName.</p>
<p>Now, this instance variable is private, so it&#39;s only accessible to the AccessorExample class. But if we needed to get the value of varName, then we&#39;d have to have some way to access it from outside of the class, and that&#39;s where the Accessor Method comes in. So below our instance variable, we have the common Accessor Method, and below that, we have our actual definition of our Accessor Method. So it&#39;s public varType getVarName, and then in the body of the method, it returns varName. So let&#39;s look a little closer at what&#39;s going on here. In the declaration, our first access identifier is public, as we touched on earlier.</p>
<p>Its return type has to match the type of the variable that you&#39;re retrieving. In this case, our type is varType, so the return type of our Accessor Method is also varType, and then we have our naming convention. We have the Accessor Method starts with get, and then the name of what we&#39;re trying to retrieve so varName, which leads us to the full Accessor Method named getVarName. Our method doesn&#39;t take any parameters, so our parentheses are empty. That&#39;s because it doesn&#39;t need to. It&#39;s always going to retrieve the same variable, and then in the body of the code, it returns varName, and that&#39;s what an Accessor Method will look like in code.</p>
<p>Here we have a more concrete example of an Accessor Method. Now that we know the rough syntax, let&#39;s look at an actual implementation. On the screen, we have a code snippet, and it&#39;s defining a class called Dog. Dog has a instance variable private String breed, and then below that, it&#39;s got a constructor, public Dog, which takes parameters String getBreed, which will then set the value of breed to whatever is passed to the constructor in getBreed. So when we create the Dog class, breed will be set by the constructor, and then below that, we have our Accessor Method, and our Accessor Method is defined by the line, public String getBreed, and it returns the value of breed.</p>
<p>We can see that since breed is of type string, our Accessor Method returns string, our breed is private while our Accessor Method is public. Our Accessor Method does not take any parameters because it doesn&#39;t need to, and it returns breed in the body of its code, and here we have an example of using this Accessor Method. So we have a new class called findMyDog, and findMyDog has a main method defined in it, where it says public static void main(String[] args), and the main method is first creating an instance of our dog class on the line where it says Dog dog1&#61; new Dog, and is passing the value of Labrador Retriever to the constructor. So in dog1, the value of breed is going to be equal to Labrador Retriever, and then we want to print out that value, so our next line down is System.out.println, and we print the string Breed, followed by dog1.getBreed.</p>
<p>So dog1.getBreed is an example of using our Accessor Method, because we&#39;re calling our Accessor Method getBreed on our dog object dog1, and that returns to us the value of Breed which has been set to Labrador Retriever. So our output, as seen on the bottom of the screen where it says Output, will read Breed Labrador Retriever. Now let&#39;s take a look at a slightly different way of using an Accessor. This is a little less explicit than what we&#39;ve looked at before. So here we have an Accessor with Multiple Parameters. On the bottom of our screen, we have a Dog class, and the Dog class is a little different than our previous Dog class. It&#39;s defined with three string instance variables, private String breed; private String color; and private int age, and then below that it has a constructor, public Dog, and it takes three parameters, string getBreed, string getColor, and int getAge, and then it sets breed &#61; getBreed; color &#61; getColor; age &#61; getAge. So now when we instantiate an object of the dog class, we have to pass it three arguments corresponding to the breed, color, and the age in order for the constructor to run properly.</p>
<p>In the top of our code example, we have another Accessor example class defined with public class AccessorExample, and it has a main method within it, public static void main String args, and the first line within the main method defines a new dog object instantiating out of the dog class with Dog dog1 &#61; new Dog, and we pass it the three arguments, Labrador Retriever, gold and 7, and then we do System.out.println(dog1). Now, as of right now, we haven&#39;t really used an Accessor. If we were to run this code as it is, this would print out a weird memory address pointing to where dog1 is stored in the memory, but we can use toString() to act as our Accessor Method. So toString() is built into every class by default. But if we explicitly define it like we have here with public String toString and you would define this in your dog class, then it overrides the default behavior of toString, and it will instead perform whatever we define it to perform.</p>
<p>In this case, we&#39;re using toString like an Accessor. Because we have within our toString method return followed by the string Breed concatenated with our breed instance variable. Which is then concatenated with the string Color, which is then concatenated with our color instance variable, which is next concatenated with the string Age, which is finally concatenated with the age variable. So the actual result of this when we call our print method, which was System.out.println dog1 is that it will look for our toString method, and it will actually print out breed Labrador Retriever, color golden, age 7. So in a way, our toString method is acting as an Accessor because it&#39;s retrieving these variables for us and then printing them out to the screen.</p></div></div></div><div class="section"><a name="section_4" /><h2 class="section_title">5. Video: Programming Java Accessor Methods (it_sdjcfa_17_enus_05)</h2><img src="https://cdn2.percipio.com/public/b/929e99c0-5c56-4fa3-be98-0d958bf58cb3/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/929e99c0-5c56-4fa3-be98-0d958bf58cb3/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll learn the use of Java accessor methods. To get started, you’ll locate my src folder, right-click on it, navigate to New, and click Java Class, and then you’ll make a Java class called AccessorExample.java. Now, you have your AccessorExample class. </p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate Java accessor methods and how they are used in Java classes</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Accessor Methods. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this video, I&#39;m going to demonstrate the use of Java accessor methods. To get started, on the left side of my project window, I&#39;m going to locate my src folder, right-click on it, navigate to New, and click Java Class, and then we&#39;re going to make a Java class called AccessorExample.java, and now we have our AccessorExample class. <br /><br />[Video description begins] <em>The IntelliJ IDE window displays. The menu bar contains the following options, including: File, Edit, View, Navigate, Code, and Analyze. The Project window is present on the left. It contains a project folder, titled: it_sdjcfa_17_enus_05. This folder contains various sub folders, including: .idea, src, and it_sdjcfa_17_enus_05.iml. The right pane displays the following information: Search Everywhere Double Shift, Go to File Ctrl&#43;Shift&#43;N, Recent Files Ctrl&#43;E, and Navigation Bar Alt&#43;Home.</em> [Video description ends] <br /><br />[Video description begins] <em>The context menu appears. It contains the following options, including: New, Cut, Copy, Paste, and Local History.</em> [Video description ends]<br /><br />[Video description begins] <em>The context sub menu appears. It contains the following options, including: Java Class, File, Scratch File, Package, and HTML File.</em> [Video description ends]<br /><br />[Video description begins] <em>The pop-up box titled: New Java Class opens. It contains an input field to enter the Name.</em> [Video description ends] <br /><br />[Video description begins] <em>The right pane displays a file titled: AccessorExample.java. It contains the following lines of code. Line 1 reads: public class AccessorExample {. Line 2 reads: }.</em> [Video description ends] <br /><br />On line one, the class declaration reads public class AccessorExample with an open curly brace, and on line 3, we have the closed curly brace representing the end of the class. As within this class that I&#39;m going to create an accessor method.</p>
<p>Now, Java accessor methods are typically used to retrieve the value of an instance variable within a class. So first off, our accessor example is going to need some instance variable for us to retrieve. So let&#39;s create one now. <br /><br />[Video description begins] <em>Line 2 reads: private int retrieveThis &#61; 5;.</em> [Video description ends] <br /><br />On line 2, I&#39;ve created our instance variable, I&#39;ve called it retrieveThis. I&#39;ve given it a private access modifier so that it&#39;s only accessible within this class, and it&#39;s of type int, and its value is 5. Since this instance variable is private, that means that any other class won&#39;t be able to directly access this value.</p>
<p>But there are a lot of other times where I might want other Java classes to be able to get the value of this instance variable. So in order to facilitate that, I&#39;m going to need an accessor method. You might also hear accessor methods called getters. That&#39;s another common term for these, and our accessor method is going to be public so that it can be accessed by other classes, and now on line 4, we have the declaration of our accessor method.<br /><br />[Video description begins] <em>Line 4 reads: public int getRetrieveThis() {.</em> [Video description ends]</p>
<p>It&#39;s public, like we mentioned, its return type is int, because the instance variable that it&#39;s going to be retrieving is of type int. We&#39;ve called it getRetrieveThis. This is why people often call accessor methods getters, because they usually start with the word get. They don&#39;t have to, that&#39;s just a convention. It doesn&#39;t take any parameters, because it doesn&#39;t need to, it&#39;s only going to return the instance variable, and then we have our open curly brace, followed by a closed curly brace on line 6, and now we&#39;re ready to put into the body of this accessor method what it&#39;s going to do, and what it&#39;s going to do is return retrieveThis. Which is what we&#39;ve now put on line 5, return(retrieveThis).<br /><br />[Video description begins] <em>Line 5 reads: return (retrieveThis);.</em> [Video description ends]</p>
<p>So what this accessor method will do is give us a way to get the value of that instance variable. So let&#39;s see how we actually would use this by creating a new main method that will make use of this accessor method. Once again, I&#39;m going to navigate into the left side of my project window. Right-click on my src folder, navigate to New and click Java Class, and in this case, we&#39;re going to create a main method within a Main.java class, and here I&#39;ve created our main class. <br /><br />[Video description begins] <em>The right pane displays a file titled: Main.java. It contains the following lines of code. Line 1 reads: public class Main {. Line 2 reads: }.</em> [Video description ends] <br /><br />On line 1, the declaration reads public class Main with an open curly brace, and on line three, we have the closed curly brace indicating the end of the class, and now within this class, I&#39;m going to define a main method. Now on line 2, I have my main method declaration, public static void main(String[] args), and that&#39;s going to be where I&#39;m going to use my accessor.<br /><br />[Video description begins] <em>Line 2 reads: public static void main(String[] args) {.</em> [Video description ends] </p>
<p>Since our accessor is not static, that means I first need an object to work on in order to be able to call our accessor method. So let&#39;s create an object of type AccessorExample to work with. Now on line 3, I have my object that I&#39;m ready to work with. It&#39;s called obj, O-B-J. <br /><br />[Video description begins] <em>Line 3 reads: AccessorExample obj &#61; new AccessorExample();.</em> [Video description ends] <br /><br />It&#39;s of type AccessorExample(), and we&#39;ve created it by calling new AccessorExample. Now I have an object that can call our accessor method. What I want to do is print out the value of retrieveThis, our instance variable, which is 5. I can&#39;t call using the .syntax obj.retrieveThis directly because it&#39;s private, but that&#39;s why we have our accessor method.</p>
<p>So we can call obj.getRetrieveThis to get the value. Let&#39;s see how that looks in a print statement. <br /><br />[Video description begins] <em>Line 4 reads: System.out.println (obj.getRetrieveThis ());.</em> [Video description ends] <br /><br />On line 4, we have our print statement now with System.out.println, and in the parentheses, I&#39;ve called obj.getRetrieveThis, which should return 5. So if everything works like we expect, when we run this in the console, we should see the value 5 printed out. Let&#39;s verify that that&#39;s the case. I&#39;ll go to the bottom left of my screen in the IDE and click on the Terminal button to open up a terminal. I will change directory into my src folder. <br /><br />[Video description begins] <em>He enters the following command, that reads: cd src.</em> [Video description ends]</p>
<p>I will then compile my Java package with javac Main.java, and now I will run the Java program with java Main, and in our console output, just below where I&#39;ve called java Main, we have the value 5. So that&#39;s how we can use our accessor methods or getters to retrieve private instance variables.</p></div></div></div><div class="section"><a name="section_5" /><h2 class="section_title">6. Video: Java Mutator Methods (it_sdjcfa_17_enus_06)</h2><img src="https://cdn2.percipio.com/public/b/be1e21af-f554-4f0d-af6f-3e9aa2585fe5/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/be1e21af-f554-4f0d-af6f-3e9aa2585fe5/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll learn Java Mutator Methods, also called setters. You’ll learn these are used to change the elements of a class. Mutator Methods modify the instance variables or the fields of a class. You’ll learn that Mutator Methods demonstrate code encapsulation by having not only the data contained in a class, but also the methods used to operate on that data contained within that same class.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe Java mutator methods and how they are used in Java classes</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Mutator Methods. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Java Mutator Methods also called setters, are used to change the elements of a class. So this is basically the opposite of a Java accessor or a getter. Because we&#39;re using the Mutator Methods to modify the instance variables or the fields of a class. So we might use a Mutator Method to change the value of a private integer from 5 to 7, for example, using a Mutator Method. Going over some of the features of Mutator Methods. They demonstrate code encapsulation by having not only the data contained in a class, but also the methods used to operate on that data contained within that same class. Their access modifier is public, and the most common use case for a Mutator Method is to use the public Mutator Method to modify a private variable of some sort. They don&#39;t have a return type.</p>
<p>So in the method declaration the return type will be void, and that&#39;s because they&#39;re not returning anything. They are instead accepting a parameter that matches the type of variable being modified, and then they are assigning that value to that variable, and that&#39;s all they&#39;re doing, they don&#39;t have to return anything. Let&#39;s take a look at the Syntax of a Mutator. On the screen we have a code snippet, and it&#39;s declaring a class called MutatorExample. So on the first line, we see a class declaration, public class MutatorExample, and then below that we have a private instance variable, with some sort of type.</p>
<p>So it&#39;s saying private varType varName, and then, at the bottom of our class we have our Mutator Method, where it says public void setVar, and then in parentheses it has varType varValue and then an open curly brace followed by varName &#61; varValue, followed by a closed curly brace. Let&#39;s take a closer look at this Mutator Method declaration. So first we see the access modifier is public because we want it to be available to any other class in order to allow us to mutate or set the private instance variable. The return type is void because the method itself is not returning anything. The name is setVar, and this is why they&#39;re sometimes called setters instead of mutators. Because the naming convention is to have the word set followed by the rest of the method name.</p>
<p>So in this case, we see our method name is setVar, and then it accepts a parameter, and the parameter matches our variable type. So the parameter for our Mutator Method is varType varValue, and the varType is the same varType in our instance variable, and then in the body of the code, we&#39;re mutating varName by setting it equal to varValue, and now that we have an idea of the general syntax of the mutator, let&#39;s take a look at a more concrete code example. So in this code snippet, we have a class declaration defining a class called Dog, and that&#39;s on the first line where it says public class Dog. Inside of Dog, we have a private instance variable called breed, and it&#39;s of type String.</p>
<p>That&#39;s on the second line where it says private String breed. Then on the next line down, we have our Mutator Method. Where it&#39;s defined by the line public void setBreed, and it accepts the parameters, String newBreed. So our Mutator Method is public, the return type is void, and the name is setBreed, and that&#39;s following our naming convention of set and it&#39;s telling us what it setting, setting breed, and then in the body of the code for our Mutator Method, we set breed equal to whatever the parameter is. So in this case, breed &#61; newBreed, and then our Mutator Method will actually print out the value of breed, just for clarity&#39;s sake. So it says System.out.println(breed), and then we have our main method followed by that, where it says public static void main(String[] args), and then the call to the setter goes in that main method.</p>
<p>So this is what the main method would look like when we actually want to use the Mutator Method. So in public static void main(String[] args), we first create an object of type Dog. So we have Dog dogType &#61; new Dog, and then we can call the Mutator Method on that object by saying dogType.setBreed and we pass it an argument, Labrador Retriever, and the result of that is that the breed within the dogType object will be set to Labrador Retriever and then it will be printed out to the screen, and we can see that on the bottom of our screen where it says output and it prints Labrador Retriever.</p></div></div></div><div class="section"><a name="section_6" /><h2 class="section_title">7. Video: Programming Java Mutator Methods (it_sdjcfa_17_enus_07)</h2><img src="https://cdn2.percipio.com/public/b/bf094f7f-3771-4b48-9642-f0368f5a4d04/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/bf094f7f-3771-4b48-9642-f0368f5a4d04/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll learn more about the use of Java Mutator Methods. <br />You’ll get started by creating a Java class. On the left-hand side in IDE in the project window, you’ll click on the src folder, navigate to New, and click Java Class. Then, you’ll create a Java class called MutatorExample. Now, in your main project window on line 1, you’ll see your mutator example class, public class MutatorExample.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate Java mutator methods and how they are used in Java classes</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Mutator Methods. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this demonstration, I&#39;m going to show the use of Java mutator methods. Mutator methods are also sometimes called setters, that&#39;s another common term for them. <br /><br />[Video description begins] <em>The IntelliJ IDE window displays. The menu bar contains the following options, including: File, Edit, View, Navigate, Code, and Analyze. The Project window is present on the left. It contains a project folder, titled: it_sdjcfa_17_enus_07. This folder contains various sub folders, including: .idea, src, and it_sdjcfa_17_enus_07.iml. The right pane displays the following information: Search Everywhere Double Shift, Go to File Ctrl&#43;Shift&#43;N, Recent Files Ctrl&#43;E, and Navigation Bar Alt&#43;Home.</em> [Video description ends] <br /><br />In order to see how these work, I&#39;m going to get started by creating a Java class. So in the left-hand side of my screen in my IDE in the project window, I&#39;m going to click on the src folder, right-click on it, navigate to New, and click Java Class, and I&#39;m going to create a Java class called MutatorExample, and now in my main project window on line 1, I have the declaration for my mutator example class, public class MutatorExample.<br /><br />[Video description begins] <em>The context menu appears. It contains the following options, including: New, Cut, Copy, Paste, and Local History.</em> [Video description ends] <br /><br />[Video description begins] <em>The context sub menu appears. It contains the following options, including: Java Class, File, Scratch File, Package, and HTML File.</em> [Video description ends] <br /><br />[Video description begins] <em>The pop-up box titled: New Java Class opens. It contains an input field to enter the Name.</em> [Video description ends] <br /><br />[Video description begins] <em>The right pane displays a file titled: MutatorExample.java. It contains the following line of code. Line 1 reads: public class MutatorExample {. Line 2 reads: }.</em> [Video description ends] <br /><br />Followed by the open curly braces and the close curly braces on line 3 indicating where the body of my class will go. Mutators in Java are used to modify the value of an instance variable. Generally, we use it to modify the value of a private instance variable. So to see how this works, first we&#39;ll have to have some sort of private instance variable defined within our class. So let&#39;s go ahead and do that now, and now on line 2, I have a private instance variable. <br /><br />[Video description begins] <em>Line 2 reads: private int mutateThis &#61; 7;.</em> [Video description ends] <br /><br />It&#39;s called mutateThis. It&#39;s of type int, its access modifier is private, and its value is 7. So this is the value that we&#39;re going to mutate or set. Because this variable is private, that means we can&#39;t access it from outside of this class. But if for some reason within our code, we wanted to be able to change this value, that&#39;s why we need a mutator method.</p>
<p>So let&#39;s create that on line 4, <br /><br />[Video description begins] <em>Line 4 reads: public void setMutateThis(int n) {.</em> [Video description ends] <br /><br />and now we have our mutator method declaration or our setter method, and it&#39;s on line 4, it&#39;s public, as an access modifier, because we want to be able to access this from outside the class. Its return type is void because it&#39;s not actually returning anything. It&#39;s just going to set the value of mutateThis. Its name is called setMutateThis, which is why people often call these mutator methods setters, because they often start with set. They don&#39;t have to, that&#39;s just a convention. It takes in one parameter, an integer n, and that&#39;s the value that it&#39;s going to set mutateThis to. So we&#39;re going to be using this mutator method to override the default value of 7 in mutateThis.</p>
<p>So to do that, we&#39;re going to set the mutateThis variable equal to n within our mutator method, and that&#39;s what we&#39;ve done here on line 5. <br /><br />[Video description begins] <em>Line 5 reads: this.mutateThis &#61; n;. Line 6 reads: }.</em> [Video description ends] <br /><br />The keyword this is telling Java to look for a mutateThis variable that&#39;s defined within this class, and then we&#39;re setting that variable equal to n on line 5. I&#39;m also going to add an accessor method or a getter method to this class in order to be able to show the before and after the mutation happens with the mutator method, <br />and I&#39;ve defined that accessor method on lines 8 to 10. <br /><br />[Video description begins] <em>Line 8 reads: public int getMutateThis() {. Line 9 reads: return mutateThis;.</em> [Video description ends] <br /><br />So on 8, l have the declaration public int getMutateThis, and then on line 9, it returns the value of mutateThis.</p>
<p>So I&#39;m going to use this to first retrieve the value of mutateThis before we modify it, and then once again after we&#39;ve modified it. So in order to see how this works, let&#39;s create a second Java class with a main method in order to use these methods. So once again, I&#39;m going to navigate on the left side of my screen in the project pane window. Right-click on the src folder, navigate to New&gt;Java Class and create a new Java class called Main.java, and now we have our main class. <br /><br />[Video description begins] <em>The right pane displays a file titled: Main.java. It contains the following lines of code. Line 1 reads: public class Main {. Line 2 reads: }.</em> [Video description ends] <br /><br />On line 1 we have the declaration public class Main. Then we have the open curly brace, and on line 3 we have the close curly brace indicating the end of the class. Within this class, I&#39;m going to define my main method, and we can see the main method is now defined on line 2 with public static void main(String[] args), and within this method, we&#39;re going to make use of our mutator method.<br /><br />[Video description begins] <em>Line 2 reads: public static void main(String[] args) {.</em> [Video description ends] <br /><br />Our mutator method is not static. So we first need an object of type MutatorExample in order to work with these methods. So let&#39;s go ahead and create that object now, and on line 3, we&#39;ve created that object. <br /><br />[Video description begins] <em>Line 3 reads: MutatorExample obj &#61; new MutatorExample();.</em> [Video description ends] <br /><br />It&#39;s called obj, O-B-J. Its type is mutator example and we created it by calling new MutatorExample. This obj we can now use to make use of the mutator method. So let&#39;s do three print statements. The first print statement is going to show the value of MutateThis as it is now before we do any changes, and we have that on line four with System.out.println (obj.getMutateThis()). <br /><br />[Video description begins] <em>Line 4 reads: System.out.println (obj.getMutateThis ());.</em> [Video description ends] <br /><br />Since we haven&#39;t made any changes, we should see this value print out as 7. Now let&#39;s use our mutator method to change the value of mutateThis to 9. <br /><br />[Video description begins] <em>Line 5 reads: obj.setMutateThis(9);.</em> [Video description ends]</p>
<p>On line 5, we&#39;ve now used our mutator method. We&#39;ve set obj.setMutateThis and we&#39;ve passed it an argument with a value of 9. So now, the instance variable within the class called MutateThis should be equal to 9. So let&#39;s put a print statement right after this just to indicate to us that the value&#39;s been changed, and we put that on line 6 with system.out.println and we&#39;re printing the string, The value has been changed, and finally, let&#39;s put a third print statement in to print the current value of mutateThis, and that&#39;s now on line 7. <br /><br />[Video description begins] <em>Line 6 reads: System.out.println (&#34;The value has been changed&#34;);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 7 reads: System.out.println (obj.getMutateThis());.</em> [Video description ends]</p>
<p>Once again, we&#39;ve used the exact same getter or accessor method that we used on line 4. On line 7, it reads System.out.println (obj.getMutateThis()), but now we should see the value of 9 printed to the console. So let&#39;s compile and run the program and make sure that everything looks and runs like it should. In the bottom left screen of my IDE, I&#39;m going to click on the Terminal button. I&#39;m going to, within my terminal, change directory to the src folder, and then I&#39;m going to compile my Java package with javac Main.java, and then I&#39;m going to run my Java program by calling java Main, and now in the console output below java Main, we see three lines.<br /><br />[Video description begins] <em>He enters the command that reads: cd src.</em> [Video description ends] <br /><br />The first line has a value of 7, which is where we&#39;ve printed out the current value of mutateThis. Then we see our string, the value has been changed because that&#39;s right after we&#39;ve called the mutator method to change the value, and then we can see the value 9 printed out because the value of MutateThis has been changed with our setter or our mutator method. So that&#39;s how we can use mutator methods to modify private instance variables in Java.</p></div></div></div><div class="section"><a name="section_7" /><h2 class="section_title">8. Video: Java Method Overloading (it_sdjcfa_17_enus_08)</h2><img src="https://cdn2.percipio.com/public/b/dd744009-97b6-40d8-b312-aada78765494/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/dd744009-97b6-40d8-b312-aada78765494/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn about Method Overloading in Java. This is where you have multiple methods that have the same name but different parameters. Because the methods all have the same name, Java decides at runtime based on how the method is called at that point in the code which instance of the method to use. This is called polymorphism, and you’ll learn there are three ways to perform Overloading.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe method overloading in Java and when to use it</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Method Overloading. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Method Overloading in Java is where we have multiple methods that all have the same name but have different parameters in some way and then because the methods all have the same name, Java decides at runtime based on how the method is called at that point in the code, which instance of the method to use, and that&#39;s called polymorphism, and we have three ways to perform Overloading. The first is with a different number of parameters. So we could have a method called overloaded, and in the first definition of overloaded, it takes one parameter, and then in the second definition of overloaded, it could take two parameters, and then Java will decide when that method is called.</p>
<p>If it&#39;s called with one parameter, Java will use the instance where overloaded has one parameter, and if it&#39;s called with two parameters, Java will use the instance of overloaded where it has two parameters. We could also overload a method by giving it different types of parameters. So maybe we have an instance of overloaded where it takes an integer, and then, we have an instance of overloaded where it takes a double, and Java will decide again at runtime, if overloaded is called with an integer, it will use the instance of the overloaded method that takes integer as a parameter, and if overloaded is called with a double as a parameter, then it will use the instance of overloaded where it takes a double as a parameter, and finally, we can overload by changing the order of parameters.</p>
<p>So we could have an instance of overloaded that accepts an integer followed by a string as parameters, and then we could have a second instance of overloaded which accepts a string followed by an integer. Let&#39;s take a look at some examples of Overloading. So in this code snippet, we have three method declarations, and they all have the same name. They&#39;re all called myMethod. But critically, they each take a different type of parameter. So the first declaration static int myMethod takes a parameter of type int.</p>
<p>The second declaration static double myMethod takes a parameter of type double, and the third declaration static float myMethod takes a parameter of type float. Each method also has a different return type because what they&#39;re all doing is taking that parameter, assigning it to be equal to a variable of the same type as the parameter, and returning that variable. So the return type has to match the type of parameter in this case. But the return type isn&#39;t what&#39;s making this necessarily polymorphic. What&#39;s making this polymorphic is the fact that the parameters are different.</p>
<p>By having one instance of myMethod take myVar as an int, another one take myVar as a double, and another one take myVar as a float, we&#39;ve overloaded myMethod, and now Java will run whatever method matches the parameter type when the method is called. So if I pass an integer to myMethod, then the first instance of myMethod will be run where it says int returnVal &#61; myVar return myVar. If I pass a double to my method, then the second instance of myMethod will be run where it says double returnVal &#61; myVar and return myVar, and if I pass a float to myMethod, then the third instance of myMethod will be run, where we have a float returnVal &#61; myVar and then we return myVar.</p>
<p>In our second example of Overloading, we have a fully fleshed out class, and our class is defined on line one called public class methodOverloading, and in our class, we have an overloaded method called addMethod, and we can tell it&#39;s overloaded because we have two instances of addMethod, both with the same name. So our first line is static int addMethod, and it takes two parameters, int x and int y, and then it returns x &#43; y, and our second instance of addMethod is static double addMethod, and it takes a double x and double y as parameters and it returns x &#43; y as well, and what makes it overloaded is the fact that the first instance takes two ints as parameters and the second instance takes two doubles as parameters, and then below that, we have our main method which is showing an example of how we can use these overloaded methods.</p>
<p>So underneath public static void main(String []args), our first line is int addints &#61; addMethod, and then we pass as arguments to addMethod, 10 and 5. Since 10 and 5 are both ints, the first instance of addMethod where it expects two ints as parameters will be used, and the result will be 10 plus 5, which is 15, and 15 is an int, so we assign it to an integer type called addints, and then our code prints that to the command line with System.out.println(addints), and our second line in our main method is double addDoubles &#61; addMethod (10.0, 5.0). So in this case, we&#39;re passing two doubles to our addMethod, 10.0 and 5.0 are both doubles.</p>
<p>So the second instance of addMethod will be used in this case where it will add double x plus double y, and the result will be stored in our double called addDoubles and that will be 15.0, and then this line is followed at the end with another print statement System.out.println(addDoubles), and so we can see in the output, we have 15 and 15.0. So even though we&#39;ve called the same method addMethod, we&#39;ve gotten different results because different instances of that method have been used based on what parameters have been passed.</p>
<p>Now, let&#39;s look at an example of Overloading using different numbers of parameters. Once again, we have a class defined on line one, public class methodOverloading, and we have an overloaded method called addMethod. But this method is overloaded in a different way now, so the return type for addMethod is int in both cases. Because again, the return type is not what makes this overloaded. In our first declaration of addMethod, we have static int addMethod, and it expects two parameters, int x and int y, and it returns x &#43; y, and in our second declaration of addMethod, we have static int addMethod, but it expects three parameters, int x, int y, and int z, and it returns x &#43; y &#43; z.</p>
<p>So, the fact that addMethod in the first instance expects two parameters, and in the second instance, expects three parameters, is what makes this overloaded. So in our main method public static void main(String []args), we have two calls to addMethod. On the first line, we have int addTwo &#61; addMethod, and we pass as arguments 10 and 5. So because there&#39;s only two parameters, this will use the first instance of addMethod when it will return x &#43; y.</p>
<p>So the result will be stored as 15 into addTwo, and then we print that to the command line with System.out.println(addTwo). Then on the second line of our main method, we have int addThree, where we once again call addMethod we pass 10, 5, and 2 as parameters to our addMethod. So now we have three parameters. So the second instance of addMethod will be used where we have an x, a y, and a z, and it will return 10 plus 5 plus 2, and the result will be 17 and that will be stored in addThree, and then we print that out to the command line with System.out.println(addThree), and we can see the output at the bottom of our screen underneath the line where it says output, and the result is 15 and 17 as we expect.</p>
<p>And finally, we have an example of Overloading using a different order of parameters. So in this code snippet, we have a class called getFruit, and getfFruit has an overloaded method called fruitMethod. In both cases, declaration starts the same with public void fruitMethod. But in the first instance, it expects an int called number as the first parameter followed by a string called fruit as the second parameter.</p>
<p>But in the second instance, it expects a string called fruit as the first parameter followed by an int called number as the second parameter, and we can see based on the order of the parameters that our print lines are different. In the first case, we do System.out.println, the string there are concatenated with the parameter number which is concatenated with the parameter fruit, and in the second instance, our print is different. In that instance, we print the parameter, fruit, followed by the string cost $ concatenated with the parameter, number.</p>
<p>So if we look at our next class which is defined near the bottom of the code snippet as displayFruit with public class displayFruit, it has a main method, public static void main(String []args), and in that main method, we first create an object out of the getFruit class called fruit with getFruit fruit &#61; new getFruit, and then we call fruitMethod twice. The first time, we have fruit.fruitMethod and we pass it 12 and the string Oranges. So in this case is an int followed by a string, and the first instance of the method will be used, and that&#39;s why on the output in the top right of the code, we see the first line is, there are 12 Oranges.</p>
<p>Then in the main method, our second fruitMethod call fruit.fruitMethod, it passes Apples as a string followed by an int as 2, and that&#39;s why in the output on the second line, our print statement is different because we&#39;ve used the second instance of fruitMethod based on the order of parameters, and that&#39;s why it says Apples cost $2.</p></div></div></div><div class="section"><a name="section_8" /><h2 class="section_title">9. Video: Programming Java Method Overloading (it_sdjcfa_17_enus_09)</h2><img src="https://cdn2.percipio.com/public/b/5d221d09-7beb-42ce-b720-1fea79b9350b/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/5d221d09-7beb-42ce-b720-1fea79b9350b/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. In this demonstration, you’ll learn how to use method Overloading in Java. You’ll create a class to work in. On the left side of your IDE in the project pane window, you’ll right click on the source folder, navigate to New, and click Java Class. Then you’ll create a new Java Class called OverloadingExample.java.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate how to perform method overloading in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Method Overloading. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this demonstration, I&#39;m going to show how to use method Overloading in Java. <br /><br />[Video description begins] <em>An IntelliJ IDE window displays. The menu bar contains the following options, including: File, Edit, View, Navigate, Code, and Analyze. The Project window is present on the left. It contains a project folder, titled: it_sdjcfa_17_enus_09. This folder contains various sub folders, including: .idea, src, and it_sdjcfa_17_enus_09.iml. The right pane displays the following information: Search Everywhere Double Shift, Go to File Ctrl&#43;Shift&#43;N, Recent Files Ctrl&#43;E, Navigation Bar Alt&#43;Home, and Drop files here to open.</em> [Video description ends] <br /><br />To get started, I&#39;m going to create a class for us to work in. So on the left side of my IDE in the project pane window, I&#39;m going to right click on my source folder, navigate to New, and click Java Class. And we&#39;re going to create a new Java Class called OverloadingExample.java, and now I have a class for us to work in. <br /><br />[Video description begins] <em>A pop-up box titled: New Java Class opens. It contains an input field to enter the Name.</em> [Video description ends] <br /><br />On line 1, we can see the class declaration, public class OverloadingExample, followed by an open curly brace, and on line 3, we have the closed curly brace indicating the end of the class.</p>
<p>So our class body will go between these two curly braces. Method Overloading in Java is where we have two methods that have the same name, but they have differences in their signatures. So for example, you could have two methods with the same name but that take different number of parameters, or two methods with the same names but they take different types of parameters. Let&#39;s see this in action. I&#39;m going to create two overloaded methods in this class, and all they&#39;re going to do is perform different print statements based on how many parameters are passed to the method. <br /><br />[Video description begins] <em>Line 2 reads: public void printThis(int n) {.</em> [Video description ends] <br /><br />So now I have the skeleton signature of my first method which is defined on line two. public void printThis, it takes in a single parameter int n.</p>
<p>Now I&#39;m going to create my overloaded method by giving a method with the same name but a different number of parameters. <br /><br />[Video description begins] <em>Line 6 reads: public void printThis(int n, int y) {.</em> [Video description ends]<br /><br />And now we&#39;ve overloaded our method, because on line 6, I have another signature with the same name, print this. Both methods are void and that they don&#39;t return anything. Both are public with their access modifier. But the second method on line 6 takes two parameters as its argument, int n and int y. So let&#39;s actually add some code to these methods. <br /><br />[Video description begins] <em>Line 3 reads: System.out.println (&#34; you passed one parameter&#34;);.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 7 reads: System.out.println (&#34; You passed two parameters&#34;);.</em> [Video description ends] <br /><br />Now our methods have code and are actually doing something.</p>
<p>So the first thing I notice is the actual parameters that get passed don&#39;t really matter, I&#39;m not using them in this case. But what matters is that the number of parameters passed changes which method gets called. So if I pass one parameter, the first method from line two to four will get called, and I&#39;ll print out the line, you passed one parameter. As we can see on line three, I have that print statement. Now if I pass two parameters, then the second method from lines 6 to 8 will be called, and the print statement on line 7 will be printed, saying you passed two parameters, but both methods have the same name. So how will Java know which one to choose? Well, it does this polymorphically at runtime. Let&#39;s see it in action by creating a main method for us to work with it.</p>
<p>So I&#39;m going to create a second class by navigating to the project pane in the left side of my window, right-clicking on my source folder, navigating to New, Java Class, and I&#39;ll create a new Java class called Main.java. <br /><br />[Video description begins] <em>The New Java Class pop-up box opens.</em> [Video description ends] <br /><br />And now I have my main class as declared on line one with public class Main, and within that, I&#39;m going to define a main method.<br /><br />[Video description begins] <em>Line 1 reads: public class Main {.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 2 reads: public class void main(String[] args) {.</em> [Video description ends]<br /><br />And now I&#39;ve defined my main method on line 2 with public static void main string args. Neither of my overloaded methods in Overloading example were static. So I&#39;m going to have to create an object first in order to use those methods, and that object will have to be of type Overloading example, so let&#39;s go ahead and create that now.<br /><br />[Video description begins] <em>Line 3 reads: OverloadingExample obj &#61; new OverloadingExample();.</em> [Video description ends] <br /><br />And now I have my object, it&#39;s called obj, as defined on line 3.</p>
<p>It&#39;s a type OverLoadingExample, and we&#39;ve created it by saying new OverLoadingExample. Now let&#39;s call our overloaded method, and we&#39;ll call it twice. The first time I&#39;m going to call it with one parameter, and the second time, I&#39;m going to call it with two parameters. <br /><br />[Video description begins] <em>Line 4 reads: obj.printThis(5);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 5 reads: obj.printThis(6, 7);.</em> [Video description ends] <br /><br />So on lines four and five, I&#39;ve called the same method, obj.printThis. We can see on line 4, I&#39;ve only called it with one argument, 5. But on line five, I&#39;ve called it with two arguments six and seven. So what this will do is, when I call print this online for, it should print out to the terminal, you only passed one parameter, and when I call print this on line five, it should print out to the terminal.</p>
<p>You passed two parameters, because Java will decide based on how many parameters were passed, which method to pick. Let&#39;s make sure that this is the case. So I&#39;m going to navigate to the bottom left side of my IDE and click on the Terminal button. And then I&#39;m going to change directory into my source folder, and then I&#39;m going to compile my Java package with javac Main.java.<br /><br />[Video description begins] <em>He enters the following command: cd src.</em> [Video description ends] <br /><br />And finally, I&#39;m going to run my program with java Main. And now in our terminal output, right below where I call java Main, we have to print lines, the first one says, you passed one parameter, and the second one says, you passed two parameters. Just as we expected. So this is how method Overloading works in Java.</p></div></div></div><div class="section"><a name="section_9" /><h2 class="section_title">10. Video: Java Interfaces (it_sdjcfa_17_enus_10)</h2><img src="https://cdn2.percipio.com/public/b/08c52fa7-9ce9-42c5-a9b6-1c13e27364ff/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/08c52fa7-9ce9-42c5-a9b6-1c13e27364ff/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn about interfaces in Java. These are similar to classes in Java because they contain methods and variables. But you’ll learn there are a few key differences between an interface and a class. The first is that in an interface, all methods are abstract by default. They don&#39;t contain any code bodies themselves. They have the method signature that defines the method name, the return type, its access modifier, and parameters.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe interfaces and how they are used within Java to specify the behavior that a class must implement</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Interfaces. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Interfaces in Java are very similar to classes in Java and at first glance, they might appear to be the same thing because they contain methods and variables just like a Java class. But there are a few key differences between an interface and a class. The first is that in an interface, all of your methods are abstract by default, and they don&#39;t actually contain any code bodies themselves. They have the method signature that defines the method name, the return type, its access modifier, and parameters, but it doesn&#39;t actually have any code. You don&#39;t specify what the method is doing, and any variables defined in an interface are public, static, and final by default.</p>
<p>What&#39;s the purpose of interfaces in Java? Well, the first is that it helps us achieve abstraction in our code, and abstraction is a way of hiding the implementation from an end-user or another developer, but still providing them with the necessary functionality to do their work. It also provides us with loose coupling because interfaces give us a method to reduce the dependency of our code modules on other modules, and reduce the interdependency between classes, and it provides a method for us to implement Multiple inheritance in Java. Java only supports single inheritance. So when you extend a class, you can only do so with one class. But with interfaces, you use the keyword implements, and you can actually implement as many interfaces as you want.</p>
<p>So you provide a comma-separated list of interfaces, and that&#39;s a way of implementing Multiple inheritance in Java. What are the features of Java interfaces? Well, an interface determines what a class does but not how it does it, and that&#39;s because an interface specifies a set of methods, but it only specifies the signatures of those methods and not the code bodies. So really, when you are implementing an interface, you&#39;re making a promise to Java. You&#39;re saying, I promise that by implementing this interface, I will implement every method defined in this interface.</p>
<p>So if an interface has three different methods defined, when you implement it in your class, you have to define those methods and provide the body of code for those methods saying what they&#39;ll do, and that forces a certain structure to the code. So if you have some sort of extensible framework, and you want to make sure that any developer who is implementing your code or your framework follows a certain set of guidelines, then you would provide this interface with these methods, and then you&#39;re guaranteed that any developer implementing your interface will have those methods.</p>
<p>The way that they work and the way that those methods run will be different based on each developers use case but at the very least, they&#39;ll have those methods, and there are some rules surrounding interfaces. One is that an interface cannot implement another interface, but an interface can inherit from another interface. So you can extend another interface. Let&#39;s take a look at an example of what an interface actually looks like in code. So this code snippet demonstrates what an interface looks like in Java. On our first line, we have interface interfaceExample.</p>
<p>So the keyword, the first-word interface, that tells Java that we&#39;re defining an interface, and then interfaceExample is the name of the interface then we have a comment below that line saying, will be regarded as public abstract void myMethod1 and public abstract void myMethod2, that&#39;s just describing how Java will interpret these methods. But within our interface, we have two methods defined. Public void myMethod1 and public void Mymethod2. We can see that&#39;s all of these methods I&#39;ve written down, there&#39;s no open and closed curly braces defining where the body of the code would start and stop for a method because we don&#39;t have any code defined.</p>
<p>We just have the pure signature followed by a semicolon to indicate the end of the line, and now we&#39;re looking at a code snippet that shows how we can actually use that interface. So on the first line, we see public class impMethods implements interfaceExample. Let&#39;s look at this a little closer. We have a class declaration, public class, and our class name is impMethods. After our class name, we have the keyword implements. So this is telling Java, expect us to be implementing an interface. After the keyword implements, we give the interface name, interfaceExample. So now our impMethods class has made a promise to Java that we are going to implement whatever abstract methods have been defined in interfaceExample. So, in our impMethods class, we have defined two methods, and the method names match the method names defined in interfaceExample. We have public void myMethod1, and public void myMethod2.</p>
<p>But in our class, we have now given code into the body of the method. So, instead of Public void, myMethod1 followed simply by a semicolon as we saw in the interface, now we have a concrete method, public void myMethod1 followed by an open curly brace, and then a print statement saying System.out.println. This is myMethod1, and then a closed curly brace to signify the end of the method. Similarly, in method2, we now have an open curly brace, followed by a print statement System.out.println. This is my method2, followed by a closed curly brace.</p>
<p>So we&#39;ve taken the abstract methods to define in the interface, and we&#39;ve given them concrete implementations in our class, and then our class at the end has a main method public static void main String arg, where we would actually put our calls, and we&#39;ll see what that looks like on the next slide, and this is where we can show how we actually implement our interface in the main method. So this is a snippet or a closer look at the main method, public static void main (String arg[]) { and the first thing we do in our main method is we create a new object, and the objects type is interfaceExample, but you see we&#39;re creating the object out of the impMethods class.</p>
<p>So we have interfaceExample object &#61; new impMethods, and then we can call our methods on the object with object.myMethod1 and object.myMethod2, and those will each print out their respective print lines in turn. So we see that where at the bottom of the screen it says Output, we have this is myMethod1 and this is myMethod2. So this is how we can use interfaces in Java.</p></div></div></div><div class="section"><a name="section_10" /><h2 class="section_title">11. Video: Programming Java Interfaces (it_sdjcfa_17_enus_11)</h2><img src="https://cdn2.percipio.com/public/b/b90f427c-5e80-4825-a430-bc5c0ade8d63/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/b90f427c-5e80-4825-a430-bc5c0ade8d63/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll learn how to create and use Java interfaces. You’ll create an interface, and then you’ll learn how to use it. You’ll also learn why you’d want to use one.</p>
<p>To start, you’ll create an interface within your project. On the left side, in IDE under the Project pane, you’ll right-click on your source folder, navigate to New&gt;Java Class, and then you’ll see Class, Interface, Enum, and Annotation. </p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate interfaces and how they are used within Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Interfaces. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this demonstration, I&#39;m going to show how we can create and use Java interfaces. So first, I&#39;m going to create an interface, and then we can talk about how we would use it, and why we would want to use an interface. <br /><br />[Video description begins] <em>An IntelliJ IDE window displays. The menu bar contains the following options, including: File, Edit, View, Navigate, Code, and Analyze. The Project window is present on the left. It contains a project folder, titled: it_sdjcfa_17_enus_11. This folder contains various sub folders, including: .idea, src, and it_sdjcfa_17_enus_11.iml. The right pane displays the following information: Search Everywhere Double Shift, Go to File Ctrl&#43;Shift&#43;N, Recent Files Ctrl&#43;E, Navigation Bar Alt&#43;Home, and Drop files here to open.</em> [Video description ends] <br /><br />So to get started, we&#39;re going to create an interface within our project. So on the left side of my window in my IDE under the Project pane, I&#39;m going to right-click on my source folder, navigate to New&gt;Java Class, and then in my list of options I have Class, Interface, Enum, and Annotation. <br /><br />[Video description begins] <em>A pop-up box titled: New Java Class opens. It contains an input field to enter the Name.</em> [Video description ends]<br /><br />So I&#39;m going to select Interface, and I&#39;m going to call it Car.java, and now we have the beginnings of our interface. You might be used to seeing the declaration look like public class, and then the class name.</p>
<p>But when we&#39;re making an interface, we use the keyword interface. So on line 1, we have the declaration public interface Car, and that lets Java know we want to create interface. <br /><br />[Video description begins] <em>Line 1 reads: public interface Car {.</em> [Video description ends] <br /><br />In an interface, we&#39;re going to create a grouping of related methods, but the methods themselves won&#39;t have any code. So we&#39;re just laying out the method names, their access modifiers, and their types. But we&#39;re going to leave it to the code that actually implements the interface, which we&#39;ll talk about later to make the body of the methods. So within the car interface, we&#39;d want to think about what kind of methods would a car have?</p>
<p>Well, we might have a method to start the car, We also might have a method to turn the car off or stop the car, and then maybe we have a method to turn the car left and turn the car right, and this completes our interface. <br /><br />[Video description begins] <em>Line 2 reads: public void start();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 3 reads: public void stop();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 4 reads: public void turnLeft();.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 5 reads: public void turnRight();.</em> [Video description ends] <br /><br />So this is what an interface consists of, a grouping of methods without any code, just the method definitions. So we have our four methods start, stop, turnLeft, turnRight. We can see that none of the methods take any arguments, but they can if we want them to.</p>
<p>So why don&#39;t we give a parameter to our start method. <br /><br />[Video description begins] <em>Line 2 now reads as: public void start(String keyType);.</em> [Video description ends] <br /><br />So, now I&#39;ve added a parameter to our start method which is perfectly valid. It&#39;s accepting a string called keyType, and we could say that the keyType is a normal key. Maybe it&#39;s a push button, or a remote start of some kind. But regardless, we can pass a parameter to this method now. Now that we know how we can define an interface, let&#39;s look at how we can actually use an interface. Interfaces are implemented by classes, and you can think of this similar to inheritance, but the difference is, we can implement as many interfaces as we want.</p>
<p>So with inheritance in Java, we can only inherit from one superclass. But with implementation in Java, we can implement as many interfaces as we want. So to see how we would implement this interface, let&#39;s create a class in our Java package. So I&#39;m going to navigate over to our source folder in the left side on the Project pane. I&#39;m gonna right-click, navigate to New, and then select Java Class, and let&#39;s make something that would make use of this car interface. <br /><br />[Video description begins] <em>The New Java Class pop-up box opens.</em> [Video description ends] <br /><br />So for example, maybe something like electric vehicle would still be a type of car, we&#39;ll make ElectricVehicle.java and I&#39;m gonna leave this on the class selection because now we want to create a concrete class.</p>
<p>So here we have our public class ElectricVehicle as defined on line 1. <br /><br />[Video description begins] <em>Line 1 reads: public class ElectricVehicle {.</em> [Video description ends]<br /><br />We want electric vehicle to implement our car interface. So on the class signature on line 1, after the class name, I&#39;m going to use the keyword implements, and then I&#39;m going to give the name of the interface, Car, and now our class, ElectricVehicle, is implementing the Car interface, and on line 1, there&#39;s a red squiggly line underneath of our class signature, because we haven&#39;t now created the methods that we&#39;ve promised to create. <br /><br />[Video description begins] <em>Line 1 now reads as: public class ElectricVehicle implements Car {.</em> [Video description ends] <br /><br />By implementing the Car interface, we have promised Java, we will create every method that&#39;s contained in that interface, the start, stop, turnLeft, and turnRight methods.</p>
<p>So until I have those methods implemented with some sort of code behind them, I&#39;m going to get this error, and we can have as many interface implementations as we want, we would just separate the names with a comma. So now, let&#39;s implement the actual methods. Our first method was the start method.<br /><br />[Video description begins] <em>Line 2 reads: public void start(Start keyType) {.</em> [Video description ends] <br /><br />So I&#39;ve put on line 2 the signature for the start method, public void start(String keyType), and this matches the signature of that method in the interface. But now I need to put some code in there. So let&#39;s make our code simple.</p>
<p>It&#39;s just going to be two print statements, one print statement saying you turn the car on, and another print statement saying the keyType. <br /><br />[Video description begins] <em>Line 3 reads: System.out.println(&#34;You turned the car on.&#34;);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 4 reads: System.out.println(keyType);.</em> [Video description ends] <br /><br />Now let&#39;s implement the stop method. <br /><br />[Video description begins] <em>Line 7 reads: public void stop() {.</em> [Video description ends] <br /><br />The stop method didn&#39;t take any parameters in the interface, so we don&#39;t put any parameters into it here, and we&#39;ve matched the signature again, public void stop, and this will be a print statement saying you stopped the car or you turned the car off rather, and finally, we have our turnLeft and our turnRight methods. <br /><br />[Video description begins] <em>Line 8 reads: System.out.println(&#34;You turned the car off.&#34;);.</em> [Video description ends] <br /><br />So let&#39;s go ahead and implement those as well, and now we&#39;ve implemented every method that we promised to implement.<br /><br />[Video description begins] <em>Line 11 reads: public void turnLeft().</em> [Video description ends] <br /><br />[Video description begins] <em>Line 12 reads: System.out.println(&#34;You turned the car left.&#34;);.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 15 reads: public void turnRight().</em> [Video description ends]<br /><br />[Video description begins] <em>Line 16 reads: System.out.println(&#34;You turned the car right.&#34;);.</em> [Video description ends] <br /><br />All four methods defined in the interface are now defined in our ElectricVehicle class and they have code within them so, they&#39;re actually doing something. If we wanted the code to do something different for a different type of car, then the next time we implement car with a different class. We can change the code around in these methods as long as we still have all four methods as defined in the interface. So interfaces, we use them when we want to have some sort of structure to our code. We want to make sure that our code always has these certain methods.</p>
<p>Regardless of what the methods are doing, we want them to have the same structure, and that can provide security by hiding certain details of the code from other elements of your Java class, and it can also lead to more structured, more manageable code bases by abstracting out the method signatures. At this point, we can use these methods in ElectricVehicle, just like we would use any other method. We can create an object out of the ElectricVehicle class, and then use the dot syntax to say, .start, .stop, .turnLeft or .turnRight on that object. So that&#39;s how interfaces work in Java.</p></div></div></div><div class="section"><a name="section_11" /><h2 class="section_title">12. Video: Java Static Methods (it_sdjcfa_17_enus_12)</h2><img src="https://cdn2.percipio.com/public/b/b299e808-56e9-4446-814c-35817b12bf11/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/b299e808-56e9-4446-814c-35817b12bf11/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn about Static Methods. These are methods that belong to a class rather than an instance of the class. You’ll learn you can access a Static Method without needing to instantiate an object first. Static Methods can be used as part of a class, and static variables can also be used to define them as being part of a class.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the static keyword and how it is applied to methods in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Static Methods. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Static Methods are methods that belong to a class rather than an instance of the class. So what that means is you can access a Static Method without needing to instantiate an object first. Just having the class existing is enough to say class name.static method, and that would call the Static Method. If you wanted to create an object, you can still call Static Methods on an object, but you don&#39;t have to. So our Static Methods can be used as part of a class, and static variables can also be used to define them as being part of a class.</p>
<p>The behavior is a little bit different for static variables, that means that only one instance of the variable will ever be created. No matter how many times objects are created at that class, there&#39;s only one instance to that variable, and we also have static blocks in Java which are ways of statically initializing classes. Let&#39;s look at an example of a Static Method. In this code snippet, we have a class declaration declaring a class called static example, that&#39;s on line one where it says public class staticExample, and in that class, just below the first line, we&#39;re declaring a Static Method, where it says static void myMethod.</p>
<p>So in that declaration, our first keyword is static, and that&#39;s telling Java that this is a Static Method, and then void is the return type of our method, and then the name is myMethod, and what that method does is it has a print statement System.out.printline Hello world, and then that&#39;s it for our Static Method. Now we&#39;ve defined ourselves a Static Method. Below that, we have a main method public static void main String args, and here we&#39;re showing how we can call that method, and as stated in the comment, we don&#39;t have to create an object, we can just call myMethod directly.</p>
<p>Normally, you might be used to seeing something like object type object equals new object type, and then you would call object.myMethod. But since our method is static, we can just say myMethod, as we see here on the line below our main method declaration. In this second example of Static Methods, we&#39;re going to be making use of a static initialization block. So on this code snippet, we have a class called Static Method Example, as we see defined on line 1 where it says public class staticMethodExample, and then we have two static instance variables defined in that class. On the second line we have static int myNum and on the third line, we have static String myString. So both myNum and myString are static instance variables that our members of the staticMethodExample class.</p>
<p>So that means they&#39;ll only exist one time. Regardless of how many objects are created out of the Static Method example, they&#39;ll all be sharing the same instance of myNum and myString. So whatever the value is for myNum or myString, that value will be the same across every object. If one object changes, the value of myNum or myString, to that change will be propagated to every other object as well. Below the two declarations for myNum and myString, we have our static initialization block, and that&#39;s defined on the line four where it says static followed by an open curly brace and that&#39;s defining the start of a static initialization block.</p>
<p>We simply write static, and then put our code between curly braces. So right below our initialization block line where it says static, we have myNum &#61; 50 and myString &#61; Hello world. So what this is doing is initializing the first values of myNum and myString, and it&#39;s important to note that a static initialization block can only be used to initialize static instance variables. So because myNum and myString are both static, we can set them in our static initialization block, and this static initialization block will only run one time when the class is first loaded.</p>
<p>As opposed to what you might be used to with something like a constructor where it&#39;s run every time a class is instantiated, this is only run once, and then below that, we have our main method public static void main String args, and on the next slide, we&#39;ll look at what using this class and the static initialization block looks like. So here we have a close up of our main method. We see the declaration on the first line with public static void main String args, and then we have two lines in our main method, both of them are print statements.</p>
<p>The first one reads System.out.printline followed by the string myNum, which is concatenated with the variable myNum, and then the second print statement reads, System.out.printline followed by the string myString, concatenated with the variable myString, and since both of these variables will have been set by the static initialization block because a class has been loaded, then they&#39;ll be equal to whatever our static initialization block set them to. In this case, myNum was set to 50 and myString was set to Hello world. So at the bottom of our code snippet, we see our output below the line Output, and it prints just as we would expect, myNum 50 and myString Hello world. This is how Static Methods work in Java.</p></div></div></div><div class="section"><a name="section_12" /><h2 class="section_title">13. Video: Programming Java Static Methods (it_sdjcfa_17_enus_13)</h2><img src="https://cdn2.percipio.com/public/b/5da0c917-f736-47d3-b730-251f8e5d0d0b/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/5da0c917-f736-47d3-b730-251f8e5d0d0b/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. In this demonstration, you’re going to learn to use static methods in Java.</p>
<p>To get started, you’ll create a class to work in. On the left side of the IDE, in the project pane, you’ll right-click on src, navigate to New&gt;Java Class, and then you’ll create a new Java class called StaticExample.java. You’ll see the class declaration on line 1 with public class StaticExample. </p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the static keyword and how it is applied to methods in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Static Methods. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this demonstration, I&#39;m going to show how we can use static methods in Java. <br /><br />[Video description begins] <em>An IntelliJ IDE window displays. The menu bar contains the following options, including: File, Edit, View, Navigate, Code, and Analyze. The Project window is present on the left. It contains a project folder, titled: it_sdjcfa_17_enus_13. This folder contains various sub folders, including: .idea, src, and it_sdjcfa_17_enus_13.iml. The right pane displays the following information: Search Everywhere Double Shift, Go to File Ctrl&#43;Shift&#43;N, Recent Files Ctrl&#43;E, Navigation Bar Alt&#43;Home, and Drop files here to open.</em> [Video description ends] <br /><br />To get started, I&#39;m going to create a class for us to work in. So in the left side of my IDE, in the project pane, I&#39;m going to right-click on src, navigate to New&gt;Java Class, and I&#39;m going to create a new Java class called StaticExample.java. And here we have the class declaration on line 1 with public class StaticExample, and the open curly brace followed by a closed curly brace on line 3, which is where the body of my code will go within my class.</p>
<p>Let&#39;s start by defining a method that&#39;s not static, which is what we might be more familiar with. <br /><br />[Video description begins] <em>Line 2 reads: public int addFive(int n) {.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 3 reads: return(n &#43; 5);. Line 4 reads: }.</em>[Video description ends] <br /><br />So on lines 2 to 4 I&#39;ve added a standard non-static method. public int addFive takes a parameter int n and it returns n &#43; 5. So, to use this standard method, we would have to do the standard operation of creating an object using the static example class and then calling this method on that object. Now let&#39;s define a static method. <br /><br />[Video description begins] <em>Line 6 reads: public static int addSix(int n) {.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 7 reads: return(n &#43; 6);. Line 8 reads: }.</em> [Video description ends] <br /><br />Now on lines 6 to 8, I have a new method called addSix, but it has a special keyword in the signature called static.</p>
<p>So we have public static int addSix, taking parameter int n on line 6. Now we have a static method, because that keyword static makes this method static. In the body of the code it returns n &#43; 6. But the difference is, with a static method, we don&#39;t need to create an object to call this method. We can actually call it directly on the class. So we could do something like static example.addSix. Let&#39;s see how this works using a main method. I&#39;m going to create a new class by navigating over to the src folder in my project pane on the left side, right-clicking, navigating to New, and going to Java Class.</p>
<p>And I&#39;m going to create a class called Main.java. <br /><br />[Video description begins] <em>A pop-up box titled: New Java Class opens. It contains an input field to enter the Name.</em> [Video description ends] <br /><br />Now I have my main class with a class declaration on line 1 with public class main, and within that, I&#39;m going to create the main method, <br /><br />[Video description begins] <em>Line 1 reads: public class Main {. Line 3 reads: }.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 2 reads: public static void main(String[] args) {.</em> [Video description ends] <br /><br />and now we have our main method on line 2, public static void main (String[] args). You might notice something interesting about our main method. It&#39;s actually a static method in itself. So let&#39;s start by calling the non-static method, this is what we might be more used to.</p>
<p>So I need to create an object first of type StaticExample to do that.<br /><br />[Video description begins] <em>Line 3 reads: StaticExample obj1 &#61; new StaticExample();.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 4 reads: System.out.println(obj1.addFive(5));.</em> [Video description ends] <br /><br />Now on line 3, I&#39;ve created an object, obj1 of type static example, and then on line 4, I&#39;ve made a print statement that will call addFive on the obj1 object. Passing an argument of 5 to that method. So theoretically, this will add 5 to that value, and then we&#39;ll print that out. So this should print out a value of 10. This is the standard way of doing it. Now, let&#39;s look at how we can call our static method. <br /><br />[Video description begins] <em>Line 5 reads: System.out.println(StaticExample.addSix(6));.</em> [Video description ends] <br /><br />Now on line 5 within my print statement, I&#39;ve called our static method, and you can see the difference between how we call a non-static method and how we call a static method.</p>
<p>I&#39;ve called the static method by simply typing in the class StaticExample.addSix, as opposed to how I had to do it previously on line 4, where I had to create an object and then call it on the object. So if a method is not static, I can&#39;t call it the way that I&#39;m calling it on line 5, but interestingly enough, I can call a static method the same way that I call a non-static method.<br /><br />[Video description begins] <em>Line 6 reads: System.out.println(obj1.addSix(6));.</em> [Video description ends] <br /><br />Now on line 6, I&#39;ve added another print statement, which actually calls our static method on obj1 instead of the class directly, and I&#39;ve passed an argument of 6 to it. So both line 5 and 6 show valid uses of a static method. So when we print this out, we should see three lines. We should see 10, 12 and 12.</p>
<p>Let&#39;s actually compile and run this program to make sure it looks like we expect it to. So in the bottom left of my IDE, I&#39;m going to click on the Terminal button to bring up a terminal. I&#39;m going to change directory into my src folder. <br /><br />[Video description begins] <em>He enters the following command: cd src.</em>[Video description ends] <br /><br />I&#39;m going to compile and run this program, first I will compile it by doing javac Main.java, and now, I will run the program with java Main, and below java Main, we have three printed lines, just as we expected, 10, 12, and 12. So that&#39;s how we can use static methods in Java.</p></div></div></div><div class="section"><a name="section_13" /><h2 class="section_title">14. Video: Course Summary (it_sdjcfa_17_enus_14)</h2><img src="https://cdn2.percipio.com/public/b/cfc36bb7-eee0-4084-9cc5-83cad0fa5afb/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/cfc36bb7-eee0-4084-9cc5-83cad0fa5afb/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll review what you’ve learned in this course. You’ve learned how to create and use methods to manipulate the data inside a class. You also learned to program with Java methods. You learned programming with Java accessor and mutator methods, working with method overloading in Java, programming with Java interfaces, and using static keyword methods.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">summarize the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Summary</em> [Video description ends]
<p>So in this course, we&#39;ve examined how to create and use methods to manipulate the data inside a class. We did this by exploring programming with Java methods. Programming with Java accessor and mutator methods. Working with method overloading in Java, and programming with Java interfaces and using static keyword methods.</p></div></div></div><div class="copyright-container"><span class="copyright-text">© 2022 Skillsoft Ireland Limited - All rights reserved.</span></div></div><div id="lb-overlay"><div class="lb-header"><button onclick="(()=>{const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'hidden';const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 1.0;curtain.style.backgroundColor = 'white';curtain.style.pointerEvents = 'auto';})();">X</button></div><div id="lb-image-container"><img id="lb-image" alt onload="(()=>{const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 0.5;curtain.style.backgroundColor = 'grey';curtain.style.pointerEvents = 'none';const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'visible';window.scrollTo(0, 0);})();"/></div><div class="lb-footer" /></div></div></body></html>