<!doctype html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-style-type" content="text/css2"><title>Course Transcript</title><link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css"><style>:root {
    --title-text: #243038;
    --toc-link: #0073C4;
    --section-title-text: #243038;
    --section-title-border: #bababa;
    --grid-caption-text: #164794;
    --grid-border: #c0c0c0;
    --grid-hdr-text: #973131;
    --grid-hdr-background: #f7f7f7;
    --missing-data: #767676;
    --text-color: #343434;
    --lightbox-border: #a0a0a0;

    --bold-font-weight: 700;

    font-family: Lato;
}

.report {
    margin: 24px;
}

.container {
    position: relative;
}

#lb-curtain {
    background-color: white;
    opacity: 1.0;
}

#lb-overlay {
    position: absolute;
    top: 40px;
    left: 20px;
    right: 20px;
    background-color: white;
    border: solid 1px var(--lightbox-border);
    visibility: hidden;
}

.lb-header, .lb-footer {
    height: 40px;
    line-height: 40px;
}

.lb-header {
    display: flex;
    justify-content: flex-end;
    padding-right: 20px;
}

#lb-image-container {
    margin: 0 40px;
}

#lb-image {
    width: 100%;
}

.report_title {
    font-size: 22px;
    font-weight: var(--bold-font-weight);
    color: var(--title-text);
}

.toc_link {
    font-size: 14px;
    color: var(--toc-link);
    margin-top: 6px;
    margin-bottom: 0;
}

.section {
    margin-top: 40px;
    margin-left: 16px;
}

.section.inner {
    margin-top: 20px;
}

.section.inline {
    margin-top: 20px;
    margin-left: 0;
}

.section_title {
    font-size: 18px;
    font-weight: var(--bold-font-weight);
    width: 100%;
    color: var(--section-title-text);
}

h2.section_title {
    border-bottom-color: var(--section-title-border);
    border-bottom-style: solid;
    border-bottom-width: thin;
}

h3.section_title {
    margin: 8px 0;
}

h3.list_title {
    margin: 8px 0;
    font-size: 14px;
    color: var(--title-text);
}

.section_text {
    font-size: 14px;
    color: var(--text-color);
    margin: 12px 0;
    width: 90%;
}

.section_link {
    font-size: 14px;
    margin: 12px 0;
    width: 90%;
}

.grid {
    border-collapse: collapse;
}
.grid_caption {
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    color: var(--grid-caption-text);
    margin: 12px 0;
    text-align: left;
    white-space: nowrap;
}
.grid_hdr_row {

}
.grid_col {
    font-size: 13px;
    color: var(--text-color);
    border-collapse: collapse;
    padding: 2px;
    text-align: left;
    vertical-align: top;
}
.grid_col_hdr, .grid_row_hdr {
    font-size: 12px;
    font-weight: var(--bold-font-weight);
    white-space: nowrap;
}
.grid_row_hdr {

}

.empty_grid {
    border-collapse: collapse;
    border-color: var(--grid-border);
    border-style: solid;
    border-width: 2px;
    padding: 4px;
    text-align: center;
}

.htmlbox {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    padding: 8px;
}

.list {
    font-size: 14px;
    font-style: italic;
}

.missing_data {
    color: var(--missing-data);
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    font-style: italic;
}

.copyright-container {
    margin-top: 24px;
    text-align: center;
}
.copyright-text {
    color: var(--text-color);
    font-size: 12px;
}

/* Transcript Questions CSS */

.question {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    display: flex;
    flex-direction: column;
    padding: 8px;
}

.question_content {
    display: flex;
    justify-content: space-between;
}

.question_details {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.question_images {
    display: flex;
    flex-direction: column;
    margin-left: 16px;
}

.question_image {
    margin-bottom: 8px;
}

.question_title {
    font-weight: var(--bold-font-weight);
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
    padding-bottom: 8px;
    margin-bottom: 8px;
}

.question_label, .question_stem {
    font-weight: var(--bold-font-weight);
    margin-top: 8px;
    margin-bottom: 8px;
}

.question_data_row {
    display: flex;
}

.question_data_col1 {
    padding: 8px;
    white-space: nowrap;
}

.question_data_col2 {
    padding: 8px;
    display: flex;
    flex-direction: column;
}

.question_answer_key {
    margin-top: 8px;
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
}

.feedback {
    font-style: italic;
}
</style></head><body class="report"><div class="container"><div class="content" id="lb-curtain"><h1 class="report_title">Java Certified Foundations Associate: Data Types</h1><div class="section_text">Java provides different data types that can be used to store and work with different types of data. In this course, you&#39;ll learn about these data types and how to perform actions on them.

First, you&#39;ll learn about the various Java data types and their properties. Next, you&#39;ll examine how to declare and initialize variables in Java and purpose of the final keyword. You&#39;ll then move on to explore data type casting and the concepts of widening and narrowing casting. Finally, you&#39;ll learn about the Java String data type and how it relates to the Java StringBuilder class.

This course is one of a collection of courses that prepares learners for Oracle&#39;s 1Z0-811: Java Certified Foundations Associate certification.
</div><div class="section"><h2 class="section_title">Table of Contents</h2><div class="toc"><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_0">1. Video: Course Overview ( it_sdjcfa_16_enus_01)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_1">2. Video: Java Data Types ( it_sdjcfa_16_enus_02)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_2">3. Video: Programming Java Data Types ( it_sdjcfa_16_enus_03)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_3">4. Video: Java Variables ( it_sdjcfa_16_enus_04)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_4">5. Video: Programming Java Variables ( it_sdjcfa_16_enus_05)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_5">6. Video: Java Type Casting ( it_sdjcfa_16_enus_06)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_6">7. Video: Programming Java Type Casting ( it_sdjcfa_16_enus_07)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_7">8. Video: Java Type Conversion ( it_sdjcfa_16_enus_08)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_8">9. Video: Programming Java Type Conversion ( it_sdjcfa_16_enus_09)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_9">10. Video: Java Strings ( it_sdjcfa_16_enus_10)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_10">11. Video: Programming Java Strings ( it_sdjcfa_16_enus_11)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_11">12. Video: Java StringBuilder Class ( it_sdjcfa_16_enus_12)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_12">13. Video: Programming the Java StringBuilder Class ( it_sdjcfa_16_enus_13)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_13">14. Video: Course Summary ( it_sdjcfa_16_enus_14)</a></p></div></div><div class="section"><a name="section_0" /><h2 class="section_title">1. Video: Course Overview ( it_sdjcfa_16_enus_01)</h2><img src="https://cdn2.percipio.com/public/b/0cb49d48-7fbc-489d-a19b-d99cd4afa434/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/0cb49d48-7fbc-489d-a19b-d99cd4afa434/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about your instructor and the course. In this course, you&#39;ll learn about data types and how to perform actions on them. You’ll learn the concepts of Java data types and their properties. You’ll also learn to declare and initialize variables in Java and cover the purpose of the final keyword. You’ll learn datatype casting and the concepts of widening and narrowing casting types.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">discover the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Overview.</em> [Video description ends]<br /><br />Hi, I&#39;m Sven Batalla. I&#39;m a Software Management Professional with 20&#43; years of experience in managing multi-million dollar projects for Fortune 500 clients.  My entire career is centered around Team Communication and Efficiency. [Video description begins] <em>Your host for this session is Sven Batalla. He is a Software Management Professional.</em> [Video description ends] <br /><br />With agile certifications and Agile Methodologies. I&#39;ve proven adept at all aspects of the Software Development Lifecycle including design, architecture, and managing people, budgets, schedules, quality, and other deliverables.
<p>In this course, you&#39;ll learn about those data types and how to perform actions on them. First, I&#39;ll cover the concepts of Java data types and their properties and next I&#39;ll declare and initialize variables in Java and cover the purpose of the final keyword.</p>
<p>Next, I&#39;ll jump into datatype casting and the concepts of widening and narrowing casting types. And finally, I&#39;ll discuss the Java String class and how it relates to the Java StringBuilder class.</p></div></div></div><div class="section"><a name="section_1" /><h2 class="section_title">2. Video: Java Data Types ( it_sdjcfa_16_enus_02)</h2><img src="https://cdn2.percipio.com/public/b/87695925-3cfd-40b7-87fd-962d4baaf886/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/87695925-3cfd-40b7-87fd-962d4baaf886/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about Java. In Java, collecting, manipulating, and working with information means using variables. You’ll learn that you need to use the proper data type. These data types can be classified into two groups, primitive and non-primitive. Primitive data types specify the size and type of information that can be stored in the variable. Non-primitive data types are referred to as reference objects.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the different Java data types and their properties</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Data Types. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>In Java, collecting, manipulating, and working with information means using variables. No problem. But what&#39;s important to understand is that depending on the kind of data you&#39;re working with, you need to use the proper data type. Now data types can be classified into two groups. The first classification of a data type is what&#39;s called a primitive.</p>
<p>A primitive data type strictly specifies the size and type of information that can be stored in the variable. It also has no methods that can be called against a variable. The second category of data types is the opposite of primitives: non-primitives. A non-primitive data type is usually referred to as a reference object because it references an object. Shocker, right? Well, with non-primitives, you have much more control over what information can be stored in the variable.</p>
<p>And there&#39;s almost always methods that you can call against a variable too. So let&#39;s dig into these, shall we? First, let&#39;s talk about primitive data types. I already mentioned that there&#39;s strict specifications of type and size of information. So what kinds of primitives are there and what are their sizes? Well, first we have the boolean. Now, this is the most basic data type that you can have. It&#39;s true or it&#39;s false. One or zero.</p>
<p>That&#39;s it. Then there&#39;s the byte. A byte is a whole number, but it can only be between -128 to 127. And then comes the integer. This is also a whole number, but its range is 32 bits. And that means that it can be anywhere between about -2 billion, to 2 billion. Then there&#39;s something between an int and a byte and it&#39;s called a short.</p>
<p>Now short can hold whole numbers between about -32.000 to 32.000. And actually there&#39;s one more type of whole number primitive data type and that&#39;s a long. A long can store value between -9 quintillion and &#43;9 quintillion. But primitives don&#39;t have to be based on just whole numbers. There&#39;s also data types like the float and floats can store values of up to seven decimal digits.</p>
<p>Meanwhile, doubles can also store decimal values, but up to 15 decimal digits. And the final primitive type is the char. Chars can store any single character, letter or ASCII value. Now, when you create a primitive variable in Java, it always defaults to something, it can&#39;t be nothing. In Java nothing is also referred to as null. And since primitive data types can&#39;t be null, they need to have a default value. And there&#39;s a real easy shortcut for remembering what the default value of a primitive data type is.</p>
<p>It&#39;s always 0. Of course, a boolean value can&#39;t be 0. It has to be true or false. But in Java, 0 is false and 1 is true. And we&#39;ll talk about that later in the course. But suffice it to say that if 0 is false, then the default for a boolean value is false. Then for all the numbers, the default value is 02. So if you create an empty variable of type byte, int, short, long, float or double, the default value will be 0.</p>
<p>As for the char data type, the default character is the \u0000. Now that&#39;s not the letter zero, but rather the zero character. In a way, it&#39;s a null character, but it&#39;s not actually null. How can I put this? Effectively, the default value for char data type is the character that means null, but it isn&#39;t actually null. Weird, right? But there it is. It&#39;s the zero character that represents null without actually being null.</p>
<p>OK, so we know what primitive data types are. So what about non-primitive data types? Well, as I said earlier, non-primitive data types are objects that can be used as references. Generally, they have methods that you can call against them, too. And you can&#39;t do that with primitive data types. Non-primitive data types are extremely common in Java. For example, probably the most common type of non-primitive is the string.</p>
<p>You can create an instance of a string and you can even call some methods against that string to do some additional actions. And we&#39;ll talk about that later in this course. Another common type of non-primitive is an array. An array is a list of things that share the same data type so you can have an array or a list of integers, bytes, booleans and so on, and you can even have an array of non-primitives. Heck, you can even have an array of arrays. Now, the next most common type of non-primitive is a class.</p>
<p>Class is an object. It has properties and methods. So imagine you wanted to define a car. You would create a class called car and then provide properties like make, model and year, number of wheels and mileage and so on. You could even create methods like start and stop. And then there&#39;s interfaces. Interfaces are interesting because they aren&#39;t actually a thing. They&#39;re a definition of a thing. That&#39;s getting a little bit advanced, but it&#39;s worth understanding that it&#39;s another type of key, non-primitive.</p>
<p>So what are the differences between primitives and non-primitives? How can you tell the difference or even decide which one to use in which situation? Well, first, let&#39;s look at a primitive. As I said earlier, primitives always have to have a value. They can&#39;t be null. They&#39;re also predefined by Java, so you can&#39;t create your own primitive. In fact, they&#39;re reserved keywords in the programming language. The size is also defined by the data type.</p>
<p>So an int can only have a value between about negative two billion and positive two billion. Now, the keyword that you would use to use a primitive always starts with a lowercase letter. And finally, primitives don&#39;t have any methods. OK, so now let&#39;s contrast that with non-primitive data types. Well, non-primitive data types can absolutely be null. In fact, that&#39;s their default value. And non-primitives are also created by programmers. And that&#39;s particularly true for classes and interfaces.</p>
<p>Now, it&#39;s a bit tricky to wrap your head around, but non-primitives all have the same size for want of a better word. So while a primitive size can vary depending on which one you use in Java, all non-primitives are the same size. Now, the other hint is that non-primitives always start with an uppercase letter. And the last difference between primitives and non primitives is that you can call methods against non-primitives.</p></div></div></div><div class="section"><a name="section_2" /><h2 class="section_title">3. Video: Programming Java Data Types ( it_sdjcfa_16_enus_03)</h2><img src="https://cdn2.percipio.com/public/b/d30e9b0f-5355-4efa-85b0-f4d6d2711594/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/d30e9b0f-5355-4efa-85b0-f4d6d2711594/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll follow a demo. This demo will give you a look at the different data types in Java. Here, you’ll follow instructions to create a Java project, set up a static class to run some code, and then we&#39;ll run through some primitive data types, as well as some non-primitive data types, and how Java renders them. To get started, you’ll follow onscreen instructions to create a Java IDE.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the use of the different Java data types and their properties</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Data Types. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>In this demo, we&#39;re going to look at the different data types in Java. To do that, we&#39;re going to create a Java project, set up a static class to run some code, and then we&#39;ll run through some primitive data types, as well as some non-primitive data types, and how Java renders them. All right. So the first thing we want to do is create a Java project. Now, to do that, we need a Java IDE.</p>
<p>For my purposes, I&#39;m going to use the open source Eclipse IDE, so I&#39;m going to go ahead and open Eclipse now. Great. Now, let&#39;s go ahead and create a Java project. In Eclipse, that&#39;s as simple as opening the &#34;File&#34; menu and clicking on &#34;New&#34;, &#34;Java Project&#34;. Now, when you create a project, you need to give it a Name. [Video description begins] <em>A window appears that reads: Create a Java Project. It features a field to specify Project name, and details about JRE, Project layout and Working sets. Below is the Back, Next, Finish, and Cancel buttons.</em> [Video description ends] So for the sake of this demo, I&#39;m going to call my project demo16. Now, all the data types that we&#39;re going to explore in this demo are fundamental aspects of Java, and so they&#39;ve been around from the very beginning.</p>
<p>Now all that means, is that there&#39;s nothing really special beyond setting the name of the project that we have to do to get this going. So let&#39;s just leave all the defaults as they are and click &#34;Finish&#34;. [Video description begins] <em>A second window appears with the required field to enter a Module name, and the Create button below.</em> [Video description ends] Good. Now Eclipse is asking us for a Module name. Now, this isn&#39;t super important for what we&#39;re trying to do in this course, so let&#39;s just leave this as the default too and click &#34;Create&#34;. Perfect. Now, our project is created and we&#39;re just about ready to get started with data types. [Video description begins] <em>Line 1 of the new Java module reads: module demo 16 {. Line 2: }.</em> [Video description ends]</p>
<p>But before we can actually explore code, well, we need a file that we can actually code in. So let&#39;s go ahead and do that. First, let&#39;s close the module tab that opened up on our screen. All right. In order to be able to play with any sort of code, you first need to have an entry point into the project. So let&#39;s do that by creating a class to play with data types. From the &#34;File&#34; menu, let&#39;s select &#34;New&#34;, &#34;Class&#34;. [Video description begins] <em>A window appears that reads: Java Class. Create a new Java class.</em> [Video description ends] Perfect. Now in the pop-up we&#39;re being asked for information about our class.</p>
<p>Now, the Source folder and Package are pointed to the root of our project by default, and that&#39;s fine for our purposes. [Video description begins] <em>The Source folder field reads demo16/sec and the Package fields reads demo16. Below is an empty Name field and options to specify Modifiers, add Interfaces, and create method stubs.</em> [Video description ends] Let&#39;s give our class a Name. In this case, let&#39;s call it DataTypes with a capital D and a capital T and we&#39;ll leave all the Modifiers, the Superclasses and the Interfaces as the defaults, but let&#39;s make sure that we check the public static void main method, stub checkbox and let&#39;s leave all the other ones unchecked.</p>
<p>Good. Now let&#39;s click &#34;Finish&#34;. Excellent. We have our class and we&#39;re finally ready to get started. [Video description begins] <em>A new Java tab class is created titled DataTypes.java. Line 1 reads: package demo16;. Line 3 reads: public class DataTypes{. Line 5 reads: public static void main(String[] args) {. Line 6 reads: // TODO Auto-generated method stub.</em> [Video description ends] Now in Java, there are two categories of data types. The first type is primitive and the second type is non-primitive. Java actually renders these differently. So you know what you&#39;re dealing with. So let&#39;s see that in action. Now, inside the main method, let&#39;s remove the comment and replace it with char. [Video description begins] <em>The host deletes the content of line 6 and types: char.</em> [Video description ends]</p>
<p>Perfect. Now, notice the word char is bolded, in fact, it&#39;s bolded just the same as the other words, and Package, public, class, static, and void are all bolded words, too. And that&#39;s because these are all reserved keywords in Java. Reserved keywords are language-specific, key commands, objects or operators. Primitive data types are considered reserved keywords in Java. And so that&#39;s why we see the word char bolded like this.</p>
<p>Now let&#39;s do one more thing with our char keyword. Right at the end of the word, let&#39;s add a period. Now, what a period does is tell Java that we want to access something about that object. This includes properties or methods. In most IDEs, like Eclipse, you can type the period or dot, as it&#39;s often called, and it will automatically pop up a dropdown of the available properties and methods. So if you type the dot at the end of the char keyword, we&#39;ll see what properties or methods are available.</p>
<p>And look at that. There&#39;s nothing. The pop-up is empty. Well, except for the actual title, of course. Now, this isn&#39;t a surprise, though. One aspect of primitive data types is that it doesn&#39;t have any properties or methods. So let&#39;s type out some other primitive data types. On the next line, let&#39;s type boolean. Good. Now notice that it&#39;s also bolded just like the char. And if we type the dot, we once again see that there&#39;s nothing in the pop-up.</p>
<p>So what are the other primitive data types? Do they all render the same way? Well, let&#39;s find out. On the next line, let&#39;s type byte. Great. It&#39;s bold, too. And now let&#39;s go to the next line and type short. Bold again. And now let&#39;s add each of the following: int, long, float, and finally double. Cool. Those are all of the primitive data types from Java and they&#39;re all bolded because they&#39;re all keywords.</p>
<p>Nice job. But what about non-primitive data types? Well, let&#39;s try a couple of those and see what we get. Let&#39;s drop a couple of lines down and type the following code: String with a capital S. Nice. Now notice a couple of things right away. First, the word String is not bolded. So even though it&#39;s a fundamental aspect of development in Java, it hasn&#39;t been elevated to the role of keyword. The other thing that we can see is that the S in the String is capitalized, whereas all the primitive keywords are all lowercase.</p>
<p>Now let&#39;s do the dot thing again, but this time with the String word. So right at the end of the word, let&#39;s type the dot. Wow. Now notice that this time there&#39;s lots of functions that popped up here. In here you can see that we can call copy method, at join method, and lots more. And that&#39;s one of the biggest differences between primitives and non-primitives.</p>
<p>With non-primitives you can actually generally access lots of methods and properties on the object. Of course, what you&#39;re looking at here is what&#39;s called static methods and properties, and we&#39;ll get to more about that later in this course. So what are some other common non-primitives? Well, one type is a class.</p>
<p>Technically, the String is a class, but there are others like it. For example, let&#39;s drop down a line and type StringBuilder, with a capital S and a capital B. Nice. StringBuilder is another way to manage Strings. In fact, we&#39;ll talk about that later in the course, too. Regardless, you can see that a class is rendered the same way as a String.</p>
<p>And finally, let&#39;s talk about one more non-primitive data type. It&#39;s a bit of a special one. It&#39;s the array. There are a few different ways to create an array, but let&#39;s focus on the most common one. On the next line, let&#39;s type String[] that&#39;s it. An array is shown as whatever data type we want, but with the square brackets. So what if we wanted to create an array of primitives?</p>
<p>Well, let&#39;s try it. Let&#39;s go down another line and type int[]. Great. Now notice that this time the code is bolded again. But wait, we said that non-primitives aren&#39;t reserved keywords. So what gives? Well that&#39;s why I say that arrays are a bit of a special snowflake. In this case, we&#39;ve created an array of integers. Put another way, we&#39;ve created a list of primitives, so we can tell that this is an array because of the square brackets, and we know that arrays are non-primitives.</p>
<p>So this is just something that you need to get used to when you&#39;re programming in Java. Anyways, that&#39;s data types in Java. You can see the difference between primitives and non-primitives. Great job.</p></div></div></div><div class="section"><a name="section_3" /><h2 class="section_title">4. Video: Java Variables ( it_sdjcfa_16_enus_04)</h2><img src="https://cdn2.percipio.com/public/b/98bd7faf-b3b9-431d-97d0-9b91cde8edaa/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/98bd7faf-b3b9-431d-97d0-9b91cde8edaa/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn how to use Java data types. You’ll learn to define variables. A variable is defined by its data type and its value. A variable is the most basic storage unit used by Java. First, you’ll define the variable and Java will allocate a portion of memory to house the value assigned to that variable. You’ll learn that how much memory is allocated is based on the data type.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe how to declare and initialize variables in Java and the purpose of the final keyword</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Variables. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>To make use of Java data types, you need to define a variable. A variable is defined by its data type and its value. In reality, a variable is the most basic storage unit in a memory location used by Java. You define a variable and Java will allocate a portion of memory to house the value assigned to that variable. Now, how much memory is allocated isn&#39;t based on the value, but rather on the data type.</p>
<p>So earlier in the course when I said that non-primitives were all the same size, this is what I was referring to. Now another characteristic of a variable is that its value can be changed during execution. So if you started off by saying an integer value was zero, you could absolutely be allowed to change its value to something else. But before you can change a variable&#39;s value or manipulate it in any way, you naturally have to declare it first.</p>
<p>So to use a variable in Java, you must declare it. The good news is that the syntax to declare a variable is always the same. It doesn&#39;t matter what data type you&#39;re using, primitive or non-primitive, and it doesn&#39;t matter what actual type you&#39;re using; boolean, byte, int, double, char, string, class or interface. The syntax is always the same.</p>
<p>It boils down to four important details. First, you declare the data type. In this example, we&#39;re using an int, and that means that the variable we&#39;re going to create is an integer type. Then you type a space and next you give your variable a name, any name you want. Well, I mean, there are some rules about what you can and can&#39;t name your variable and we&#39;ll get to that in a second.</p>
<p>But for the most part, it&#39;s pretty OK. And lastly, you type a semicolon. But there is one more thing that you can do when you&#39;re defining a variable. You can actually define its initial value. Now, remember earlier in the course that I said all data types have a default value. Well, in the previous little code snippet, we created an integer variable called myInt.</p>
<p>Now, the rules in Java say that doing that means that the initial value of myInt is going to be zero. But what if I want to start as a different value? Well, when you declare a variable, you can do that. Take a look at this example. All we did here was take our original variable declaration of int myInt and add &#61; 10 after the variable name and before the semicolon. So the whole thing reads quite nicely.</p>
<p>It&#39;s saying that we&#39;ve created an integer variable called myInt and set its initial value to 10. So as I said a bit earlier, you can name your variables just about anything you want, but there are some rules and conventions in Java about what you can and can&#39;t do when it comes to naming. For example, the first character of your variable must be a letter, a dollar sign, or an underscore. But even though you can do it, Java recommends never using the dollar sign.</p>
<p>So just keep it to letters or underscores. Now you can use numbers in your variable name too, but Java doesn&#39;t allow numbers to be the first character. And it&#39;s also important to note that variable names are case-sensitive so you can actually create two variables with the same name as long as they aren&#39;t the same from a case usage perspective. Now, variables are all one word and alphanumeric, so that means spaces and special characters can&#39;t be used in their names. And finally, you can&#39;t name a variable the same as a reserved keyword.</p>
<p>So if you wanted to name your variable int, you wouldn&#39;t be allowed to. Now, to paraphrase Dr. Ian Malcolm, yeah, but you developers were so preoccupied with whether or not you could do a thing, you didn&#39;t stop to think if you should. Put another way, while it&#39;s true that you can name some variables just about anything you want, it doesn&#39;t mean you should.</p>
<p>In Java there is a certain set of best practices that you should follow for naming your variables. And these aren&#39;t hard rules, meaning Java won&#39;t fail to compile your project, but you should still follow the guidance. First, try to always begin your variable names with a letter. Now, that might seem obvious since we&#39;re so limited on how we can begin a variable name. The main point is to avoid using the dollar sign and underscore.</p>
<p>It&#39;s also very important from a perspective of clean code that your variable names are composed of full words and meaningful names. Calling your variables foo, bar or baz doesn&#39;t help the next developer to understand what that variable is for. But calling a variable numberofpeople is very obvious. It&#39;s also very important to avoid creating variable names that are only a single character. Just like foo, bar and baz are terrible and non-descriptive names, so are variable names like A, B or C.</p>
<p>The reason I bring this specific example up is because there is a situation where there is an exception. The only exception to the single-character-name rule is for situations where the variable is truly a well-understood transient throwaway variable like the i variable used in iterators. Another best practice for variable naming is to use lower camelCase. Now that means that every single word in the variable name should have its first letter uppercase, but the very first word in the variable name should be all lowercase.</p>
<p>And finally, while variable names can be any length, be prudent. You don&#39;t want to write a novel to describe the variable. It&#39;s OK to be long. Just be concise. Now, in the earlier syntax example, I showed you how to create an integer variable, but of course, there&#39;s all kinds of other primitive types, too. So let&#39;s take a look at how we would create variables of different data types. First, we have a boolean. Now, this is pretty simple.</p>
<p>For booleans, we use the keyword boolean and then we give any name we want and then use the keyword trueOrFalse, all lowercase to initialize the value. Then we have the byte. For bytes we can use the byte keyword and then create it just like we did with the integer earlier on. Now take a look at the short variable. Notice that we&#39;ve set the value to about negative 32.000.</p>
<p>Now it&#39;s important to see that we can set the value to any value we want, positive or negative, as long as it&#39;s within the range that the data type supports. Then we see the long variable. Now notice at the end of the value that there&#39;s a capital L. That&#39;s not technically required here because we&#39;re declaring the value, but without the L, Java would technically be widening an integer into a long. And we&#39;ll talk more about narrowing and widening later in the course.</p>
<p>And you&#39;ll notice the same kind of syntax being used for the float and double. And finally, there&#39;s the char variable. Now, notice that the value is in single quotes. Characters are always represented in single quotes. OK, so that&#39;s how we create primitive data types, but what about non-primitive data types? Take these code snippets, for example.</p>
<p>In the top snippet we&#39;re creating an instance of a String and notice that we declare it in exactly the same way as a regular primitive variable. We define the variable type, in this case, String and then the variable name. And then we declare the initial value after an equal sign. So in this case, we&#39;re setting the String value to &#34;Hello world&#34;. Now, in the bottom snippet, we&#39;re creating an array.</p>
<p>Now, arrays are interesting because they aren&#39;t an object per se, rather they&#39;re a collection of things. So we&#39;re actually creating two arrays here. The first array is an array of Strings and the second array is an array of integers. We know the variable is an array because the data type is followed by an open and close square bracket. The other hint is that the values that we&#39;re setting the array to are comma-delimited and contained inside the squiggly brackets.</p>
<p>Now what&#39;s important to note here is that whatever the data type of the array is, the contents of the array must be that data type. So in the first array, the values are all Strings and in the second array the values are all integers. Now, earlier, I talked about there being different types and levels of variables in Java. In actuality, there are three types of variables: a local variable is a variable that&#39;s defined inside a code block and therefore usable inside that code block.</p>
<p>And that&#39;s important. If I create a variable inside a method, I can&#39;t access it from outside that method. It is local to that code block only. Another type of variable is an instance variable. Instance variables are variables that can be declared on a class definition. So, for example, imagine that there was a class that you used to define a car.</p>
<p>Now there could be an instance variable defined on that class named make, and another called model. From anywhere in the code where you have access to an instance of the car class, you would be able to access those instance variables. But you must have an actual instance of the car class to access those variables. Instance variables are also sometimes called properties. And the final type of variable is the static variable.</p>
<p>Static variables are similar to instance variables, except you don&#39;t need an instance of the class to access the variable value. Now, let&#39;s pull all that information together and see how we would actually go about creating a local non-primitive variable and then use an instance and static variable. In this code snippet, we have a main class with a static main method. So let&#39;s take a look at what&#39;s happening inside this method.</p>
<p>Now right at the top, we&#39;re outputting a value to the console, using a print-line command. The value that we&#39;re outputting is from the variable named &#34;staticVariable&#34;, on the MyClass object. But what&#39;s important to see here is that we haven&#39;t actually created an instance of the MyClass object yet. And in fact, we&#39;re calling for the variable value against the MyClass definition. So if we assume that the value of the &#34;staticVariable&#34; is 20, then that&#39;s what we&#39;ll see in the console.</p>
<p>Now below that, we actually do create an instance of the MyClass object. And this is how you would create a variable for a non-primitive type. Almost always you&#39;ll have to use the new keyword. And right after that we create a primitive variable named localVariable. And that&#39;s what it is. It&#39;s a local variable. Technically so is the MyClass variable that we created right above it. So now we have two local variables.</p>
<p>One is primitive, the one named localVariable and one is non-primitive, the one named MyClass. Anyway, the value of localVariable has been set to 10. Now in the next line we set the value of the myClass.instanceVariable named instanceVariable to equal the value of localVariable. What&#39;s important to understand here is that the instanceVariable is not accessible until we create an instance of the class. So while we can access the staticVariable without an instance, we can&#39;t do that for the instanceVariable.</p>
<p>And finally, the last line of code outputs the value of the variable named instanceVariable to the console. So since we set it to the value of localVariable and localVariable was set to 10, we would see that the value of 10 is output to the console.</p></div></div></div><div class="section"><a name="section_4" /><h2 class="section_title">5. Video: Programming Java Variables ( it_sdjcfa_16_enus_05)</h2><img src="https://cdn2.percipio.com/public/b/361eeab0-43db-4a65-be4d-c21baf56217b/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/361eeab0-43db-4a65-be4d-c21baf56217b/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. In this demo, you’ll explore declaring variables in Java. You will use your previous demo to create variables for each of the different data types. Then, you’ll initialize each variable with a value. You’ll use what you built in Eclipse from the previous demo. You’ll open Eclipse IDE first, and then learn to convert each of those data types into real variables.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">declare and initialize variables in Java and use the final keyword</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Variables. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>In this demo, we&#39;re going to explore declaring variables in Java. To do that, we&#39;re going to use our previous demo to create variables for each of the different data types that we typed out. We&#39;ll then initialize each variable with a value. And we&#39;ll know we&#39;re doing a good job when the code is able to compile without any errors. All right. So as I said, we&#39;re going to piggyback off our previous demo, which we built in Eclipse. So let&#39;s head over to the Eclipse IDE now.</p>
<p>All right. So I already have our project open from the previous demo, but if you don&#39;t, go ahead and open it now. All right. So in our last demo, we typed out a whole bunch of data types. Some were primitives and some were non-primitives. But there&#39;s a problem with what we did. There are no variables yet. And so in this demo, we&#39;re going to convert each of those data types into real variables. Now, as we go along, we&#39;ll also initialize each variable with a value.</p>
<p>All right. So the first thing we need to do is access our data types class from the previous demo, and we can do that by double clicking on the DataTypes.java file in the Package Explorer panel on the left-hand side of the screen. And I&#39;ve already got mine open. Good. So as you can see on the screen, we&#39;ve typed out a bunch of different data types, each on a new line. Now notice that there&#39;s lots of red underlining. These are complaints from Java. The Eclipse IDE is looking at our code and telling us that it&#39;s all wrong. Well, that&#39;s true.</p>
<p>It&#39;s because we typed out all of our data types, but we didn&#39;t actually define them as variables. In fact, that means that this code can&#39;t be compiled. Actually, let&#39;s prove that. Let&#39;s start by saving the file with a Ctrl S and then running it with a Ctrl F11. Now in the console log at the bottom of the screen, we&#39;re seeing a nice big red exception. [Video description begins] <em>The console tab contains a list of syntax errors and prompts to insert variables.</em> [Video description ends]</p>
<p>Now, this is telling us that there&#39;s a compilation problem. It tries to figure out what the problem is, but it&#39;s actually saying there&#39;s quite a few. So ultimately, trust me when I say the problem is that we haven&#39;t defined proper variables and the code can&#39;t compile. So let&#39;s fix that. Let&#39;s go ahead and create some variables. Let&#39;s start at the top. The first line of code that we wrote was char. Well, that&#39;s not proper code and you can see that Eclipse has highlighted it telling us that.</p>
<p>So let&#39;s convert it to a proper variable. Now remember that the syntax for a variable is the data type, a space, the variable name and then a semicolon. So let&#39;s replace the char line of code with this: char myChar; Nice. Now notice how Eclipse is no longer underlining the code. that&#39;s great. That means that it now understands that line of code. So we&#39;ve now created a variable called myChar that is a char data type. And notice my naming. My variable name starts with a lowercase letter and each new word is capitalized.</p>
<p>OK, so let&#39;s keep going. Let&#39;s fix the rest of the primitive types. Let&#39;s change the boolean line to boolean myBoolean. And don&#39;t forget that semicolon. and then let&#39;s fix the byte line to byte myByte and now let&#39;s fix the short line to short myShort. [Video description begins] <em>The first letter after the word my is always capitalized by the host.</em> [Video description ends] And next, let&#39;s fix the int line to int myInt and the long line to long myLong and the float to float myFloat and we&#39;ll name the double myDouble.</p>
<p>Perfect, so now we can see that there are no more complaints on our primitive variables. Now there&#39;s still some complaints about our non-primitives down below, but maybe those don&#39;t matter anymore. So let&#39;s save the file again and try running it again. And remember, that&#39;s Ctrl S and Ctrl F11. Dang, still broken. Well, I guess that means that we have to fix our non-primitives too.</p>
<p>So let&#39;s do that. Let&#39;s replace our String line with String myString. [Video description begins] <em>Ιn line 15 the host deletes the dot after String and types myString;.</em> [Video description ends] And we&#39;ll do the same with StringBuilder and call the variable myBuilder. Good. Now let&#39;s give our String array the name of myStringArray with a capital S and a capital A. And notice that that means that the first letter of each word in my variable name is capitalized except for the first letter.</p>
<p>And finally, let&#39;s name our integer array, myIntArray. Perfect, so now we can see that there are no more complaints in the file at all. Well, at least no more red ones anyways. So let&#39;s see if this compiles now. Let&#39;s save it and run it. Nice. Now, our console at the bottom of the screen is empty. There is no code that outputs information to the console. So a blank output is exactly what we expect. So that&#39;s it.</p>
<p>We&#39;ve created a bunch of variables. They&#39;re all different data types and they all have different names, and that&#39;s actually important. You can&#39;t name two variables the same in the same scope. OK, so what if we wanted to set the value for each of these variables? So how do we do that? Well, let&#39;s go back up to our char line and I&#39;ll show you. Now before the semicolon let&#39;s add this text: space,&#61; space, &#39;s&#39;. Good. Now, what we&#39;ve done here is we&#39;ve initialized the myChar variable to the letter s.</p>
<p>Pretty easy, huh? Well, let&#39;s do that for our other variables. Let&#39;s set our myBoolean variable to true by typing &#61; true before the semicolon. Excellent. Now we&#39;ll set the byte to 1 and the short to 2 and the int to 3 and the long to 4 and the myFloat to 5.6 and the myDouble to 7.8. Excellent. Now notice that Java is a bit confused by the value that we gave our float variable. Well, that&#39;s because in Java, any number that has a decimal place is automatically considered to be a double.</p>
<p>And so according to Java, we&#39;re trying to put a double value in a float. So we can fix that by telling Java that the number really is a float. And we can do that by typing the letter f at the end of the number 5.6. Perfect. The error went away. But floats aren&#39;t the only data types that we can do this for. In fact, we should technically be doing this for other numbers too. So let&#39;s do it. At the end of the long number, let&#39;s type the capital letter L. Good.</p>
<p>Now that tells Java that the number that we typed truly is a long. And finally, even though it&#39;s the default, let&#39;s type the letter d at the end of the double number to tell Java that we&#39;re dealing with a double value. Excellent. So all of our primitives are configured and have been initialized with a real value. So what about our non-primitives? Well, let&#39;s do it. Let&#39;s drop down to our String and initialize the variable by adding &#61; &#34;hello space world&#34;. Nice!</p>
<p>Now for Strings, you can see that we can initialize them in pretty close to the same way as primitives. But not all non-primitives are like that. To prove that, let&#39;s look at our StringBuilder. Let&#39;s initialize it too. Now before its semicolon, let&#39;s add the code space,&#61; space, new space, StringBuilder with a capital S and a capital B, and then open and close round brackets. Perfect. Now you can see that we used the new keyword and this created a new instance of the StringBuilder class for us to use.</p>
<p>And finally we get to our special snowflakes, the arrays. Now, let&#39;s start with the String array. Now, before the semicolon, let&#39;s add the code space,&#61; space, {&#34;hello&#34;, space, &#34;world&#34; and }. Perfect. Now, what we&#39;ve done here is created an array of Strings. The array contains two Strings. The first one says hello and the second says world.</p>
<p>Now notice how the syntax to initialize the array includes a comma-delimited list of items surrounded by squiggly brackets. So let&#39;s do the same for our integer array. Let&#39;s add the code: &#61; {1,2,3}. Now the integers are comma-delimited and all surrounded by squiggly brackets. OK, so let&#39;s do one more thing. Let&#39;s quickly touch on the final keyword in Java.</p>
<p>Let&#39;s pretend you wanted to create a variable and set its value just like we&#39;ve done here. But then you want that variable to never be allowed to change ever again. Well, in Java, you can do that by using the final keyword. For example, let&#39;s go up to our int variable. Now, right below that variable, let&#39;s add another line. Let&#39;s type myInt&#43;&#43;; Good. Now, this isn&#39;t really hard code. All it&#39;ll do is add one to the integer variable that we have.</p>
<p>So what that means is that after this code runs, the value of myInt variable would be 4 because we added 1 to the 3 value that was initialized. But let&#39;s say we decided we didn&#39;t want the variable to ever be allowed to change. Well, let&#39;s do that. Now before the keyword int, let&#39;s add the code final. Now notice what happened to our myInt&#43;&#43;. Notice that Java doesn&#39;t like it anymore.</p>
<p>And if we tried to run this file, we get an exception because we&#39;re not allowed to change the variable. Pretty cool, right? And so there you have it. We&#39;ve converted our data types to real actual variables and we&#39;ve even initialized each and every one of them with a value. Great job.</p></div></div></div><div class="section"><a name="section_5" /><h2 class="section_title">6. Video: Java Type Casting ( it_sdjcfa_16_enus_06)</h2><img src="https://cdn2.percipio.com/public/b/fc622940-8264-4420-9eed-2c6a0fe90af8/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/fc622940-8264-4420-9eed-2c6a0fe90af8/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn about type casting. In Java, type casting means you’ll take a variable and convert it from one data type to another. You’ll also discover that certain data types aren&#39;t compatible and so type casting isn&#39;t possible. Additionally, you’ll learn there are two ways you can type cast. The first direction is called widening and the other is called narrowing.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe data type casting and the concepts of widening and narrowing casting</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Type Casting. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>In Java there&#39;s a specific kind of thing that you can do with variables, and it&#39;s called Type Casting. Sure, that might sound like your variable is stuck doing a certain kind of acting gig for the rest of its life until it sinks into a terrible depression. But that&#39;s not what it is at all.</p>
<p>In Java, type casting means that you take a variable and effectively convert it from one data type to another. So you can take an integer and convert it to a double and vice versa. But one thing that you have to watch out for is that sometimes certain data types aren&#39;t compatible and so the casting isn&#39;t possible. Now, when it comes to type casting, there are two ways that you can do that, or actually put another way, there are two directions that you can do that. The first direction you can go with casting is what&#39;s called widening.</p>
<p>Generally widening can be done automatically by Java for compatible types. Widening is about taking a data type and casting it to another bigger data type. So, for example, you can take a short data type, which remember has a maximum size of about 32,000, and easily cast it to a long data type, which has a maximum size of about nine quintillion. The other direction you can go with casting is what&#39;s called narrowing.</p>
<p>Narrowing can&#39;t be done automatically because there&#39;s no real backwards compatible type. Narrowing is about taking a data type and casting it to another smaller data type, or at least a different data type. So, for example, you may want to try to take a long data type and cast it to a short data type. But you can see the problem. If you have a huge number in your long variable, it may not fit in the short variable. So narrowing can be problematic. So what are the differences between widening and narrowing? How can you tell the difference or even decide which one to use in which situation?</p>
<p>Well, let&#39;s take a look at widening. As I said earlier, widening is effectively automatic. Without any real work on your part, Java can easily widen a data type. And in fact, that&#39;s the key. When it comes to widening its the compiler that does the job. You tell Java you want the data type to be widened and it can handle the rest for you. Now when you ask for a variable to be widened, you don&#39;t have to give Java a casting operator or any other special code.</p>
<p>You can just tell Java that you want the variable to be a certain type and it&#39;ll take care of it. But widening isn&#39;t magic. There are still constraints. The data types that you&#39;re casting have to be compatible. And finally and most importantly the target type in the cast operation can&#39;t be smaller than the source. In other words, you can&#39;t cast an integer to a byte. The target type has to be bigger, so you could cast a bite to an integer.</p>
<p>OK, so let&#39;s contrast that with narrowing. Well, with narrowing the cast is manual, Java won&#39;t be able to figure out what to cast to without help. What that means is that the developer is the one doing the casting and that means that the developer needs to actually provide a casting operator. And this will tell Java what and how to cast to and from. Of course, because narrowing is a manual approach, it means that there&#39;s no real limit on what you can and can&#39;t cast to.</p>
<p>Of course, if you try to cast a String into an integer, it may fail for different reasons, but technically from a code compilation perspective, it would be fine. The failure would happen at runtime, but should be perfectly fine at compile time. And the last difference between widening and narrowing is that with narrowing, you can cast a smaller data type. So if you wanted to cast an integer to a byte, you could do that as long as the value would fit in the byte, of course. So when we talk about widening a variable, we&#39;re really talking about converting it to a larger data type.</p>
<p>So imagine you have a thimble of water and you want to put that water into a shot glass. You could absolutely do that. You would be widening the container. Then over time, you added some more water into that shot glass and you want to put it into a pint glass. Well, you could do that, too. And again, you would be widening the container.</p>
<p>Well, in Java the same rule applies, as long as the data type that you want to cast is smaller than the data type that you want to cast to, then you can quickly and easily and automatically cast to the new data type. And Java will do it for you. But the order is very strict. In fact, the order for widening is byte, followed by short, then char, then int, then long, then float and then double. Now you can skip steps like you can cast a byte to an int or even all the way to a double, but you must go in that direction. Smallest to biggest.</p>
<p>You can&#39;t cast a double to a float automatically because a double is bigger than a float. And so that would actually be narrowing. So let&#39;s go over a quick example of widening. In this code snippet, we create an integer variable called myInt and we set its value to 50. Then in the next line of code, we create a new float variable called myFloat, and we set its value to the myInt variable. Now, what that&#39;s doing is it&#39;s telling Java to create a new float variable and initialize it with the integer value.</p>
<p>Now, Java has no problem with that. It creates the float and sets the value automatically. In the next couple of lines, we output the values to the console and what we see is that the Integer value is 50, and so is the Float value. In fact, because it&#39;s a float value, the output now includes a decimal place. The cast is successful and it does exactly what we expect. So that&#39;s how widening works.</p></div></div></div><div class="section"><a name="section_6" /><h2 class="section_title">7. Video: Programming Java Type Casting ( it_sdjcfa_16_enus_07)</h2><img src="https://cdn2.percipio.com/public/b/a4edcc5c-7d20-457c-8d57-088b399823ca/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/a4edcc5c-7d20-457c-8d57-088b399823ca/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. In this demo, you’ll learn the concept of widening. You’ll learn how to create a variable and cast it to bigger and bigger data types. You’ll also learn to output each result to the console so you can see the widening working as you go. This demo will use the work done in previous demos, which were built in Eclipse.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the use of data type casting and widening and narrowing casting</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Type Casting. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>In this demo, we&#39;re going to go over the concept of widening. We&#39;ll create a variable and we&#39;ll cast it to bigger and bigger data types, and we&#39;ll output each result to the console so we can see our widening working as we go. All right. So to do this demo, we&#39;re going to piggyback a bit off of our previous demos, which we built in Eclipse. So let&#39;s head over to the Eclipse IDE now.</p>
<p>All right. So I already have our project open from the previous demo, but if you don&#39;t, you go ahead and do that now. Now, what we&#39;re going to do in this demo is we&#39;re going to create a simple variable and then cast it to a bigger and bigger data type. And this is called widening. So to do that, we&#39;re going to create a new class so that we can start from a fresh canvas. So the first thing we&#39;re going to do is create a new class.</p>
<p>And to do that in Eclipse, let&#39;s go to the &#34;File&#34; menu and select &#34;New&#34;, &#34;Class&#34;. Perfect. Now in the pop-up Eclipse is asking us for information about our Class. The Source folder and the Package are pointed to the root of our project by default, and that&#39;s fine for our purposes here. So let&#39;s give our Class a Name. In this case, let&#39;s call it Widening with a capital W.</p>
<p>Now, I&#39;ll leave the Modifier, Superclass and Interfaces as the defaults, but let&#39;s make sure that we check the public static void main method stub checkbox and leave the others unchecked. Good. Now let&#39;s click &#34;Finish&#34;. Excellent, we have our Class and now we can finally get started. OK, so remember that the concept of widening in Java [Video description begins] <em>A new Java tab class is created, titled Widening.java. Line 1 reads: package demo16;. Line 3 reads: public class Widening {. Line 5 reads: public static void main(String[] args) {. Line 6 reads: // TODO Auto-generated method stub.</em> [Video description ends] is to cast a variable from one data type to another, but always in an upwards direction. Or more appropriately, it&#39;s about casting to bigger data types.</p>
<p>So, for example, imagine you had a glass of water and if you wanted to pour the whole glass into a swimming pool, you could absolutely do that. The glass and the pool are like data types and the water is the value. In Java, we call that widening. Of course, on the other hand, if we had a glass of water and wanted to pour it into a thimble, that wouldn&#39;t work so well.</p>
<p>In Java that&#39;s called narrowing. Of course, for the purposes of this demo, we&#39;re concerned with widening. So let&#39;s focus on that. Now, the point is that widening is about converting variables to larger data types. So let&#39;s write out an example. Let&#39;s replace the comment with this code: byte myByte &#61; 1; perfect. [Video description begins] <em>The host deletes the content of line 6 and replaces it.</em> [Video description ends] So what we&#39;ve done here is we&#39;ve created a variable called myByte, which uses the data type byte, and has been initialized to a value of 1.</p>
<p>Now, in Java, a byte is just about the smallest kind of data type that you can have. So let&#39;s start by proving that we have the right value. So let&#39;s drop a couple of lines down and type the following code: System.out.println(myByte); good. Now what we&#39;re doing here is we&#39;re creating a byte variable and we&#39;re setting its value to 1 and then we&#39;re outputting that value to the console. So let&#39;s prove that. Let&#39;s save the file with a Ctrl S and run the project with a Ctrl F11.</p>
<p>Nice. So we now see a value of 1 being displayed in the console at the bottom of the screen. Congratulations. We created a variable and showed its value on the console. Now let&#39;s widen the variable. Let&#39;s say we want to create a short data type from myByte variable. Well, that would mean casting myByte to a short. And since a short is bigger than a byte, I can totally do that. So let&#39;s do it.</p>
<p>On the line below our byte, let&#39;s type this code: short myShort &#61; myByte; Now on the line below our print line command, let&#39;s type this code: System.out.println(myShort); Excellent. So what we&#39;ve done here is we&#39;ve created a new variable called myShort that is using the short data type and we&#39;ve initialized its value from our byte. Then we added another print line command to output that value to the console.</p>
<p>So let&#39;s save this and run it. Cool. So now we see two 1s in the console output at the bottom of the screen, that shows that our cast worked. So let&#39;s keep going. Let&#39;s repeat the whole process but for an integer. So below our short, let&#39;s add the code: int myInt &#61; myShort; and then we&#39;ll add System.out.println(myInt). Excellent. Now we&#39;ll save and run that. All right, now we have three 1s. Excellent! [Video description begins] <em>The console tab in the bottom of the screen now lists the number 1 three times.</em> [Video description ends]</p>
<p>But wait, there is more let&#39;s keep this going. Let&#39;s try this with a long. Below our integer we&#39;ll add: long myLong &#61; myInt and as a last console output we&#39;ll type: System.out.println(myLong); We&#39;ll save it and we&#39;ll run it. Excellent! Four 1s. OK, so that&#39;s the whole numbers, but what about our decimal numbers? Well, let&#39;s give that a whirl. So below our long, let&#39;s add this code: float myFloat &#61; myLong;</p>
<p>Good, and we&#39;ll add our print line command: System.out.println(myFloat); and we&#39;ll save and run that. Ooh! Something different. Now remember that a float is a value that has a decimal number. So when we cast a whole number into a float, it worked, but we don&#39;t have an actual decimal number, so we get 1.0. Nice. All right. So let&#39;s do one more cast. And you probably guessed which one.</p>
<p>Below our float, let&#39;s add the code: double myDouble &#61; myFloat; and we&#39;ll add one last console output: System.out.println(myDouble); and we&#39;ll run that. Excellent, another 1.0. This worked seamlessly. But let&#39;s prove it a little bit more. Let&#39;s change our original byte value from 1 to 42. [Video description begins] <em>In line 6 the host replaces the value 1 with 42.</em> [Video description ends] So if our casting is working properly, then every single value that we output to the console should now be changed to 42. So let&#39;s save the file and run the project again to see.</p>
<p>Hey, we got 42. Great. OK, so one last thing. Now remember that a widening is about casting to a larger data type. If you had a byte and you wanted to cast to a double, you can do that directly. You don&#39;t have to cast to each type in between like we did here. To prove that let&#39;s change the myDouble variable to equal the myByte variable, instead of the myFloat variable: myByte; Save and run. There it is, we still got the number 42 as our output. So that&#39;s widening in Java. Great job.</p></div></div></div><div class="section"><a name="section_7" /><h2 class="section_title">8. Video: Java Type Conversion ( it_sdjcfa_16_enus_08)</h2><img src="https://cdn2.percipio.com/public/b/94c9503b-1786-47dd-bef5-abc097c0e151/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/94c9503b-1786-47dd-bef5-abc097c0e151/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about automatic type casting and then there&#39;s manual type casting in Java. You’ll learn that automatic type casting allows Java do the work of widening your variables to larger data types. Manual type casting tells Java how to convert data from one type to another. You’ll learn that the process of manually converting a variable from one type to another is generally known as narrowing.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe data type conversion and the concepts of widening and narrowing conversions</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Type Conversion. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>In Java, there&#39;s automatic type casting and then there&#39;s manual type casting. With automatic type casting, you can let Java do the work of widening your variables to larger data types. With manual type casting, you&#39;re telling Java how to convert data from one type to another. Now, the process of manually converting a variable from one type to another is generally known as narrowing.</p>
<p>Manual casting, as you can guess from the name, is an activity that always has to be performed by the programmer. There is no automation. Java may not know how to convert from one type to another. So you&#39;ll have to do the work of telling it what you want to do. And the way to do that is through a casting operator. And I&#39;ll show you more about that in a second. Now, the reason narrowing is a manual process is because Java can&#39;t automatically figure out how to convert certain data types.</p>
<p>For example, with narrowing target types can actually be smaller than the source type. You can&#39;t expect Java to automatically convert 1.23 to an integer because it&#39;s not a whole number. So you have to tell it what to do. So when we talk about narrowing variables, we&#39;re really talking about converting it from one data type to another. It&#39;s generally called narrowing because you&#39;re going from a larger data type to a smaller one.</p>
<p>Now, remember that with widening, Java could automatically convert a variable to another data type as long as that data type was larger than the one that you&#39;re coming from. So you can go from byte to short to int to long and so on. Well with narrowing you&#39;re asking Java to go in the opposite direction but that&#39;s not without its dangers. So let&#39;s imagine that you have a pint glass of water and you want to put that water into a shot glass.</p>
<p>Well, if the amount of water that you have in the pint glass is small, you could absolutely do that with no consequences and you would be narrowing the container. Of course, if the amount of water that you have in the pint glass is more than the shot glass can handle, you&#39;ll have a big mess on your hands. Well in Java the same rule applies. As long as the value that you have fits in the target data type, you&#39;ll be OK. But if you overrun the size of the target data type, you&#39;ll run into problems.</p>
<p>More importantly, you&#39;ll run into situations where the data doesn&#39;t seem to match what you&#39;re expecting. Now, the good news is that the syntax for narrowing is pretty straightforward. All you have to do is define a variable of the data type you want. And then when you go to make it equal to some value, you prefix the source variable with the target data type in round brackets. So let&#39;s take a look at the syntax on the screen, for example.</p>
<p>In this snippet, we have a variable called sourceVariable and its data type is SourceDataType. Great. Then on the next line, we create a new variable called targetVariable and it&#39;s data type is TargetDataType. Then what we&#39;re doing is we&#39;re casting our &#34;SourceVariable&#34; to the TargetDataType class by using the TargetDataType in round brackets. So what this code is doing is it&#39;s actually creating a new variable that is equal to a converted version of the SourceDataType class variable.</p>
<p>Now, again, it&#39;s very important to remember that just because we&#39;re using the syntax, it doesn&#39;t mean that narrowing and casting of this type will always work. It&#39;s kind of like this: all dogs are animals, but not all animals are dogs. So if you try to narrow something that simply isn&#39;t compatible, the casting operation will fail on you and that&#39;ll only happen at runtime.</p>
<p>OK, so let&#39;s go over an actual example of what narrowing would look like. In this code snippet, we created a double variable named myDouble and then we set its value to 25.65. So far, so good. Now, in the next line, we want to cast or narrow that value. And what we&#39;re doing is we&#39;re creating an integer variable called myInt. Then you see that we&#39;re setting its value to the myDouble variable, but we&#39;re using the manual casting syntax to convert it to an integer.</p>
<p>Then in the next two lines, the values of myDouble and myInt are output to the console and the result would be that the double value would still be 25.65 and the integer value would be 25. A successful narrowing. Now it&#39;s important to understand that even though a double is a decimal number, it doesn&#39;t mean it&#39;s fundamentally incompatible with an integer. So we can do this, but there are side effects. Java tries to be helpful when converting between known primitive types.</p>
<p>In fact, let&#39;s pretend I set the myDouble variable value to be triple the maximum size of an integer. Well, instead of failing, Java will actually just overrun the integer size three times and you&#39;ll get some number that equates to that overrun. And this is critical to understand. It means that Java is doing some magic for you, or at least it&#39;s doing something that you might not expect.</p>
<p>Primarily it means that the value that you get in the integer is technically not the value that was in the double. Some developers would say that they&#39;d rather have Java throw an exception here rather than succeed with the wrong number. So just be careful when it comes to narrowing.</p></div></div></div><div class="section"><a name="section_8" /><h2 class="section_title">9. Video: Programming Java Type Conversion ( it_sdjcfa_16_enus_09)</h2><img src="https://cdn2.percipio.com/public/b/1774659c-8593-4b76-ae1e-43680e366d49/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/1774659c-8593-4b76-ae1e-43680e366d49/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. In this demo, you’ll learn the concept of narrowing. You&#39;ll create a variable and cast it to smaller and smaller data types. Then, you’ll output each result to the console to see the narrowing as you go. This demo will use the work done in previous demos, which were built in Eclipse.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the use of data type conversion and widening and narrowing conversions</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Type Conversion. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>In this demo, we&#39;re going to go over the concept of narrowing. We&#39;ll create a variable and we&#39;ll cast it to smaller and smaller data types. We&#39;ll output each result to the console so that we can see our narrowing working as we go. All right. So to do this demo, we&#39;re going to piggyback a bit off of our previous demos, which we built in Eclipse. So let&#39;s head over to the Eclipse IDE now.</p>
<p>All right. So I already have our project open from the previous demo. But if you don&#39;t go ahead and do that now. Now, what we&#39;re going to do in this demo is we&#39;re going to create a simple variable and then cast it to smaller and smaller data types. And this is called narrowing. To do that, we&#39;re going to create a new class so that we can start from a fresh canvas.</p>
<p>So the first thing we&#39;re going to do is create a new class. To do that in Eclipse, let&#39;s click on the &#34;File&#34; menu, and select &#34;New&#34;, &#34;Class&#34;. Now in the pop-up, Eclipse is asking us for information about our Class. The Source folder and Package are pointed to the root of our project by default, and that&#39;s fine for our purposes.</p>
<p>So let&#39;s give our Class a Name. In this case, let&#39;s call it Narrowing with a capital N. And we&#39;ll leave the Modifiers, the Superclass and the Interfaces as the defaults, but let&#39;s make sure that we check the public static void main method stub checkbox and leave the others unchecked. Good. Now let&#39;s click &#34;Finish&#34;. Excellent. We have our Class and we&#39;re ready to go. [Video description begins] <em>A new Java tab class is created titled Narrowing.java. Line1 reads: package demo16;. Line 3 reads: public class Narrowing {. Line 5 reads: public static void main(String[] args) {. Line 6 reads: // TODO Auto-generated method stub.</em> [Video description ends]</p>
<p>So now remember that the concept of narrowing in Java is to cast a variable from one data type to another. Doesn&#39;t actually matter what data types you convert from and to, but there is always a risk of incompatibility. So the data types still have to be compatible to perform a narrowing cast. So, for example, imagine you had a glass of water. If you wanted to pour the whole glass into a thimble, you could do that, but you&#39;d get a bit of a mess. But both the glass and the thimble hold water, so they are compatible types.</p>
<p>In Java, we call that narrowing. Of course, on the other hand, if we had a bowl of spaghetti and we wanted to convert that into the color purple, we would get all confused. And the same is true for Java. One of the biggest differences between widening and narrowing is that widening can happen automatically in Java, while narrowing requires us to tell Java what to do. So let&#39;s write out an example.</p>
<p>Let&#39;s replace the comment with this code: [Video description begins] <em>The host deletes the content of line 6 and types.</em> [Video description ends] double myDouble &#61; Double.MAX_VALUE; all uppercase. And don&#39;t forget that semicolon. Perfect. So what we&#39;ve done here is we&#39;ve created a variable called myDouble, which uses the data type double and has been initialized to the maximum possible value of a double. Now, in Java, a double is the largest numeric data type that you can have. So let&#39;s start by proving that we have the right value.</p>
<p>Let&#39;s drop a couple of lines down and type the following code: System.out.println(myDouble); Now, what we&#39;re doing here is we&#39;re creating a double value, setting it to the maximum value of a double and then outputting that value to the console. So let&#39;s prove it. Let&#39;s save the file with a Ctrl S and let&#39;s run the project with a Ctrl F11. Nice. So we now see a monster value being displayed in the console at the bottom of the screen. Congratulations.</p>
<p>We created a variable and showed its value on the console. We&#39;re getting good at this. Now let&#39;s narrow the variable. Let&#39;s say I wanted to create a float data type from my double variable. Well, that would mean casting my double to a float. And since a float is smaller than a double, I can&#39;t rely on Java doing that automatically. I have to manually tell Java to perform that cast.</p>
<p>So let&#39;s do it. On the line below our double, let&#39;s add this code: float myFloat &#61; and then in round brackets (float) and then myDouble; Now in the line below our print line command, let&#39;s add this code System.out.println(myFloat) and ; excellent. So what we&#39;ve done here is we&#39;ve created a new variable called myFloat that is using the float data type, and we&#39;ve initialized its value from a double. But the important part of the code is that we specifically told Java to convert the double value to a float by adding the round brackets and the keyword float before the myDouble variable.</p>
<p>Then we added another print line command to output our float value to the console. So let&#39;s save this and run it. Uh-oh, suddenly we&#39;re seeing Infinity in the console. Well, that&#39;s because we tried to put a value that&#39;s simply too large to fit into a float, so we overran it. And for float, that results in Infinity. That&#39;s the danger of narrowing. If you&#39;re trying to pour a glass of water into a thimble, you will overrun the container. So let&#39;s fix that.</p>
<p>Let&#39;s change the Double.MAX_VALUE to Integer.MAX_VALUE. And now let&#39;s save and run this. Ahh! Much better. Now we see both values in the console. You can see that the float value is slightly different though, so that tells us the cast isn&#39;t necessarily exact. Regardless, let&#39;s keep going. Let&#39;s repeat the whole process for a long. Below our float, let&#39;s add this code: long space myLong &#61; and in round brackets (long) and then myFloat;</p>
<p>And then let&#39;s add another print line: System.out.println(myLong). Excellent. And now let&#39;s save and run this to see what we get. Perfect. We got the expected value. The format of the value is slightly different again, but it appears to be the same value. But wait, there&#39;s more. Let&#39;s try this with the int. Below our long, let&#39;s add this code: int space myInt &#61; and then in round brackets (int) and myLong;</p>
<p>And then the print line command: System.out.println(myInt); And now let&#39;s save and run this again. What? What is this now? We narrowed a huge number down to an int and got a negative number? What&#39;s that about? Well, this is once again the danger of narrowing. Downwards casting isn&#39;t exact. We lose some precision as the narrowing happens. So in this case, we&#39;ve overrun the integer just enough that it rolled over to the other end of the spectrum.</p>
<p>So you can see it&#39;s not going to work great. So let&#39;s fix that. Let&#39;s change our original value from the maximum size of an integer to, say, 65000. [Video description begins] <em>In line 6 that reads: double myDouble &#61; Integer.MAX_VALUE;, the host deletes the part after the &#61; symbol and types 65000.</em> [Video description ends] Now let&#39;s run this again. Much better. Now we see all the values are exactly the same in the console. Fantastic. So let&#39;s keep going.</p>
<p>Below our integer, let&#39;s add the code: short myShort &#61; (short) in round brackets, and then myInt and we&#39;ll add another console output: System.out.println(myShort) and don&#39;t forget the semicolon. Now let&#39;s save and run this. What? Again? Oh, man! Now our number is overrunning the short. [Video description begins] <em>In the console tab, below the list of the 65000 values, appears the value -536.</em> [Video description ends]</p>
<p>Well, let&#39;s change the number from 65000 to 1000 then. [Video description begins] <em>In line 6 the host replaces the value 65000 with 1000.</em> [Video description ends] And we&#39;ll save and run that. Perfect. We&#39;re back to normal. [Video description begins] <em>All values in the console tab now read 1000.</em> [Video description ends] All right, let&#39;s do one more cast, and you probably guessed which one. Below our short let&#39;s add byte space myByte &#61; and then in round brackets (byte) and then myShort;</p>
<p>And we&#39;ll add a system print line: System.out.println(myByte); Excellent. So we&#39;ll save and run this. Oh, man! Well, should we be shocked at this point? Another overrun. [Video description begins] <em>At the end of the 1000 values list in the console now appears the value -24.</em> [Video description ends] So that&#39;s narrowing in Java. You can convert from any data type to another. But where compatibility is a problem or overruns happen, you could find yourself in a position where you&#39;re getting unexpected results, just like we did. So be very careful about what you&#39;re casting from and to. Regardless, this has been how to perform a narrow cast. Great job.</p></div></div></div><div class="section"><a name="section_9" /><h2 class="section_title">10. Video: Java Strings ( it_sdjcfa_16_enus_10)</h2><img src="https://cdn2.percipio.com/public/b/370a3ad4-ddc3-4066-a0eb-407c8f2972b2/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/370a3ad4-ddc3-4066-a0eb-407c8f2972b2/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn about one of the most common and important non-primitive classes in Java, the String Class. You’ll discover the String Class is so common that most other programming languages include String as a primitive. The purpose of the String Class is to define and manage text. You’ll learn that even though a String is a non-primitive data type, it&#39;s composed of a primitive data type.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the features of the Java String class </li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Strings. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>One of the most basic, common and important non-primitive classes in Java is the String Class. In fact, the String Class is so common that most other programming languages include String as a primitive. So Java is a little special here. Now, the purpose of the String Class is to define and manage text. Now, while a String is a non-primitive data type, it&#39;s actually composed of a primitive data type.</p>
<p>Effectively, a String is a collection of chars. In fact, it&#39;s a special array of chars. But probably the most important detail about a String is that it&#39;s immutable. Immutable means that the value cannot be changed. That&#39;s right. Once you set the value of a String, that&#39;s it. That&#39;s what it is forever. Oh, sure, you can create new Strings and you can even override your existing String variables to make it look like you&#39;ve changed the value, but you&#39;re not actually changing the value.</p>
<p>In fact, the way it works is that Java allocates an area of memory where your String is located and that&#39;s why you can&#39;t change it. If you want to change it, you need to create a new String, which means a new area of memory and override the original value, so Java can recover that bit of memory. In Java, there are two main ways that you can create an instance of a String.</p>
<p>The first and frankly easiest, is to use a literal. What that means is that you can define a String simply by saying it equals a piece of quoted text. And the second way is to use the new keyword. In this case, you create a new instance of the String class and pass it the text that you want it to be equal to. Now, the advantage of the new keyword is that you can create an instance of a String based on other data types like arrays or chars, and it will also always create another area of memory.</p>
<p>Now the advantage of the literal besides, of course, being easier is that Java keeps all the literals in what it calls a constants pool. So if you created two Strings with the same literal, Java would actually optimize your memory usage by having both variables point to the same memory block. So what&#39;s the syntax that we can use when creating a String? What&#39;s the actual code that we would use to create a String and then use it? Well, as I said earlier, there are two ways to do it.</p>
<p>On the screen, we can see some code snippets that represent those two ways. At the top of the snippet we see a String creation using a literal. You can declare your variable with a single String myString. Now, obviously, the text, myString is the variable name. Then after an equal sign, you can provide the text that you want to initialize the String variable to in double quotes. In the case of this snippet, we&#39;re saying that the myString variable is being set to the literal constant of &#34;Hello world&#34;. Now, at the bottom of the snippet you can see an example of creating a String using the new keyword.</p>
<p>This code once again creates a String called myString, except this time after the equal sign, we say new String and then in the String&#39;s constructor we pass in a double-quoted String. Now, unlike using the literal, every time you use the new keyword, Java will allocate a new memory location for your String value, even if there&#39;s another String using that exact same value. In other words, Java guarantees a different object in memory if you use the new keyword.</p>
<p>Downside is that it reduces the chances of Java being able to optimize your code&#39;s memory footprint. Now, the String class in Java has quite a number of built-in methods that can be used to obtain information or new Strings altogether from a given String. As an example, here are a few very common methods that can be used against a String. First, we have the charAt method. It can be used to search for a specific character in a String and return its index location.</p>
<p>Next, we have the compareTo method. This can compare two Strings and tell you how different they are based on the Unicode character values of the Strings, and it&#39;s not often used. The concat method allows you to add a String to your String and produce another String. Now remember, Strings are immutable, so you can&#39;t change your existing String. And that means that the concat method actually returns a whole new String.</p>
<p>The contains method allows you to search for a piece of text in your String and the result will be true, meaning it found the value, or false, meaning it didn&#39;t. Now, unlike the compareTo method, the equals method actually tells you if two Strings are the same or not. If they are, the method will return true. And next, there&#39;s the indexOf method. Now this method is used to define at what index you might find a piece of text in your String.</p>
<p>If the value isn&#39;t found, negative one is returned, and the length method tells you how many characters are in your String. The Substring method is useful for being able to pull out parts of a String, into a new String. And finally the toLowerCase and toUpperCase methods create new versions of the String in all lowercase or uppercase, respectively.</p>
<p>Now, just because a String is immutable, it doesn&#39;t mean that you can&#39;t do things with it. In fact, let&#39;s consider this code snippet. In this code snippet, we have two Strings. One is named myString1, with a value of &#34;Hello &#34; and a space and the other is named myString2 with a value of &#34;world&#34;. Then we create a whole other String called myString3 and we make it equal to myString1 &#43; myString2.</p>
<p>Now this results in the creation of a whole new block of memory that equals the value of the first two variables put together. Then finally, we output the value of myString3 to the console and we get a value of Hello world But there&#39;s another way to combine Strings, and that&#39;s to use the concat method. Let&#39;s consider this code snippet. In this code snippet we once again have the same two Strings.</p>
<p>We&#39;ve got myString1 with a value of &#34;Hello &#34; and a space and we have myString2, which has been given a value of &#34;world&#34;. Then we once again create a whole other String called myString3, but this time we make it equal to something else. This time we take the myString1 variable and call the concat method with the myString2 variable as the parameter. Now what this does is add the value of String2 to the end of String1 and output a new String.</p>
<p>And Strings are immutable so it doesn&#39;t change String1 or String2. Instead it outputs a whole new String. So if you put the result into a new variable, myString3, and then output the value of myString3 to the console, then we get the value of Hello world. I will tell you that the concat method is way more efficient than the plus operator, but it can only work with two variables at a time.</p>
<p>Next, let&#39;s look at an example of a code snippet that shows how we would use the length method. In this code snippet, we create an instance of a String with the text &#34;Hello world&#34;. Then in the line below, we call the length method on that String while outputting the result to the console, using the print line command.</p>
<p>Now, the purpose of the length method is to return the total number of characters, including spaces and special characters in the String. Now, if you manually counted the number of characters in the String Hello space world, you would arrive at 11 characters. So if we ran this code, that&#39;s what the result of the length method would be. And finally, let&#39;s take a look at a small code snippet and see the charAt method in action.</p>
<p>In this code snippet that we have here we create an instance of a String with the text &#34;Hello world&#34; once again. Then in the line below, we call the charAt method on that String and ask for the character at index 6. Now, the purpose of the charAt method is to return whatever character is at the given index. Now remember that indexes are all zero-based, so that means that index 6 actually means the seventh character in the String. So in this case, that would be the letter w in Hello world. So if you ran this code, it would output the letter w to the console.</p></div></div></div><div class="section"><a name="section_10" /><h2 class="section_title">11. Video: Programming Java Strings ( it_sdjcfa_16_enus_11)</h2><img src="https://cdn2.percipio.com/public/b/530b1b84-cd54-4a77-9940-5d383cfad56e/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/530b1b84-cd54-4a77-9940-5d383cfad56e/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. In this demo, you’ll go over the features of the String class in Java. To do that, you’ll follow onscreen directions to create a class in your existing project and then create and display Strings in different ways. To do this demo, you’ll use the work from previous demos, which were built in Eclipse.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the features of the Java String class</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Strings. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>In this demo, we&#39;re going to go over the features of the String class in Java. To do that, we&#39;re going to create a class in our existing project and then create and display Strings in a couple of different ways. All right. So to do this demo, we&#39;re going to piggyback a bit off our previous demos, which we built in Eclipse. So let&#39;s head over to the Eclipse IDE now.</p>
<p>All right. So I already have our project open from the previous demo, but if you don&#39;t, why don&#39;t you go ahead and do that now. Now, what we&#39;re going to do in this demo is we&#39;re going to create a simple String variable and then call a few methods to show what we can do with Strings. To do that, we&#39;re going to create a new class so that we can start from a fresh canvas. So the first thing we&#39;re going to do is create that class. And to do that in Eclipse, let&#39;s click on the &#34;File&#34; menu and select &#34;New&#34;, &#34;Class&#34;.</p>
<p>Perfect. Now in the pop-up Eclipse is asking us for information about our Class, so let&#39;s give it a Name. In this case, let&#39;s call it Strings with a capital S. Now, we&#39;ll leave all of the settings default, but let&#39;s check the public static void main method stub checkbox and leave everything else alone. And then we&#39;ll click &#34;Finish&#34;. Excellent. We have our class and we can get started. [Video description begins] <em>A new Java tab class is created titled Strings.java. Line 1 reads: package demo16;. Line 3 reads: public class Strings{. Line 5 reads: public static void main(String[] args) {. Line 6 reads: // TODO Auto-generated method stub.</em> [Video description ends]</p>
<p>So now we can get to creating and using a String. So let&#39;s start by creating a String variable. Let&#39;s replace the comment in the main function with the following code: String space myString space &#61; space [Video description begins] <em>The host deletes the content of line 6 and types.</em> [Video description ends] and in double quotes &#34;Hello&#34; and don&#39;t forget to end with a semicolon. Good. Now let&#39;s drop a couple of lines down and type the following code: System.out.println(myString); Now what we&#39;ve done here is we&#39;ve created a String variable named myString and we&#39;ve initialized it with a value of &#34;Hello&#34;.</p>
<p>Then we&#39;re using the print line command to output the value to the console. So let&#39;s test this. Let&#39;s save the file with a Ctrl S and then run the project with a Ctrl F11. All right. So we&#39;re seeing the text Hello in the console at the bottom of the screen. Nice job. Now, before we go any further, notice that the Hello has a capital H. Now, remember that a String is a non-primitive data type, and that means that there are methods and properties that we can access against it.</p>
<p>So let&#39;s do that. Below our print line command, let&#39;s add another line of code like this: System.out.println(myString.charAt with a capital A (1)); So here we&#39;re calling the charAt method against our String variable. We&#39;re asking for whatever character is at index 1 of the String. And remember that in Java indexes are zero-based. So asking for a character at index 1, is actually asking for the second character. So if we count that out, then the second character is the e in Hello. So let&#39;s save this and run it to find out. Hey, perfect.</p>
<p>We got the letter e in the console at the bottom of the screen. Great. Now let&#39;s add another method call. Beneath our last print line command, let&#39;s add another line of code like this: System.out.println(myString.concat( and then in double quotes space, world and the &#34; and the )) and ; So here we&#39;re calling the concat method against our String variable. We&#39;re passing in a value of space, world. And what that means is we&#39;re asking Java to create a new String that appends space, world, to our existing String of Hello.</p>
<p>So if you run this code, we should get Hello world. So let&#39;s save the file and run it and see what happens. Perfect. Hello world. Nice. [Video description begins] <em>The text Hello world appears in the console tab.</em> [Video description ends] Next, let&#39;s use the contains method. In the next line of code, let&#39;s type this code: System.out.println(myString.contains(&#34;world&#34; and then we&#39;ll close the brackets and a semicolon. Now, what we&#39;re doing here is we&#39;re checking to see if our String contains the text world.</p>
<p>Now, remember that Strings are immutable. In our previous line of code, we asked to add the word world to our String, but that should create a whole new String. That means that our existing String variable should not have the word world in it and it should still just be Hello. So if we try to find world inside a String that should only contain Hello, we shouldn&#39;t find it. So let&#39;s run it and see what it says.</p>
<p>We&#39;ll save it and we&#39;ll run it. Excellent. The result is false and that&#39;s exactly what it should be. But let&#39;s change it to make sure that we&#39;re using it properly. Instead of the text world, let&#39;s change it to el. Now, we know that that text is somewhere in the word Hello, so this should give us an answer of true. So let&#39;s give it a rip. Nice. It&#39;s true. OK, so now let&#39;s use the equals method. This is like the contains method, except, instead of looking to see if a piece of text exists inside the String, it checks to see if the whole String equals some text.</p>
<p>So let&#39;s try it. In the next line, let&#39;s type this code: System.out. print line or println(myString.equals(&#34;foo&#34;)) and ; So what we&#39;re doing here is we&#39;re asking Java if our String value is exactly the same as the text foo. Well, we know they&#39;re not the same, so we expect a value of false here. So let&#39;s run it and find out. And there it is: false, just like we expected. OK, so now let&#39;s change the text foo to the text hello. And now let&#39;s try that.</p>
<p>False again. Why is that? Well, it&#39;s because in Java, Strings are case-sensitive. Remember that we said our text Hello has a capital H. So the text hello with a lowercase is not the same as the text Hello with a capital H. So now let&#39;s try changing our text to capital H Hello, and run it again. That&#39;s got it. Perfect. Now continuing on with the searching pattern, let&#39;s take a look at the indexOf method. So in the next line, let&#39;s type this code: System.out.println(myString.indexOf with a capital O, &#34;ll&#34;)) and the ;</p>
<p>So what we&#39;re doing in this code is we&#39;re asking Java to tell us at what index we can find the text ll. Now remember that indexes in Java are zero-based and we know that the text ll is in the String and we know that the l&#39;s are the third and fourth letters in the word. But since indexes are zero-based, they&#39;re actually indexes 2 and 3. So that means that the text ll should begin at index 2.</p>
<p>So let&#39;s run this code and see what we get. Perfect, we got index 2. But, what if the text we&#39;re looking for doesn&#39;t exist in the String? Well, let&#39;s try it and see. Let&#39;s change the text we&#39;re looking for to foo. And now let&#39;s run that. [Video description begins] <em>The host replaces the ll in line 13 with the text foo.</em> [Video description ends] So you can see now that we got a value of -1. Now in a String, nothing can be at index -1. So if you get a value of -1, it really means that the text that you&#39;re looking for is not found in the String.</p>
<p>OK, so next, let&#39;s use the length method. In the next line, let&#39;s type the following code: System.out.println(myString.length() then we&#39;ll close the bracket for the print line and a semicolon. Great. Now the length method tells us how many characters, including spaces and special characters, are in the String. So if we count the letters in the word Hello, we get 5. So if we run this code, that&#39;s what we should see. So let&#39;s run the code and find out. Nice! Man, we&#39;re killing it here. [Video description begins] <em>The value 5 appears in the console.</em> [Video description ends]</p>
<p>All right, lastly, let&#39;s take a look at the toUpperCase method. In the next line, let&#39;s type this code: System.out.println(myString.toUpperCase with a capital U and a capital C, open close brackets. And then don&#39;t forget the semicolon at the end. Now, the toUpperCase and the toLowerCase methods both work the same way, and their intent is pretty obvious from the naming of the methods. So what we expect to see here is that the String will be output as all uppercase characters.</p>
<p>So let&#39;s run it and find out. Excellent. We got our String output in all capital letters and nothing says warm greeting like screaming hello at somebody, right? So that&#39;s the String class and its methods. There are other methods and ways that you can use the String class, but this gives you a good idea of how to interact with it. Now, remember that Strings are immutable and that means that they can&#39;t change. So you need to use these methods to gather information about your String and then generate new Strings. So happy stringing.</p></div></div></div><div class="section"><a name="section_11" /><h2 class="section_title">12. Video: Java StringBuilder Class ( it_sdjcfa_16_enus_12)</h2><img src="https://cdn2.percipio.com/public/b/24530363-c0e4-4634-a930-5bb5bb7fca8b/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/24530363-c0e4-4634-a930-5bb5bb7fca8b/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn that Strings are immutable, which means they can&#39;t be changed. In order to change a String, you need to create a new String or overwrite your existing variable. To work around this, you’ll learn to use the StringBuilder Class. You’ll discover the StringBuilder Class is a collection of characters put together to form text. You’ll learn the purpose of the StringBuilder is to manage memory allocation of your text.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the Java StringBuilder class and how it relates to the String class</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java StringBuilder Class. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>In Java, Strings are immutable, and that means that they can&#39;t be changed. To change a String means that you actually need to create a whole new String, or overwrite your existing variable. So how do you work around that? Well, you can use the StringBuilder Class.</p>
<p>Like a String, the StringBuilder Class is ultimately a collection of characters that are all put together to form a piece of text. Now, the purpose of the StringBuilder is to manage the memory allocation of your text under the hood. The result is that you can call methods on the StringBuilder and actually manipulate the text that it contains. What that means is that the String value managed by the String class is mutable, which means that it can be changed. Now the StringBuilder is not a replacement for the String class.</p>
<p>It&#39;s better to consider the StringBuilder class as an alternative to the String class. The methods and the way that you interact with it is different than String, and you can&#39;t initialize it with a literal. So it is different, but it&#39;s a good alternative. In fact, StringBuilder is very useful for looping and threading conditions because it manages memory for you behind the scenes. Now, the StringBuilder Class is extremely useful.</p>
<p>It&#39;s fast and efficient, it manages Strings and allows you to manipulate text without having to create other variables or override existing variables. As I said, it&#39;s particularly handy if you want to build Strings using a looping mechanism. The StringBuilder Class is almost identical to another class called StringBuffer. StringBuffer can also be used to manipulate Strings in almost exactly the same way.</p>
<p>It even has the exact same methods as StringBuilder, so it&#39;s worth exploring that class, too. But the main difference between the two classes is that StringBuilder is thread-safe and what that means is that it can be accessed from multiple threads at once without collisions. However, it achieves that by making no guarantees of synchronization. In other words, if you were trying to append a bunch of text to a StringBuilder from a bunch of different threads all at once, there would be no guarantee of what order those values would go in.</p>
<p>However, the advantage of the StringBuilder over the StringBuffer is that it&#39;s much faster and much more efficient. I personally use StringBuilder all the time. So how would we go about using StringBuilder? Well, the good news is that the StringBuilder class is well known and so it&#39;s built-in just like the non-primitive cousin, String. And that means that in order to use StringBuilder, you don&#39;t have to import any classes or packages. You can just get right to using it.</p>
<p>And just like other non-primitives, you can create an instance by declaring the data type, then giving a variable name, and then after an equal sign, create a new instance of that data type using the new keyword. So you can see in our example here that we&#39;re creating a new StringBuilder named myBuilder. Now, as mentioned, the StringBuilder class allows Strings to be changed, in other words, the Strings are mutable.</p>
<p>So to do that, there are a few methods that are included in the StringBuilder class. Specifically, the append method allows us to add more text to the existing String. The charAt method allows us to find a character in the existing String. The delete method allows us to remove a portion of the String.</p>
<p>The insert method allows us to insert text somewhere in the existing String. The length method allows us to count the number of characters. The replace method allows us to replace a portion of the String with some other text. The reverse method allows us to reverse the order of the String. And finally, the Substring method allows us to pull a portion of the String out into a whole new String. Now it&#39;s important to note that most of the StringBuilder class methods use indexes to understand where to make the changes in the existing String.</p>
<p>And those indexes are always zero-based. So a value of zero means the very beginning of the String. Now, unlike the String class, you can&#39;t create a StringBuilder class by just defining a String literal. You must always use a constructor. In other words, you&#39;ll always have to use the new keyword. And the StringBuilder class has a bunch of constructors that you can use.</p>
<p>For example, you can use the default empty constructor to simply create an instance and then get started. And this is particularly useful ahead of looping algorithms. You can also pass a CharSequence value into the constructor to create a String entry from that. Now if you want to set the initial capacity of a StringBuilder instance, you can do that by calling the constructor that accepts the initial capacity value.</p>
<p>Now, this is useful in cases where you want to keep a close eye on how much text is being allowed into that buffer. And finally, you can create an instance that already has a String in it. To do that, you can use the constructor that includes a String parameter. Now, let&#39;s take a look at an example of how you would use the append method let&#39;s say. In the code snippet we see here, we&#39;re creating an instance of a StringBuilder class.</p>
<p>Then we use a for loop to iterate over a piece of code 10 times. Now, for each index of that loop, we call the append method to add the current index of the loop and a comma to the existing String. So the first time the loop runs, the StringBuilder would be empty and the index would be 0. So after the append, the value of the StringBuilder would be 0, then in the next iteration, the value of StringBuilder would now be seen to be 0, and the index would be 1.</p>
<p>So after that append, the value of the StringBuilder would now be 0,1, and this would go on and on until the loop has finished all 10 iterations. Now once the loop is finished, we can output the value of the StringBuilder to the console. So we get a final output after 10 iterations of 0,1,2,3,4,5,6,7,8,9, not too hard, right?</p></div></div></div><div class="section"><a name="section_12" /><h2 class="section_title">13. Video: Programming the Java StringBuilder Class ( it_sdjcfa_16_enus_13)</h2><img src="https://cdn2.percipio.com/public/b/96a11b64-1803-4031-b1b0-18a13dddf80a/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/96a11b64-1803-4031-b1b0-18a13dddf80a/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. In this demo, you’ll learn the features of the StringBuilder class in Java. You’ll use the work from previous demos to create an instance of a StringBuilder object, and then explore the methods and features available within that object. First, you’ll head to Eclipse IDE and open your project. Next, you’ll create a new class in order to start with a fresh canvas.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the use of the Java StringBuilder class</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming the Java StringBuilder Class. Your host for this session is Sven Batalla.</em> [Video description ends]
<p>In this demo, we&#39;re going to go over the features of the StringBuilder class in Java. To do that, we&#39;re going to piggyback off our previous demo and then create an instance of a StringBuilder object, and then explore the methods and features available within that object. All right. So to do this demo, we&#39;re going to piggyback a bit off our previous demos, which we built in Eclipse.</p>
<p>So let&#39;s head over to the Eclipse IDE now. All right. So as you can see, I already have our project open here. But if you don&#39;t, go ahead and open it now. Now, what we&#39;re going to do in this demo is we&#39;re going to create an instance of the StringBuilder class and then call a few methods to show what we can do with it. And to do that, we&#39;re going to create a new class so that we can start with a fresh canvas.</p>
<p>So the first thing we&#39;re going to do is create that class. To do that in Eclipse, let&#39;s click on the &#34;File&#34; menu and select &#34;New&#34;, &#34;Class&#34;. Perfect. Now in the pop-up, Eclipse is asking us for some information about our class, so let&#39;s just work on the Name. We&#39;re going to call this Builder with a capital B. Good. Now we&#39;ll leave all the defaults alone and leave everything as it is, but we will check the public static void main method stub checkbox and then click &#34;Finish&#34;. [Video description begins] <em>A new Java tab class is created titled Builder.java. Line 1 reads: package demo16;. Line 3 reads: public class Builder {. Line 5 reads: public static void main(String[] args) {. Line 6 reads: // TODO Auto-generated method stub.</em> [Video description ends]</p>
<p>Excellent. We have our class. Now we can finally get started. All right, so now we can get to playing with the StringBuilder. So the first thing we need to do is create an instance of a StringBuilder. So let&#39;s replace the comment in the main method with the following code: [Video description begins] <em>The host deletes the content of line 6 and types.</em> [Video description ends] StringBuilder with a capital S and a capital B space builder &#61; new space StringBuilder, again with a capital S and B, (&#34;Hello with a capital H, &#34;) and a semicolon, good.</p>
<p>Now, unlike the String data type, in order to use the StringBuilder, we must use the new keyword to create a new instance. You can&#39;t set it to a string literal like we can with Strings. Now, just to see that this is working, let&#39;s add a print line command below our new builder object to output its value to the console. So let&#39;s type: system.out.println(builder); Good. Now let&#39;s save this file with a Ctrl S and run it with a Ctrl F11.</p>
<p>Excellent. So in our console output at the bottom of the screen, we can see that the StringBuilder outputs the expected Hello. Nice. Now, the purpose of the StringBuilder class is to help us with manipulating otherwise immutable Strings. Remember that Strings are immutable, which means that they can&#39;t change, while the StringBuilder allows us to actually change the text that it&#39;s managing. So let&#39;s play with the builder a bit. First, let&#39;s make our greeting a bit more personal.</p>
<p>Let&#39;s add our name text. So in the line right below our StringBuilder, let&#39;s add the following code: builder.append( and then &#34; space, your name, &#34;) and ; good. Now let&#39;s save the file and run the project. Hey, look at that! Now our name is being output to the screen with our greeting. Cool. [Video description begins] <em>The text Hello Sven appears in the console.</em> [Video description ends] But it&#39;s worth noting that with the StringBuilder you can actually chain commands.</p>
<p>In fact, let&#39;s go back to our append command and before the semicolon, let&#39;s add this code: .append(&#34;!&#34; and we&#39;ll save that and run the project again. Cool. So now we know that the builder is working just as we want and that chaining works quite well. All right. So that&#39;s appending. [Video description begins] <em>An exclamation mark appears after the text Hello Sven in the console.</em> [Video description ends] But what if we wanted to put some text at the beginning or somewhere in the middle of the String? Well, with the StringBuilder class, you can call the insert method to do that. So let&#39;s try it.</p>
<p>Let&#39;s pretend we wanted to insert a surprised exclamation at the beginning of our greeting. To do that, let&#39;s drop down to the line after our append and type the following code: builder.insert(0, and then in double quotes the word Oh! and a space and then we close the brackets and a semicolon. As you can see, the insert method accepts two parameters. The first parameter is the zero-based index of where to place the new text, and the second parameter is the new text to insert.</p>
<p>It&#39;s important to remember that in Java, indexes are zero-based. So by putting 0 in our command, we&#39;re actually asking for a new text to be inserted right at the beginning of the existing text. Anyway, let&#39;s save the file and run the project. Excellent. Now we&#39;ve added our surprise to the beginning of the String. Nice job. [Video description begins] <em>The console now reads: Oh! Hello Sven!</em> [Video description ends] All right, so we&#39;ve appended text to the end and we&#39;ve inserted text at the beginning, though, we could have put it anywhere.</p>
<p>But what happens if we want to replace text? Well, StringBuilder has us covered there too. To replace some portion of the text, we just need to use the replace method. But be careful, though. This isn&#39;t like a search and replace. You need to know the actual index locations of the text that you want to replace. In fact, let&#39;s add another command here. On the line below our insert, let&#39;s type the following code: builder.replace(4, 9, and then in double quotes, Hi, and then end double quote, );</p>
<p>Good. Now in this case, we&#39;re telling the builder that we want to replace whatever text starts at index 4 and ends at index 9 with Hi,. So we&#39;ve effectively decided that we want to replace our existing Hello with something a little less formal, but also correct a bit of grammar by adding a comma. So let&#39;s save and run this. Perfect. We&#39;ve successfully replaced Hello with Hi. Nice job.</p>
<p>All right. So now let&#39;s say that we feel that our surprise thing at the beginning is goofy and we want to remove it. Well with StringBuilder we can remove text pretty easily. So to do that we&#39;ll use the delete command. So let&#39;s add another line of code after our replace line. Let&#39;s add this code: builder.delete(0, 4);</p>
<p>Good. Now, just like the insert and replace the delete command is accepting index locations for which part of the text to remove. In our case we&#39;re removing the Oh, the exclamation mark and the space that follows it. So let&#39;s save and run this. Nice! Now we&#39;re just left with the Hi and our name.</p>
<p>Now finally, let&#39;s play with one more method of the StringBuilder. Let&#39;s adjust our print line command. Instead of just outputting the contents of the builder, let&#39;s reverse the text. So let&#39;s add the following code after the builder variable, but still inside the brackets: .reverse().</p>
<p>Good, now all this is doing is taking the contents of the builder and reversing the order. So let&#39;s save it and run it. Perfect. Now, our String has been reversed. [Video description begins] <em>The output in the console now appears reversed.</em> [Video description ends] There&#39;s not much left of our original Hello, is there? Anyways, that&#39;s it. That&#39;s the StringBuilder. With this class, you can create and manipulate Strings to your heart&#39;s content. Great job.</p></div></div></div><div class="section"><a name="section_13" /><h2 class="section_title">14. Video: Course Summary ( it_sdjcfa_16_enus_14)</h2><img src="https://cdn2.percipio.com/public/b/7a08d902-0f9c-4cae-9751-25b5bf945d56/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/7a08d902-0f9c-4cae-9751-25b5bf945d56/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll summarize what you’ve learned in the course. In the course, you discovered different data types and how to perform actions on them. You also explored programming Java data types, declaring and initializing Java variables, programming Java data type casting and conversion and using Java Strings and the Java StringBuilder class.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">summarize the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Summary.</em> [Video description ends]
<p>So in this course, we&#39;ve examined data types and how to perform actions on them.</p>
<p>We did this by exploring programming Java data types, declaring and initializing Java variables, programming Java data type casting and conversion and using Java Strings and the Java StringBuilder class.</p>
<p>In our next course, we&#39;ll move on to explore how to create and use methods to manipulate the data inside a class.</p></div></div></div><div class="copyright-container"><span class="copyright-text">© 2022 Skillsoft Ireland Limited - All rights reserved.</span></div></div><div id="lb-overlay"><div class="lb-header"><button onclick="(()=>{const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'hidden';const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 1.0;curtain.style.backgroundColor = 'white';curtain.style.pointerEvents = 'auto';})();">X</button></div><div id="lb-image-container"><img id="lb-image" alt onload="(()=>{const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 0.5;curtain.style.backgroundColor = 'grey';curtain.style.pointerEvents = 'none';const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'visible';window.scrollTo(0, 0);})();"/></div><div class="lb-footer" /></div></div></body></html>