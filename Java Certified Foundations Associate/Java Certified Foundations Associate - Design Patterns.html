<!doctype html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-style-type" content="text/css2"><title>Course Transcript</title><link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css"><style>:root {
    --title-text: #243038;
    --toc-link: #0073C4;
    --section-title-text: #243038;
    --section-title-border: #bababa;
    --grid-caption-text: #164794;
    --grid-border: #c0c0c0;
    --grid-hdr-text: #973131;
    --grid-hdr-background: #f7f7f7;
    --missing-data: #767676;
    --text-color: #343434;
    --lightbox-border: #a0a0a0;

    --bold-font-weight: 700;

    font-family: Lato;
}

.report {
    margin: 24px;
}

.container {
    position: relative;
}

#lb-curtain {
    background-color: white;
    opacity: 1.0;
}

#lb-overlay {
    position: absolute;
    top: 40px;
    left: 20px;
    right: 20px;
    background-color: white;
    border: solid 1px var(--lightbox-border);
    visibility: hidden;
}

.lb-header, .lb-footer {
    height: 40px;
    line-height: 40px;
}

.lb-header {
    display: flex;
    justify-content: flex-end;
    padding-right: 20px;
}

#lb-image-container {
    margin: 0 40px;
}

#lb-image {
    width: 100%;
}

.report_title {
    font-size: 22px;
    font-weight: var(--bold-font-weight);
    color: var(--title-text);
}

.toc_link {
    font-size: 14px;
    color: var(--toc-link);
    margin-top: 6px;
    margin-bottom: 0;
}

.section {
    margin-top: 40px;
    margin-left: 16px;
}

.section.inner {
    margin-top: 20px;
}

.section.inline {
    margin-top: 20px;
    margin-left: 0;
}

.section_title {
    font-size: 18px;
    font-weight: var(--bold-font-weight);
    width: 100%;
    color: var(--section-title-text);
}

h2.section_title {
    border-bottom-color: var(--section-title-border);
    border-bottom-style: solid;
    border-bottom-width: thin;
}

h3.section_title {
    margin: 8px 0;
}

h3.list_title {
    margin: 8px 0;
    font-size: 14px;
    color: var(--title-text);
}

.section_text {
    font-size: 14px;
    color: var(--text-color);
    margin: 12px 0;
    width: 90%;
}

.section_link {
    font-size: 14px;
    margin: 12px 0;
    width: 90%;
}

.grid {
    border-collapse: collapse;
}
.grid_caption {
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    color: var(--grid-caption-text);
    margin: 12px 0;
    text-align: left;
    white-space: nowrap;
}
.grid_hdr_row {

}
.grid_col {
    font-size: 13px;
    color: var(--text-color);
    border-collapse: collapse;
    padding: 2px;
    text-align: left;
    vertical-align: top;
}
.grid_col_hdr, .grid_row_hdr {
    font-size: 12px;
    font-weight: var(--bold-font-weight);
    white-space: nowrap;
}
.grid_row_hdr {

}

.empty_grid {
    border-collapse: collapse;
    border-color: var(--grid-border);
    border-style: solid;
    border-width: 2px;
    padding: 4px;
    text-align: center;
}

.htmlbox {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    padding: 8px;
}

.list {
    font-size: 14px;
    font-style: italic;
}

.missing_data {
    color: var(--missing-data);
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    font-style: italic;
}

.copyright-container {
    margin-top: 24px;
    text-align: center;
}
.copyright-text {
    color: var(--text-color);
    font-size: 12px;
}

/* Transcript Questions CSS */

.question {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    display: flex;
    flex-direction: column;
    padding: 8px;
}

.question_content {
    display: flex;
    justify-content: space-between;
}

.question_details {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.question_images {
    display: flex;
    flex-direction: column;
    margin-left: 16px;
}

.question_image {
    margin-bottom: 8px;
}

.question_title {
    font-weight: var(--bold-font-weight);
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
    padding-bottom: 8px;
    margin-bottom: 8px;
}

.question_label, .question_stem {
    font-weight: var(--bold-font-weight);
    margin-top: 8px;
    margin-bottom: 8px;
}

.question_data_row {
    display: flex;
}

.question_data_col1 {
    padding: 8px;
    white-space: nowrap;
}

.question_data_col2 {
    padding: 8px;
    display: flex;
    flex-direction: column;
}

.question_answer_key {
    margin-top: 8px;
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
}

.feedback {
    font-style: italic;
}
</style></head><body class="report"><div class="container"><div class="content" id="lb-curtain"><h1 class="report_title">Java Certified Foundations Associate: Design Patterns</h1><div class="section_text">While developing software, being able to use repeatable solutions to commonly occurring problems greatly reduces development time. In this course, you will learn how design patterns can be used to provide repeatable solutions to the common design problems.

First, you will learn the importance of design patterns and discuss the types of design patterns such as Behavioral, Creational and Structural. Next, you will write code to demonstrate how to implement the Iterator, Singleton and Adapter design patterns. Finally, you will learn some advanced features of software development, including design anti-patterns, software refactoring techniques, API pattern principles, and API patterns.

This course is one of a collection of courses that prepares learners for Oracle’s 1Z0-811: Java Certified Foundations Associate certification.
</div><div class="section"><h2 class="section_title">Table of Contents</h2><div class="toc"><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_0">1. Video: Course Overview ( it_sdjcfa_05_enus_01)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_1">2. Video: Importance of Design Patterns ( it_sdjcfa_05_enus_02)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_2">3. Video: Behavioral Design Patterns ( it_sdjcfa_05_enus_03)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_3">4. Video: Programming Iterator Design Patterns  ( it_sdjcfa_05_enus_04)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_4">5. Video: Creational Design Patterns ( it_sdjcfa_05_enus_05)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_5">6. Video: Programming Singleton Design Pattern ( it_sdjcfa_05_enus_06)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_6">7. Video: Structural Design Patterns ( it_sdjcfa_05_enus_07)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_7">8. Video: Programming Adapter Design Pattern ( it_sdjcfa_05_enus_08)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_8">9. Video: Design Anti-patterns ( it_sdjcfa_05_enus_09)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_9">10. Video: Software Refactoring for Efficient Programming ( it_sdjcfa_05_enus_10)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_10">11. Video: Software Refactoring Techniques ( it_sdjcfa_05_enus_11)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_11">12. Video: API Pattern Principles ( it_sdjcfa_05_enus_12)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_12">13. Video: API Patterns ( it_sdjcfa_05_enus_13)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_13">14. Video: Course Summary ( it_sdjcfa_05_enus_14)</a></p></div></div><div class="section"><a name="section_0" /><h2 class="section_title">1. Video: Course Overview ( it_sdjcfa_05_enus_01)</h2><img src="https://cdn2.percipio.com/public/b/ab5fb338-1375-4eaf-af90-ea2b9c5e9c0e/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/ab5fb338-1375-4eaf-af90-ea2b9c5e9c0e/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about the course and the instructor. In this course, you’ll learn the importance of design patterns, including Behavioral, Creational, and Structural design patterns. Demonstrations will be performed for the Iterator, Singleton, and Adapter design patterns.</p>
<p>You’ll also learn about design anti-patterns, as well as software refactoring techniques. Finally, you’ll learn API patterns and API resource layout.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">discover the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Overview.</em> [Video description ends]
<p>Hi, I&#39;m Joe Khoury. [Video description begins] <em>Your host for this session is Joseph Khoury. He is an IT/Business Expert.</em> [Video description ends] I&#39;m a Professional Engineer, IT Consultant and Entrepreneur. As a Professional Engineer, I&#39;ve logged over 8,000 hours managing projects. Driven by an entrepreneurial motivation, I have founded and sold two IT-based businesses and have been involved in the E-learning market for the better part of 12 years.</p>
<p>I write for an IT-based E-learning blog and am a published author for the IEEE and will often speak at IT conferences on technology-based subjects globally. Oracle&#39;s 1Z0-811: Java Certified Foundations Associate certification is targeted to audiences seeking foundational knowledge of the Java programming language and concepts.</p>
<p>Individuals tackling this certification will demonstrate that they can write and execute a Java program, work with the Java Development Kit, JDK, and the Java Runtime Environment, JRE. In this course, I will discuss the importance of design patterns, including Behavioral, Creational and Structural design patterns. Demonstrations will be performed for the Iterator, Singleton and Adapter design patterns.</p>
<p>Design anti-patterns will be reviewed, as well as software refactoring techniques. I&#39;ll also cover API patterns and API resource layout.</p></div></div></div><div class="section"><a name="section_1" /><h2 class="section_title">2. Video: Importance of Design Patterns ( it_sdjcfa_05_enus_02)</h2><img src="https://cdn2.percipio.com/public/b/61bed275-9b34-453e-a842-67a39fcd1452/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/61bed275-9b34-453e-a842-67a39fcd1452/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about the importance of design patterns. You’ll learn design patterns are essentially typical software solutions that would normally apply to common problems related to object-oriented software design. Design patterns point to higher-level descriptions of solutions.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the importance of design patterns</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Importance of Design Patterns. Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this video, we&#39;ll consider the importance of design patterns. Design patterns are essentially typical software solutions that we would normally apply to common problems related to object-oriented software design. Design patterns point to higher level descriptions of solutions, not to be confused with algorithms. Both describe typical solutions to some type of known common problems.</p>
<p>And while an algorithm sets out a clear group of actions to achieve some objective, they&#39;re not the same. Again, a pattern is typically a higher level description of a solution for example, you can apply the same pattern to different programs and it&#39;s possible that the code for each one is quite different. The pattern does not represent a specific set of code, rather it&#39;s a broad concept geared towards solving a particular type of problem.</p>
<p>Each design pattern is a blueprint that is fully customizable to solve a design problem specific to our program or in a different context. In fact, design patterns have been described very succinctly as a solution to design problem in context. So solution, problem, context. Design patterns are very important, and because of that, you&#39;ll find that most patterns are described in a very formal way, opening the door to others to reproduce them in different contexts.</p>
<p>Typical sections used to formalize a pattern description include the intent of the pattern. The intent provides a brief description of both problem and solution and answers the question: what problem does the pattern address? For example, the Singleton design pattern solves problems like: how can we ensure that a class only has one instance? And how can the solitary instance of a class be accessed globally?</p>
<p>The motivation section explains the problem and solution, typically by using a scenario that illustrates the problem is the motivation behind the pattern. The next section, the structure of classes, displays each component of the pattern and how they are all related. In a formal description, this is typically a diagram using object modeling technique or OMT.</p>
<p>Then, of course, there is the code example, and you&#39;ll typically find these in one of the more common programming languages, including Java. The code examples are awesome for helping illuminate the concept behind the pattern. You may also find other helpful details in some pattern catalogs discussing implementation steps, the relationship amongst patterns, as well as other details.</p>
<p>So we&#39;ve established that patterns are typical solutions to common problems in object-oriented software design. But where do they come from? Solutions usually get applied over and over in different projects and in different contexts. Eventually, someone decides to give it a name and describe the solution in detail. But the concept of pattern language was itself first described in a book about a language for designing the urban environment.</p>
<p>That was the concept that inspired four authors known as the Gang of four. Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm. In 1994 they published Design Patterns: Elements of Reusable Object-Oriented Software. And it was in this book that they applied the concept of design patterns to object-oriented design. The original book featured 23 patterns solving various problems related to object-oriented design.</p>
<p>Other object-oriented patterns have been discovered since then. Now, why are patents important? Even if you weren&#39;t aware of specific patterns, the fact is that you may already be applying one because a design pattern is just that. It&#39;s a pattern. And, you know, even from personal experience, I&#39;ve applied several specific patterns before knowing and acknowledging that they even existed, as it were. Why would patterns be considered important if, for example, you&#39;re already unwittingly applying them?</p>
<p>The thing is, until formally recognized and documented, a design pattern isn&#39;t formally recognized and documented. The act of formally recognizing and documenting solutions lends credibility to the solution. In fact, design patterns can be seen as another tool in your developer&#39;s toolkit, a collection of tried, tested and proven solutions to common problems in software design. And they just work.</p>
<p>Even if you never encounter problems associated with some patterns, understanding patterns is still valuable, since it teaches one how to solve many different types of problems using object-oriented design principles. Design patterns enhance communication amongst developers as design patterns define a common language to describe solutions to problems within a specific context.</p>
<p>Basically, patterns enable us to communicate more efficiently and effectively. For example, you could just say to a developer on your team: use an iterator for that, and you know that the concept behind a suggestion is understood. You needn&#39;t explain what the iterator is about, if you both know the pattern and the name. All patterns can be grouped or categorized by their intent, their purpose.</p>
<p>We have three main groups of patterns: we have creational patterns, which are concerned with object-creation mechanisms that improve the flexibility and reuse of existing code. We have structural patterns which explain how to assemble objects and classes to create larger structures, while at the same time ensuring that the structures are flexible and efficient.</p>
<p>And finally, we have behavioral patterns and these focus on the interaction between objects promoting effective communication and assignment of responsibilities amongst objects. Those who choose not to use patterns, ironically follow a specific pattern of beliefs. For example, some detractors of patterns say that patterns are just so much duct tape to fix up a weak programming language.</p>
<p>This is not entirely untrue. The need for patterns typically surfaces when a programming language or technology does not supply the necessary level of abstraction. Some patterns are just overused when, in fact, simpler, more performant solutions are available.</p>
<p>And since patterns essentially formalize approaches that are already widely used, patterns can be used incorrectly by developers when they steadfastly stick to a specific pattern blueprint without taking into account the fact that they should probably adapt it to their own specific context.</p>
<p>And then there is just unwarranted use of some patterns. Many beginners and novices who&#39;ve become acquainted with patterns may be tempted to apply them everywhere.</p>
<p>This is not advisable because there are situations where simpler code is the optimum solution.</p></div></div></div><div class="section"><a name="section_2" /><h2 class="section_title">3. Video: Behavioral Design Patterns ( it_sdjcfa_05_enus_03)</h2><img src="https://cdn2.percipio.com/public/b/a45c5969-502d-489a-94c8-d01a057326f0/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/a45c5969-502d-489a-94c8-d01a057326f0/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about Behavioral Design Patterns. You’ll learn that Behavioral Design Patterns are concerned with the interactions between objects. Behavioral patterns promote effective communication and assignment of responsibilities amongst objects. With Behavioral Design Patterns, the interaction between objects is designed so that objects can easily talk to each other and still remain loosely coupled, which means the implementation and the client are loosely coupled.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe what are Behavioral design patterns and discuss implementations of these design patterns</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Behavioral Design Patterns. Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this video, we&#39;ll explore Behavioral Design Patterns. Behavioral Design Patterns are concerned with the interactions between objects. Behavioral patterns promote effective communication and assignment of responsibilities amongst objects. With Behavioral Design Patterns, the interaction between objects should be designed such that objects can easily talk to each other and still remain loosely coupled, which essentially means that the implementation and the client are loosely coupled.</p>
<p>We must avoid hard coding and dependencies. The first Behavioral Design Pattern we&#39;ll look at is Chain of Responsibility. This pattern allows us to pass requests to a chain of request handlers. When receiving a request, each respective handler chooses either to process the request or to pass it to the next handler in the Chain of Responsibility. Next is the Command pattern.</p>
<p>This pattern allows us to take a request and transform it into an object encapsulating all the information about that request. We can use this pattern to parameterize clients and perform some actions, for example, cueing or delaying the execution of a request. Next, the Mediator pattern allows us to effectively diminish the chaotic dependencies that exist between objects. Basically, this pattern restricts direct interaction between objects and instead forces objects to collaborate via a mediator object only.</p>
<p>And the Iterator pattern sets up the traversal over the elements of an object, but without exposing its underlying representation or structure, be it list, stack, tree or what have you. Next, the Memento pattern. This allows us to save and restore the state of an object without exposing the details of the object&#39;s implementation. The Observer pattern allows us to define a subscription-based process, which allows an object to notify observers of any state changes that occur.</p>
<p>And the Interpreter pattern basically defines how to represent the grammar of a language, and includes an interpreter that can use that representation to interpret sentences in that language. The Template method is a Behavioral Design Pattern used to define the skeleton of an algorithm in an operation with some steps being deferred to subclasses. The Template method allows subclasses to redefine some steps of an algorithm without altering the structure of the algorithm.</p>
<p>The State pattern allows an object to change its behavior when the object&#39;s internal state changes. This gives the appearance that the object changed its class. Basically the State pattern solves the problem: how can we make behavior dependent on state. And the Strategy pattern. This allows us to define a set of algorithms that may be used interchangeably. The Strategy pattern allows the algorithm to vary independently of clients using it.</p>
<p>In essence, this pattern defers the decision about which algorithm to use until runtime. And this in turn means the calling code can be designed to be more flexible and reusable. The Visitor pattern allows us to isolate algorithms from the objects that they operate on. As a result, new operations may be added to existing object structures without altering the structures themselves.</p>
<p>And the Null object pattern describes the uses and behaviors of Null objects. Rather than using a Null reference to signify the absence of an object, the Null object pattern uses an object which implements the expected interface, but the method&#39;s body is empty.</p>
<p>One of the main advantages of this type of approach is that a Null object becomes predictable, it does nothing, and hence it can have no side effects. In summary, then, Behavioral Design Patterns are focused on the interactions between objects, and behavioral patterns promote effective communication as well as the assignment of responsibilities amongst objects. And with Behavioral Design Patterns, the interaction between objects is designed so that it&#39;s loosely coupled, and that means that the implementation and the client should also be loosely coupled, avoiding hard coding and dependencies.</p></div></div></div><div class="section"><a name="section_3" /><h2 class="section_title">4. Video: Programming Iterator Design Patterns  ( it_sdjcfa_05_enus_04)</h2><img src="https://cdn2.percipio.com/public/b/c3370126-9670-4d53-ab7a-ced96f4ce0cd/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/c3370126-9670-4d53-ab7a-ced96f4ce0cd/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. In this demo, we&#39;ll implement an Iterator design pattern. First, you’ll open IntelliJ and find the project named BehavioralPatterns. You’ll see the base package is com.local.iterator. You’ll find IteratorDemo and import Iterator from java.util.</p>
<p>You’ll find an instance of a class called CourseRepository. That instance is called repository. Next, you’ll add courses. </p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">create the Iterator design pattern</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Iterator Design Patterns . Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this demo we&#39;ll implement an Iterator design pattern. To start my demo, I&#39;ve opened IntelliJ and I have a project named BehavioralPatterns open. The base package here is com.local.iterator, so that&#39;s where I&#39;m developing this Iterator implementation. OK, so first, IteratorDemo. On line 3, I import Iterator from java.util.</p>
<p>And then on line 9, this is where I&#39;m getting an instance of a class called CourseRepository, and that instance is called repository, so that&#39;s on line 9. Now, on line 11, I&#39;m just printing out a message saying: let&#39;s add some courses, then lines 12 through 15 I&#39;m calling the addCourse method to add courses to the repository. Now on line 17, this is where I&#39;m getting an instance of the Iterator.</p>
<p>Then line 19, I&#39;m printing out a message indicating: let&#39;s iterate over the courses. So I have two messages here that I want to use to separate out what I&#39;m doing. So first, I&#39;m adding courses. Before I add the courses again on line 11, I&#39;m printing out a message. But then again, when I iterate over the courses, after adding them all and using the Iterator, I want to print out a message indicating that we&#39;re going to iterate over the courses.</p>
<p>So on line 20, the conditional statement is calling the hasNext method on the courseIterator. This is testing the condition that we&#39;re at the end of the collection. Further on down in the code from lines 24 through 26, I&#39;m using a for-each loop to demonstrate how convenient it is to be able to iterate over a collection with a for-each loop. Now over in CourseRepository. [Video description begins] <em>The host clicks on the second tab called CourseRepository.java.</em> [Video description ends]</p>
<p>Again, importing java.util.Iterator, but then on line 5, we&#39;re implementing the iterable interface. Upon implementation of an interface, we override all of its methods. I do that later on down in the code, so we&#39;ll have a look shortly. Lines 7 and 8, I set up variables to work with. [Video description begins] <em>Line 7 reads: private String [] courses;. Line 8 reads: private int index;.</em> [Video description ends] Then on line 10, I&#39;m initializing the CourseRepository with a default size and index. [Video description begins] <em>Line 10 reads: public CourseRepository () {. Line 11 reads: courses &#61; new String [0]; and line 12 reads index &#61; 0;.</em> [Video description ends] Then from lines 15 down through 25, this is the addCourse method. It&#39;s passed in a course, then a conditional statement on line 16 looks to see if we&#39;re at the end of the course&#39;s array.</p>
<p>And if we are, then we&#39;ll add a new item by defining a new array. And I do that on line 18. The new array is named moreCourses and it&#39;s an array of String values , and its length is the length of the original courses array &#43; 1, for the course we&#39;re going to add. It has a length of 0. We&#39;re going to add 1 to it, so it&#39;s going to have a length of 1. And that 1 will be the course that&#39;s passed in to the addCourse method here.</p>
<p>Now we can conveniently use arraycopy, we&#39;re doing that on line 19, to copy the arrays. So basically, it&#39;s a way to recreate the old courses array with the new course that is temporarily stored in moreCourses. So that&#39;s why in line 20, I set courses back to the larger moreCourses. Then I set what was the temporary moreCourses array to null.</p>
<p>Then on line 23, I set the element in the courses array at the index value to the value of course that was passed in to the addCourse method. Then on line 24, I increment the index after the operation. Line 27 starts the overrides. So we override the iterator method, the hasNext method, and the next method.</p>
<p>On line 29, I&#39;m creating an instance of an Iterator. And this Iterator will be passed back to the calling program to allow it to iterate over this collection. The hasNext method on line 34 returns a true or false based on the currentIndex. So if the currentIndex is less than the length of the current courses array, that means that it does have a next element.</p>
<p>Then on line 39, the definition of the next method, which just returns the element at courses at the currentIndex and then after that operation, increments currentIndex. So that&#39;s why the &#43;&#43; after the currentIndex. And then on line 43, returning the Iterator.</p>
<p>All right, so let&#39;s go ahead and try this out. I&#39;ll select Run in the toolbar. Now, I&#39;ll resize the console area so that we can access the full output. [Video description begins] <em>The host clicks on the line that separates the bottom from the top view and drags it upwards to enlarge the bottom view.</em> [Video description ends] The message appears: First, let&#39;s add some courses: then four courses are added, then another message: Now let&#39;s iterate over the courses: so at this point, the collection has values in it.</p>
<p>So it should output the exact same courses that it output while it was adding them. And it does. So now let&#39;s go back to the IteratorDemo. [Video description begins] <em>The host drags down the bottom view to make the upper view visible again and returns to the first tab: IteratorDemo.java.</em> [Video description ends] And take a look at lines 19 through 22. So in lines 19 through 22, we have the Now let&#39;s iterate over the courses message, And then the Iterator iterated over the collection using hasNext to determine if it&#39;s at the end of the collection.</p>
<p>And then with each iteration on line 21 prints the value of the collection item that is represented by courseIterator.next. Now we can do the same thing with the for-each loop. However, I won&#39;t get a second message indicating: Now let&#39;s iterate over the courses. So that&#39;s a good test. We should see if it&#39;s different. So I&#39;ll highlight lines 19 through 22, Ctrl forward slash to comment them out.</p>
<p>Now I&#39;ll highlight lines 24 through 26 Ctrl forward slash to uncomment them. Now, I&#39;ll select Run from the toolbar again. Now, I&#39;ll resize the console again so we can access the full output. And sure enough, there&#39;s the first message. Then the four items being added, and then this time we don&#39;t have the header indicating that: Now let&#39;s iterate over the collection. But it did output the elements in the collection. And so with that, we&#39;ve successfully implemented an Iterator pattern.</p></div></div></div><div class="section"><a name="section_4" /><h2 class="section_title">5. Video: Creational Design Patterns ( it_sdjcfa_05_enus_05)</h2><img src="https://cdn2.percipio.com/public/b/ca8b54b9-17fb-4e04-be95-a787e0bd12cc/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/ca8b54b9-17fb-4e04-be95-a787e0bd12cc/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn about Creational Design Patterns. You’ll learn Creational patterns provide various mechanisms concerning the creation of objects. One benefit is increased flexibility as well as code reuse. You’ll discover these patterns are focused on how objects are created. Creational patterns are used when a decision must be made during the process of instantiating a class or during the creation of an object of a specific class.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe what are Creational design patterns and discuss implementations of these design patterns</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Creational Design Patterns. Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this video, we&#39;ll explore Creational Design Patterns. Creational patterns provide various mechanisms concerning the creation of objects. One benefit is increased flexibility as well as code reuse. So, these patterns then are focused on how objects are created. Creational patterns are used when a decision must be made during the process of instantiating a class or during the creation of an object of a specific class.</p>
<p>In Java, an object is typically created using the new keyword. With Creational patterns, rather than instantiating objects directly using the new keyword, we can create objects in a more flexible way, deciding which objects are required for a particular use case while at the same time hiding their creation logic. The first pattern that we&#39;ll discuss is the Singleton pattern. The Singleton pattern is one of the simplest design patterns in Java. This pattern involves using a single class whose responsibility is to create a sole instance.</p>
<p>That&#39;s one single instance of an object. With this pattern, a class must ensure that only a single instance is created and further that it can be used by all other classes. In other words, that it&#39;s globally accessible. There are two forms of Singleton Design Pattern. First, lazy loading or lazy instantiation, which defers creation of an instance until such time that it&#39;s required.</p>
<p>And then there is early instantiation or eager loading, which involves the creation of an instance at load time. This carries with it a performance hit, particularly on larger systems, where you could have as many as thousands of instantiations at load time. Next, the Prototype Creational Design Pattern provides a way for us to copy existing objects without making our code dependent on their classes.</p>
<p>The Prototype pattern effectively delegates the process of cloning to the objects that are being cloned themselves. The pattern declares a common interface for all objects that support cloning. The common interface allows us to clone an object while managing to keep our code decoupled from the class of that object. Typically, an interface like this contains a sole cloning method.</p>
<p>In all classes, the implementation of the clone method goes something like this: the method creates an object of the current class and then brings all the old objects&#39; field values over to the new one. An object supporting the cloning process is known as a Prototype. When objects have several fields and large numbers of possible configurations, cloning them may in fact be the most effective and efficient approach to creation, rather than subclassing.</p>
<p>The Factory Design Pattern provides an interface for creating objects in a superclass, but it allows subclasses to alter the type of objects to be created. In the Factory pattern, we can create an object without exposing its creation logic. The new object can be accessed using a common interface.</p>
<p>The factory method provides an approach for replacing direct calls to constructors using the new operator with calls to a special factory method. Under the hood, the objects are still created via the new operator, but the new operator&#39;s called from within the factory method itself. Objects returned by a factory method are typically called products. The Abstract Factory is a pattern that allows us to create families of related objects, but without the need to specify their respective concrete classes.</p>
<p>Abstract Factory patterns represent a type of super factory which effectively creates other factories. This is why it&#39;s also known as a factory of factories. An interface is responsible for creating a factory of related objects, deferring the instantiation to subclasses. The Abstract Factory pattern is typically used when you want to group a collection of factories together. The Builder pattern lets us construct complex objects in a step-by-step fashion.</p>
<p>This pattern allows us to create different types and representations of objects using the same constructor. The builder pattern proposes that the object construction code be extracted out of its own class and moved to separate objects known as builders. The pattern organizes the construction of an object into a set of steps. To create an object, you simply execute a series of steps on a builder object.</p>
<p>One important thing to note about Builder Design Pattern is that you needn&#39;t call all of the creation steps. Instead, you can call only those steps that are required to produce a specific configuration that you&#39;re looking for. It is possible that some of the construction steps may require different implementations to build various representations of a product. In this scenario, we can create several different builder classes that use the same set of building steps, but in a different manner.</p>
<p>We can then use these different builder classes to produce different types of objects. In software design, performance is typically one of, if not the key issue. And object creation can be a costly step. The intent of the Object Pool pattern is to reuse objects that are typically expensive to create. An Object Pool is essentially a container holding a specified number of objects.</p>
<p>When an object is borrowed from the pool, it won&#39;t be available in the pool again until it&#39;s put back. Thus, objects in the pool have a specific life cycle: creation, validation, and destruction. A pool can help manage available resources in a more efficient way. But the main advantage of the Object Pool Design Pattern is that it boosts application performance considerably, and it&#39;s most effective in scenarios with a high rate of initialization.</p></div></div></div><div class="section"><a name="section_5" /><h2 class="section_title">6. Video: Programming Singleton Design Pattern ( it_sdjcfa_05_enus_06)</h2><img src="https://cdn2.percipio.com/public/b/e685df53-30c0-4f14-baa7-287615b78c9e/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/e685df53-30c0-4f14-baa7-287615b78c9e/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. You’ll learn to implement the Singleton design pattern. To get started, you’ll open IntelliJ. On the Welcome to IntelliJ screen, select &#34;New Project&#34;, and then select &#34;Next&#34;. Then, check the Create project from the template checkbox, and select &#34;Next&#34;. You’ll specify the Project name, and name the project CreationalPatterns.</p>
<p>You’ll then select &#34;Finish&#34;. Now, IntelliJ will prepare your workspace and load the project. </p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">create the Singleton design pattern</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Singleton Design Pattern. Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this demo, I&#39;ll implement the Singleton design pattern, OK, to get started, I&#39;ve opened IntelliJ. Now on the Welcome to IntelliJ screen, I&#39;ll select &#34;New Project&#34;, I&#39;ll select &#34;Next&#34;, now, I&#39;ll check the Create project from template checkbox, select &#34;Next&#34;, now I&#39;ll specify the Project name, I&#39;ll call this project CreationalPatterns, and note that Base package is already filled in for me.</p>
<p>Now this is filled in only because I&#39;ve already created a Singleton and I had it in this Base package. So IntelliJ remembered that and filled the Base package for me. So I&#39;m just going to leave it and select &#34;Finish&#34;. And now IntelliJ prepares my workspace and loads the project. And the Main.java file is opened in the Editor. OK, so over in the Project tree, I&#39;ll expand the Project. Then src. Then I&#39;ll right click the Base package, point to New and select &#34;Java Class&#34;. In the New Java Class dialogue for the name, I&#39;ll specify MySingleton, press Enter.</p>
<p>And now I have the shell of MySingleton class. OK, so let&#39;s press Enter a couple of times to create some space in MySingleton class. OK, and on line 5, I&#39;ll enter a comment about early loading an instance. Then on line 6, I&#39;ll use private static MySingleton instance &#61; new MySingleton(); so this will instantiate a new instance for me.</p>
<p>Now, I&#39;ll press Enter a couple more times. And now on line 8, I&#39;ll specify a private constructor. So that&#39;s private MySingleton(). OK, and now I&#39;m creating this private constructor here so that no one will be able to create new instances of this class. Now essentially, because we define this private constructor like this, the new keyword won&#39;t be available to create another instance. We can later on return the instance to the calling class when the getInstance method is invoked.</p>
<p>Now, I&#39;ll press Enter a couple more times and now I&#39;ll specify a public getInstance method. And this is going to allow me to maintain control over how I want to return the Singleton. [Video description begins] <em>The host types public static MySingleton getInstance() in line 10.</em> [Video description ends] Now we&#39;re going to use the conventional getInstance method, which is standard when implementing a Singleton. This just returns the instance created earlier on line 6. [Video description begins] <em>The host types return instance; in line 11.</em> [Video description ends] OK, now let&#39;s select the Main.java tab.</p>
<p>Now, over in the Project tree, I&#39;ll right click &#34;Main&#34;, my Main class, I&#39;ll point to Refactor, select &#34;Rename&#34;, and I&#39;ll specify MySingletonDemo to Rename this class and I&#39;ll select &#34;Refactor&#34;. And done. OK, so now I have MySingletonDemo class. So I&#39;ll highlight the comment: write you code here on line 6, and now I&#39;ll start writing my code. So first, let&#39;s just see if I can use the new keyword to create a new instance of the MySingleton class.</p>
<p>And notice that MySingleton is underlined in red. [Video description begins] <em>The host types MySingleton instance &#61; new MySingleton(); in line 6.</em> [Video description ends] If I hover over MySingleton, the information pop-up tells me that &#39;MySingleton()&#39; has private access in &#39;com.local.singleton.MySingleton&#39;. OK, so now let&#39;s backspace over that, and now I&#39;ll just specify MySingleton.getInstance(); so I&#39;m going to call the getInstance method from here. Now, I&#39;m going to output that, so I&#39;ll type System.out.println(instance); on line 7, press Enter a couple more times, then on line 9, I&#39;ll specify a comment about grabbing another instance.</p>
<p>So I want to grab another instance to see if we get the same instance of the Singleton back. So I&#39;ll type MySingleton newInstance &#61; MySingleton.getInstance(); All right, so a new instance. And now I&#39;ll print that out. System.out.println(newInstance); Now, I&#39;ll right click &#34;main&#34;, select Run. And now in the console the System.out.println printed the object to the console for both instance and newInstance, and note that they&#39;re identical.</p>
<p>Now, we&#39;ve been successful to this point creating the Singleton pattern, but it&#39;s early loaded and I want it to be lazily loaded. So let&#39;s go back into MySingleton. [Video description begins] <em>The host clicks on the MySingleton.java tab.</em> [Video description ends] And now on line 6. Basically, I want to lazy load the newInstance, so I&#39;ll change my comment on line 5, and then on line 6 I&#39;ll backspace over new MySingleton() and specify and now down in the getInstance method, I need to handle the fact that this is now a lazily loaded instance.</p>
<p>So I&#39;ll type if(instance &#61;&#61; null) then I&#39;ll specify instance equals new MySingleton, right? We&#39;ll create a new Singleton. if it&#39;s null obviously one doesn&#39;t exist. If it does exist, then it&#39;s not null, so I&#39;ll just return that instance. OK, so now I&#39;ll right click main again, over in MySingletonDemo. I&#39;ll select Run &#39;Main&#39; from the context menu, and the output to the console again confirms the fact that we have one instance. All right, so we&#39;ve successfully implemented a Singleton design pattern.</p></div></div></div><div class="section"><a name="section_6" /><h2 class="section_title">7. Video: Structural Design Patterns ( it_sdjcfa_05_enus_07)</h2><img src="https://cdn2.percipio.com/public/b/c3ce5869-426d-42a6-a959-d81f40e45617/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/c3ce5869-426d-42a6-a959-d81f40e45617/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn about Structural Design Patterns. You’ll learn that Structural Design Patterns describe how to assemble objects and classes into larger structures, while at the same time managing to keep these structures flexible and efficient. In other words, Structural Design Patterns are focused on how classes and objects can be composed to form larger structures.</p>
<p>You’ll learn Structural Design Patterns can simplify structures by identifying relationships. </p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe what are Structural design patterns and discuss implementations of these design patterns</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Structural Design Patterns. Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this video, we&#39;ll explore Structural Design Patterns. Structural Design Patterns describe how to assemble objects and classes into larger structures, while at the same time managing to keep these structures flexible and efficient. In other words, Structural Design Patterns are focused on how classes and objects can be composed to form larger structures.</p>
<p>The Structural Design Patterns can simplify structures by identifying relationships, and the patterns themselves are concerned with the way that classes inherit from each other and how they are composed using other classes. First, let&#39;s consider the Adapter pattern. This pattern provides a way for objects with incompatible interfaces to collaborate.</p>
<p>You can create an adapter which is a special object that converts the interface of one object so that another object can talk to it. An adapter wraps one of the objects in order to hide the complexity of conversion, and the wrapped object doesn&#39;t even necessarily have to be aware of the adapter.</p>
<p>For example, we could wrap an object that works with imperial measurements like cups, quarts, ounces and so on, with an adapter that converts all of the data to metric like milliliters, liters, grams and kilograms. Sometimes, as in the example I just cited, it&#39;s possible to create a two-way adapter that can convert the calls in both directions.</p>
<p>A bridge is a Structural Design Pattern that can be used to split a large class or a group of closely related classes into two separate hierarchies: abstraction and implementation, and these can be developed independently of each other. A Bridge pattern can be used to decouple functional abstraction from implementation, such that these two separate hierarchies can vary independently.</p>
<p>The Bridge pattern, therefore, enables the separation of implementation from the interface, which improves extensibility, and can hide implementation details from the client. Next is the Composite Design Pattern, and this pattern allows us to compose objects into tree structures and then allows us to work with these structures as if they were individual objects.</p>
<p>A Composite pattern defines class hierarchies that contain primitive and complex objects, and they make it easier to add new kinds of components and provide structural flexibility with a manageable class or interface. The Decorator Structural Design Pattern lets us attach new behaviors to objects by placing them inside special wrapper objects that themselves contain the desired behaviors.</p>
<p>Extending a class is typically the most common approach to altering an object&#39;s behavior, but inheritance is not perfect. Inheritance is static. That is, you cannot change the behavior of an existing object at runtime. One can only replace the object itself with another one created from a different subclass altogether. Subclasses may also only have a single parent class. In most languages, inheritance won&#39;t allow classes to inherit behaviors from multiple other classes at the same time.</p>
<p>One way to overcome these limitations is by using aggregation or composition, rather than inheritance. Aggregation and composition work almost identically. One object has a reference to another, and delegates some work to it. To summarize, with this pattern, an object can use the behavior of various classes, has references to multiple objects and can delegate various kinds of work to them. And the Facade pattern.</p>
<p>This Structural Design Pattern provides a simplified interface to a library, a framework or any other complex group of classes. Basically a Facade is a class that offers a simple interface to a complex subsystem, typically containing a lot of moving parts. [Video description begins] <em>A diagram displays on-screen. It shows a Client that&#39;s using the Facade and the Facade then is connected to its subsystem containing Class A and Class B. Class B is connected to Class C. On the right of the screen, there is a Library and a Framework.</em> [Video description ends] Although a Facade may actually provide limited functionality, when compared to working with the subsystem directly, it only includes those features that clients actually care about.</p>
<p>A Facade is particularly helpful in situations where you need to integrate an app with a complex, sophisticated library having a large number of features. But you only need a handful of those features. The Flyweight pattern allows one to fit more objects into available RAM. And this is accomplished by sharing common components of state, between multiple objects rather than storing all the data in each object.</p>
<p>The Flyweight pattern proposes to stop storing extrinsic state inside the object. Instead, this state is better passed to specific methods that rely on it. Only the intrinsic state should reside within the object, allowing us to reuse it in different contexts.</p>
<p>Consequently, we&#39;d require fewer of these objects because they differ only in their intrinsic state, which has far fewer variations than extrinsic state. Proxy. Proxy is a design pattern, whose intent is to provide a substitute or placeholder for another object. A proxy has control over access to the original object, allowing one to perform some action either before or after the request is made against the original object.</p>
<p>The Proxy pattern proposes that a new proxy class be created with an identical interface to the original service object. Then the app is updated so that it passes the proxy object to each one of the original object&#39;s clients. When a request from a client is received, the proxy creates a real service object and subsequently delegates all the work to the service object.</p>
<p>The benefit here is that if you need to execute something either before or after the primary logic of the class is encountered, the proxy can accomplish this without changing that class. Because the proxy implements the identical interface as the original class, it can be passed to any client expecting a real service object.</p></div></div></div><div class="section"><a name="section_7" /><h2 class="section_title">8. Video: Programming Adapter Design Pattern ( it_sdjcfa_05_enus_08)</h2><img src="https://cdn2.percipio.com/public/b/9fe77a2c-438e-417b-8fb0-6e903d8d3aaf/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/9fe77a2c-438e-417b-8fb0-6e903d8d3aaf/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll watch a demo. In this demo, you&#39;ll implement the Adapter design pattern. You’ll remember the Adapter pattern works as a bridge between two incompatible interfaces. You’ll open your project in IntelliJ. You’ll look at the file, Client class. This class will act as a Client to complete the demo.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">create the Adapter design pattern</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Adapter Design Pattern. Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this demo we&#39;ll implement the Adapter design pattern. Recall that the Adapter pattern works as a bridge between two incompatible interfaces. In this scenario, we have a client that works in imperial measurements but we work in metric. We want to be able to interface with the client so that they can purchase wine in bulk from our store.</p>
<p>Now, we could change the app, but the point of the demo is to show how we can work with incompatible interfaces. So we&#39;ll assume for the sake of this demo that we cannot alter the client system and we want to maintain our own system as it is, because it&#39;s integrated into several other client systems. And we don&#39;t want to risk breaking something when a quick and easy adapter pattern will do the job.</p>
<p>Here in IntelliJ I&#39;ve got my project open. Now the first file to look at is the Client class. Now, this class simply is going to act as a Client to complete the demo. All the work here takes place on lines 6 and 7, [Video description begins] <em>The host is at the Client.java tab. Line 1 reads package com.local.adapter;. Line 3 reads public class Client {. Line 5 reads public static void main(String[] args) {. Line 6 reads WineInGallonsInterface adapterInterfaceClass &#61; new WineInGallonsImplClass();. Line 7 reads: adapterInterfaceClass.purchaseWineInGallons(quantityInGallons: 10);. Lines 8 and 9 both read }.</em> [Video description ends] where we&#39;re grabbing an instance of the WineInGallonsImplClass and then we&#39;re calling the purchaseWineInGallons method.</p>
<p>OK, so now, [Video description begins] <em>The host is at the Wine.java tab. Line 1 reads package com.local.adapter;. Line 3 reads public class Wine {. Line 4 reads private double winePrice;. Line 6 reads public Wine(double quantityLitres) {. Line 7 reads this.winePrice &#61; quantityLitres * 19.99;. Line 8 reads System.out.println(&#34;Your wine order today is &#34; &#43; winePrice &#43; &#34; USD.&#34;);. Line 9 reads System.out.println(&#34;Thank -you for your order!&#34;);. Lines 10 and 12 read}.</em> [Video description ends] the Wine class is a functional class that calculates the price of the Wine.</p>
<p>Now it calculates this price based on litres, so that&#39;s why we&#39;re going to implement the Adapter design pattern. OK, carrying on. The WineInLitresInterface is an adaptee interface. [Video description begins] <em>The host is at the WineInLitresInterface.java tab. Line 1 reads package com.local.adapter;. Line 3 reads public interface WineInLitresInterface {. Line 5 reads public Wine purchaseWine(double quantityLitres);. Line 6 reads }.</em> [Video description ends]</p>
<p>The adapter class converts the incompatible interface of the class, the adaptee, into another interface that the target client requires. Now, the WineInLitres class is an implementation of the adaptee interface. [Video description begins] <em>The host is at the WineInLitres.java tab. Line 1 reads package com.local.adapter;. Line 3 reads public class WineInLitres implements WineInLitresInterface {. Line 5 reads public Wine purchaseWine(double quantityInLitres) {. Line 6 reads System.out.println(&#34;Purchasing &#34; &#43; quantityInLitres &#43; &#34; litres of Wine&#34;);. Line 7 reads return new wine(quantityInLitres);. Lines 8 and 10 read}.</em> [Video description ends]</p>
<p>On line 3, this class implements the WineInLitresInterface. Now, in the WineInGallonsInterface, this is the target interface. [Video description begins] <em>Line 1 reads package com.local.adapter;. Line 3 reads public interface WineInGallonsInterface {. Line 4 reads public Wine purchaseWineInGallons(double quantityInGallons);. Line 5 reads }.</em> [Video description ends]</p>
<p>This is the interface that the client wants to target, and then we have WineInGallonsImplClass. This class extends the WineInLitres class and it implements the WineInGallonsInterface. [Video description begins] <em>Line 1 reads package com.local.adapter;. Line 3 reads public class WineInGallonsImplClass extends WineInLitres implements WineInGallonsInterface {. Line 4 reads public Wine purchaseWineInGallons(double quantityInGallons) {. Line 5 reads double quantityInLitres &#61; convertGallonstoLitres(quantityInGallons);. Line 6 reads return purchaseWine(quantityInLitres);. Line 7 reads }. Line 8 reads private double convertGallonstoLitres(double gallonQuantity) {. Line 9 reads return gallonQuantity * 3.79;. Lines 10 and 11 read }.</em> [Video description ends] So it&#39;s here that we actually do the conversion. So, yes, this is a very simple example, but it does the job because what we&#39;ll see is that we&#39;ll be able to specify gallons.</p>
<p>So over to my Client class on line 7, we&#39;re setting up to purchase 10 gallons of Wine. OK, so let&#39;s run this and see what happens. So I&#39;ll click to Run icon on the toolbar. All right, so. The application told us that we&#39;re purchasing around 38 litres of Wine, that the order today is 757 dollars and 62 cents roughly. I didn&#39;t bother to round off this dollar figure. And then we thank the customer for their order. OK, so we successfully implemented the Adapter design pattern.</p></div></div></div><div class="section"><a name="section_8" /><h2 class="section_title">9. Video: Design Anti-patterns ( it_sdjcfa_05_enus_09)</h2><img src="https://cdn2.percipio.com/public/b/f82de4a4-751b-46ab-80cc-18ac1339d5d7/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/f82de4a4-751b-46ab-80cc-18ac1339d5d7/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn about Design Anti-patterns. You’ll learn anti-patterns are similar to design patterns. An anti-pattern describes a common solution to a problem, but that solution generates negative consequences. Anti-patterns are sometimes the result of managers or developers not knowing any better, or they could result from developers lacking sufficient knowledge or experience to solve a specific type of problem. Anti-patterns can result from managers or developers applying an excellent design pattern incorrectly.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe and review different types of design anti-patterns</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Design Anti-patterns. Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this video, we&#39;ll explore Design Anti-patterns. Anti-patterns, similar to their corresponding design patterns, define an industry-wide vocabulary that describes the common defective processes and implementations of organizations. A higher level vocabulary, as it were.</p>
<p>When implemented effectively, a higher level vocabulary tends to simplify the communication amongst people in the software industry, which facilitates concise and articulate description of higher level concepts. In other words, people in the software industry can understand each other better with a common, higher level vocabulary. An anti-pattern simply describes a common solution to a problem, but that solution generates negative consequences.</p>
<p>So it&#39;s not really a good solution. Anti-patterns can sometimes be the result of managers or developers just not knowing any better, or it could result from them lacking sufficient knowledge or experience in solving a specific type of problem, or anti-patterns can also result from managers or developers applying an excellent design pattern in the wrong context. Anti-patterns themselves offer real-world experience in the recognition of recurring problems in the software industry.</p>
<p>And they also provide a detailed solution for the most common difficulties. Anti-patterns focus on the most common problems in the software industry and offer the tools to enable one to recognize these problems and further, to uncover the underlying causes to begin with. One of the key objectives of anti-patterns is to describe useful approaches to software refactoring.</p>
<p>Software refactoring itself is a way to modify code in order to improve the software&#39;s structure and long-term maintenance. The first design anti-pattern that we&#39;ll consider is the Poltergeist anti-pattern. Poltergeists are classes with very limited rules and similarly limited, effective life cycles. They usually start processes on behalf of other objects. The refactored solution includes reallocating responsibilities to longer lived objects, thereby eliminating the Poltergeists.</p>
<p>You&#39;ve got to love some of these names. And the next one is a Boat Anchor, and this is a unit of software or hardware serving literally no useful purpose on the current project. It&#39;s very ironic, but it&#39;s also very common to learn that what is considered a Boat Anchor in an organization turns out to have been a very expensive acquisition. Probably the reason why the organizations tend to hold on to it.</p>
<p>A Golden Hammer is a familiar technology or concept that seems to be enthusiastically over-applied to several software problems.</p>
<p>The solution with this anti-pattern involves expanding developer knowledge via multifaceted education and training, to help developers understand alternative technologies and approaches. A Dead End anti-pattern describes a situation where a Dead End is reached, if, through the modification of a reusable component, it will no longer be maintained and supported by the supplier.</p>
<p>At this point, the support burden rests on the application&#39;s system developers and maintainers. Typically, improvements in the reusable component are not simple to integrate and support problems can then be blamed on the modification. Next, Spaghetti Code. Spaghetti Code is one of the most recognizable anti-patterns. Spaghetti Code occurs in programs or systems lacking software structure.</p>
<p>Continued coding and extensions typically serve to compromise the structure of the software, where even the original developer may lack clarity about the software. Common causes include: developers inexperienced with object-oriented design technologies, lack of mentoring, developers working in isolation, ineffective or non-existent code reviews, and no design work done prior to implementation.</p>
<p>Now, The Minefield. Sometimes using current software technology is like walking through a high-tech minefield. Several bugs are found in released software products. In fact, some estimate that original source code may contain on average multiple bugs per line of code. To address this anti-pattern, proper investment in software testing is an absolute necessity in order to ensure that systems are reasonably bug-free.</p>
<p>In some organizations, the number of testing staff actually exceeds programming staff. That&#39;s how important testing is. Next is Cut and Paste Programming. Code can be reused by copying source statements, but this can also lead to significant maintenance issues. Instead, consider alternative forms of reuse that can reduce maintenance issues by using common source code that has been tested and is typically well-documented. The next design anti-pattern is Continuous Obsolescence.</p>
<p>This anti-pattern is related to the rate of technological change. We all know that technology changes so quickly without pause. And this makes it so that developers frequently experience trouble keeping up with current versions of software, and this can result in difficulties integrating combinations of product releases. Java should be recognized as an example technology of this phenomenon. New versions are released every few months, and with the advent of DevOps and CICD, the release cycle has only accelerated.</p>
<p>To counter this, open system standards have emerged as an important stabilizing influence, because consortium standards are typically the result of well-thought-out industry consensus. The Lava Flow anti-pattern is concerned with dead code and neglected or forgotten design information that tends to get frozen in an ever-changing design. The name comes from the fact that dead code and neglected or forgotten design information are analogous to a lava flow with hardening edges and globules.</p>
<p>The refactored solution to this anti-pattern includes a commitment to a configuration management process which eliminates dead code and continually evolves or refactors design focused on improving quality. Our next anti-pattern is the Ambiguous Viewpoint. Object-oriented analysis and design models are usually presented without a clear explanation of the viewpoint represented by that model.</p>
<p>By default, object-oriented analysis and design models represent an implementation viewpoint that may actually be the least useful. Further, mixed viewpoints don&#39;t permit the fundamental separation of interfaces from implementation details, effectively nullifying one of the primary benefits of object-oriented design. Next, the Functional Decomposition anti-pattern is the output of experienced, non-object-oriented developers creating applications using an object-oriented language.</p>
<p>The resulting code may resemble a structural language in class structure. And this can be deceivingly complex, because resourceful, experienced and intelligent procedural developers are very adept at devising very clever ways to apply their tried and true time-tested methods to an object-oriented architecture. Next, Input Kludge.</p>
<p>Software that fails basic behavioral tests may be victim to Input Kludge, which typically occurs when ad hoc algorithms are used for handling program input. The next anti-pattern is Mushroom Management. Within some architecture and management groups, there is this explicit policy that&#39;s designed to keep system developers isolated from the system&#39;s end users.</p>
<p>Requirements are therefore passed second hand through intermediaries, including architects, managers or requirements analysts. And this can lead to confusion. And finally, The Blob. This procedural style design can lead to one object with a large majority of responsibilities, while most other objects execute the simplest processes or perhaps only hold data. The solution here involves refactoring the design to more equitably distribute responsibilities and also includes isolating the effects of changes.</p></div></div></div><div class="section"><a name="section_9" /><h2 class="section_title">10. Video: Software Refactoring for Efficient Programming ( it_sdjcfa_05_enus_10)</h2><img src="https://cdn2.percipio.com/public/b/0f032fa8-e5e0-4aa3-b48b-a2a4103956d6/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/0f032fa8-e5e0-4aa3-b48b-a2a4103956d6/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn about the process of refactoring. First, you’ll learn that refactoring is a systematic process that involves improving code without creating new functionality. It can transform a veritable mess into clean code and simple design. You’ll discover refactoring improves the internal structure of source code while preserving its external behavior.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe how to use code refactoring to implement efficient programming solutions</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Software Refactoring for Efficient Programming. Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this video, we&#39;ll explore the process of refactoring. First, let&#39;s define refactoring. Refactoring is a systematic process that involves improving code, without creating new functionality. It can transform what is a veritable mess into clean code and simple design. Refactoring improves the internal structure of source code while preserving its external behavior.</p>
<p>Typical risks and pitfalls include the fact that refactoring does not mean rewriting code. Refactoring is also not about fixing bugs. That&#39;s a totally different process altogether. Refactoring is not about improving visual aspects of software such as its user interface. Refactoring must not be performed where there&#39;s an absence of safeguards against introducing defects.</p>
<p>That is just too risky. Rather, safeguards should include regression testing, automated unit or automated acceptance tests and support for formal reasoning like type systems. When undertaking a refactoring initiative, we expect that the refactoring exercise will improve the codebase. One benefit from refactoring is that, with reasonable effort, it does invariably help understand the codebase.</p>
<p>Refactoring also typically improves the objective attributes of code, for example, length, duplication, coupling and cohesion, cyclomatic complexity and so on. And these are attributes that generally are consistent with improved maintenance. Refactoring facilitates reusable design elements such as design patterns and code modules, and refactoring encourages developers to carefully consider design decisions that were made and understand why they were made.</p>
<p>Now we&#39;ll talk about one of the main objectives of refactoring, and that is to combat technical debt. Refactoring can transform a code mess into clean code and simple design. So it avoids dreaded sloppy code, like inconsistent and poorly conceived variable and object naming, bloated classes and bloated methods. Clean code adheres to the Don&#39;t Repeat Yourself or DRY principles, which means, for one, that it doesn&#39;t contain duplication.</p>
<p>This can be a real problem because each time a change is made in a piece of code that is duplicated somewhere in the codebase, you must make an identical modification to every duplicated instance. Clean code uses a minimalist approach with respect to the number of classes and other moving parts. Less code is less subject matter that needs to be kept in your head. Less code means easier maintenance and results in fewer bugs. Also, keep in mind that code is a liability. So it should be kept short and simple and as concise as possible.</p>
<p>One other thing about clean code is that clean code passes every test. When only 95% of your tests have passed, you know that your code is dirty. Overall, clean code is far easier and much cheaper to maintain. What exactly do we mean by technical debt? Well, technical debt is simply a metaphor for sloppy or unclean code. Let&#39;s consider a bank loan. You get a loan from the bank, which allows you to make purchases faster, as in now.</p>
<p>You pay interest on the principal, which is the amount borrowed, in order to speed up your purchasing process. You eventually have to pay off the principal, again, the amount you borrowed, but you also have to pay the interest on a loan. It&#39;s compound interest, too. So the longer you go without paying and continue to borrow, the more debt you accumulate in an accelerated fashion.</p>
<p>The interest could potentially exceed your total income, which renders repayment difficult if not impossible. And a similar thing can happen with technical debt. A developer can temporarily speed things up by avoiding tests for new features. However, slowly but surely, this gradually slows progress every day until the developer is compelled one way or another to pay off the technical debt by writing and running tests. So what causes technical debt?</p>
<p>When there is a lack of tests and testing, there&#39;s a lack of immediate feedback. It may be quicker to go this way, but it just invites risk. In a worst case scenario, changes may be implemented and deployed right through to production without any prior testing. And we know that this can lead to some pretty catastrophic consequences. There&#39;s also the lack of documentation. This not only slows down current developers, it introduces myriads of other risk.</p>
<p>And it also slows down the onboarding process, delaying the possibility of getting new people to contribute in a meaningful way. Worse, if key people leave the project, that lack of documentation can put a full stop to development. Lack of team interaction and communication is another cause of technical debt.</p>
<p>For example, if an up-to-date project knowledge base isn&#39;t distributed properly, some people will wind up with outdated material and consequently outdated understanding about the project. There&#39;s also the lack of compliance monitoring, and this can occur when everyone working on the project writes code with no oversight or monitoring for standards and compliance.</p>
<p>And the sheer lack of understanding related to the consequences of technical debt can cause technical debt, typically because there is no commitment to provide sufficient time for refactoring, if its impact, as negative as it is, is not understood. Now, let&#39;s consider some other factors. The project&#39;s requirements are constantly changing and the project&#39;s programmers are writing new code every day that works with potentially obsolete components.</p>
<p>Therefore, the longer that refactoring is deferred or delayed, the higher the volume of dependent code that will have to be reworked and addressed at some point in the future. Long-term simultaneous development in several branches can also lead to simultaneous accumulation of technical debt, which increases when changes are merged. The more changes made in isolation, the greater the total technical debt. In some scenarios, business pressures can create circumstances that may press the rollout of features before they&#39;re actually really finished. This is very risky.</p>
<p>Also, when a project seems like a monolith rather than the sum of individual modules, any changes to one part of the project will affect others. In addition, team development is more challenging due to the fact that it&#39;s difficult to isolate the work of individual developers. And incompetence. This is when the developer just doesn&#39;t understand how to write clean code.</p>
<p>When should refactoring occur? Well, there&#39;s this rule of three or limit of three which goes like this: when you&#39;re doing something for the first time, just do it and get it done. When you are doing something similar for the second time, blush at the fact that you have to repeat it, but just get it done anyway. But when you find yourself doing something for the third time, it&#39;s time to start refactoring.</p>
<p>Also, when you&#39;re addressing bugs in code, that&#39;s a good time to consider refactoring. It doesn&#39;t mean that you refactor while you&#39;re addressing bugs, but it&#39;s a good time to consider refactoring. Clean code is much easier to troubleshoot and to locate root causes of errors. The code review could potentially be the last chance to clean up the code before being pushed to production.</p>
<p>Pairwise reviews are excellent for identifying and fixing simple problems quickly and for assessing the time required to fix more difficult problems. And finally, when adding a feature, refactoring can help bring out the understanding of other developers&#39; code. But if you must deal with other people&#39;s dirty code, try to refactor it first. Because clean code is so much easier to grasp and comprehend and it&#39;s so much easier to make changes within clean code.</p></div></div></div><div class="section"><a name="section_10" /><h2 class="section_title">11. Video: Software Refactoring Techniques ( it_sdjcfa_05_enus_11)</h2><img src="https://cdn2.percipio.com/public/b/f6b8b5f9-40c2-49bf-ae9c-fc342747bff3/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/f6b8b5f9-40c2-49bf-ae9c-fc342747bff3/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn software refactoring techniques. You’ll learn that before you can effectively refactor your code, it&#39;s important to understand what the main culprits are, the typical problems, and how to locate them. This is where code smells make their presence known. Code smells are simply aspects of code that are typically indicative of problems.</p>
<p>First, you’ll look at some typical refactoring targets. These include code bloaters and change blockers or change preventers.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe how to use software refactoring techniques to solve architectural coding problems</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Software Refactoring Techniques. Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this video, we&#39;ll consider software refactoring techniques. Before you can effectively refactor your code, it&#39;s important to understand what the main culprits are, the typical problems, and further, how to locate them. This is where code smells make their presence known. Code smells are simply aspects of code that are typically indicative of problems.</p>
<p>OK, so now let&#39;s look at some typical refactoring targets. First, code bloaters. These are code classes and methods that have grown to such huge proportions that they&#39;re genuinely difficult to work with. These smells don&#39;t typically manifest right away either. Rather, they accumulate over time and as the program evolves. For example, the long method is a situation that occurs when a method contains too many lines of code.</p>
<p>Of course, this is subjective. For example, what is too long? What is too many lines of code? Generally speaking, though, most methods needn&#39;t be longer than ten to 20 lines. Usually long methods contain code snippets that can be grouped together. So you may want to consider moving this code to a separate new method or function and replace the old code with a simple call to the new method.</p>
<p>Change blockers or change preventers are smells that can indicate when you need to change something in one place in your code, but you&#39;ll also have to make similar changes in other places, too. As a result, development becomes much more complicated, risky and expensive. This is similar to shotgun surgery, where making any modifications requires that you make several small changes to many different classes. In the refactoring exercise, this may mean moving classes around.</p>
<p>Next, are smells related to incomplete or incorrect application of object-oriented programming principles. This can happen, for example, when using alternative classes with different interfaces, which essentially means having two classes that perform identical functions, but they have different method names. Another target exists in the form of dispensable elements.</p>
<p>These are elements in code that are not necessary, and in fact, without them, the code would be easier to read, more efficient and simply cleaner. Examples include unnecessary comments, duplicate code, that&#39;s a real bad one, and dead code, which may be a variable, a field, parameter, method or class no longer used. And this frequently happens because it&#39;s obsolete.</p>
<p>Then we have couplers. Couplers are interesting targets. Couplers are code elements that participate in the excessive coupling between classes. You&#39;ll often hear of symptoms like feature envy in relation to couplers. This is a situation where a method accesses the data from some other object more than its own data.</p>
<p>For example, this can occur when fields are moved to a data class. In this type of situation, it may be best to move the operations on data to the class as well. Refactoring methods. These methods can be conveniently grouped by their function. So first, let&#39;s consider moving features. Moving features is concerned with moving features between objects. Let&#39;s assume, for example, that functionality has been distributed amongst the various different classes in a confusing and difficult way.</p>
<p>The moving features refactoring techniques, which includes moving methods, fields, extracting classes as well as others, can be used to safely create new classes, move functionality between classes and hide implementation details. Next, simplifying conditionals. This is an excellent refactoring technique because the logic in conditionals tends to become more complicated over time.</p>
<p>Decomposing conditionals, which is one of the refactoring techniques in this category, decomposes complicated logic into separate methods. The condition, the then, and the else. Next are the organizing data refactoring techniques. These are focused on data handling and replacing primitives with rich class functionality. For example, one problem that is common is when you have an array that contains various types of data.</p>
<p>In this case, it may be wise to replace that array with an object that has separate fields for each element. Now, composing methods. A significant component of refactoring involves correctly composing methods. In most situations, excessively long methods are the culprit. The sheer volume of code inside long methods can disguise the execution logic and make the method very difficult to understand, which means that changing it is even more of a challenge.</p>
<p>The refactoring techniques in the composing methods category can help reorganize and simplify methods and address code duplication. And of course, with clean code, we know that it makes it much easier to understand code and to work with code. The next category is handling generalization. The techniques in this category are concerned primarily with creating new classes and interfaces and moving functionality within the class inheritance hierarchy. Now the techniques involved in the simplifying method calls category simplifies method calls, making them easier to understand.</p>
<p>This also serves to simplify interfaces associated with interaction between classes.</p></div></div></div><div class="section"><a name="section_11" /><h2 class="section_title">12. Video: API Pattern Principles ( it_sdjcfa_05_enus_12)</h2><img src="https://cdn2.percipio.com/public/b/d21b7086-11d8-4520-8d6b-abf2a0cacf14/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/d21b7086-11d8-4520-8d6b-abf2a0cacf14/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about the guiding principles behind typical API patterns. You’ll learn most web applications expose APIs clients use to interact with the application. A well-designed API can support platform neutrality or platform independence. Any client should be able to call the API, regardless of how the API is implemented. This requires using standard protocols and a mechanism where the client and the service can agree on the data format.  </p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">recall the guiding principles that underpin most API patterns</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: API Pattern Principles. Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this video, we&#39;ll explore the guiding principles behind typical API patterns. Most modern web applications expose APIs that clients can use to interact with the application. A well-designed web API should aim to support platform neutrality or platform independence. Any client should be able to call the API, regardless of how the API is implemented internally.</p>
<p>This requires using standard protocols and having a mechanism whereby the client and the web service can agree on the format of the data to be exchanged. The web API should also be able to evolve and add functionality independently of client applications. As the API evolves, existing client applications should continue to function without modification. And all functionality must be easily discoverable.</p>
<p>When designing APIs, it&#39;s important to organize the API around the resources. We need to focus on the business entities that the web API exposes. For example, in an online video service, the primary entities might be users and videos. Keep in mind that resource doesn&#39;t necessarily have to be based on a single physical data item.</p>
<p>For example, a video resource which could include movies, TV series and documentaries, might be represented internally across multiple tables in relational database, then presented to the user as a single entity. And this leads nicely into the next point, and that is to avoid creating APIs that simply reflect the internal structure of a database. A typical client should never be exposed to the underlying structure or implementation.</p>
<p>Entities are often conveniently grouped together into collections. For example, users and videos. A collection is a separate resource from the individual item within the collection, and it should have its own URI. You should adopt a consistent naming convention in URIs. Another consideration is how you may be able to expose relationships and associations between different types of resources. So the focus is on serving resources, and we should always try to keep URIs relatively simple.</p>
<p>We must not forget that all web requests impose some load on the web server. More requests mean larger load, so we should recognize and acknowledge that. To help in this regard, we should avoid deploying &#34;chatty&#34; APIs. That is, exposing huge volumes of small or tiny resources. An API configured that way may require that a client send several requests to find even modest amounts of data.</p>
<p>When designing an API, we must avoid introducing dependencies between web API and the underlying data sources. The web API should be an abstraction of the database. In scenarios where it&#39;s not possible to map an operation implemented by an API, we can use HTTP methods to accommodate such requests. For example, the API could provide an option to invoke a function and return the results as an HTTP response. An API should define operations in terms of HTTP methods.</p>
<p>The HTTP protocol defines some well-known methods and the most common HTTP methods used by restful web APIs are the GET request, which is used to retrieve information about the resource at the specified URI and the response body contains the information requested. The POST request creates a new resource at the specified URI. The request body contains specifics about the new resource. A PUT request can create or replace the resource at the specified URI. The request body specifies the resource to be created or updated.</p>
<p>PATCH requests perform a partial update of a resource. The request body specifies the changes that are to be applied to the resource. And DELETE. The DELETE method removes the resource at the specified URI. When a GET request is made, the response body contains a representation of the requested resource. The HTTP protocol uses media types also known as MIME types, to specify formats.</p>
<p>Most web API support JSON and XML. And the content type header is where that format is specified. POST, PUT, PATCH or DELETE operations, require processing and or network traffic time to complete and return response. Such operations are treated as asynchronous. You could return an HTTP status code 202 Accepted, that tells the client that the request was accepted but isn&#39;t completed.</p>
<p>Now, let&#39;s take a quick look at some status codes. A successful GET usually returns a 200 OK status code, while if the resource is not found, the method should return a 404 Not Found code. For POST methods, if a POST is accepted but doesn&#39;t create a new resource, the method can return HTTP status code 200. If the method creates a new resource, it returns a 201 Created code.</p>
<p>If there is no content to return, the method can return 204 No Content status code and invalid requests should return a 400 Bad Request code. For PUT methods, if a PUT method updates an existing resource, it can return a 200 OK. If the method creates a new resource similar to the POST method, it returns a status code 201 Created. If the method updates an existing resource, it can sometimes return 204 No Content.</p>
<p>And where it&#39;s not possible to update an existing resource, a 409 Conflict code is returned. Now, the specification for the PATCH method, which is RFC 5789, does not define a particular format for PATCH documents. The format is typically inferred from the media type specified in the request. And the most common supported PATCH formats are variations of JSON. Now, the DELETE method, if successful, typically returns 204 No Content status, or if the resource was not found, a 404 Not Found code.</p>
<p>An API should support navigation, allowing clients to access resources in an efficient manner. Clients, for example, could be provided with the ability to request a sort order. An API should provide a convenient way for clients to request information, but in a way that is network-friendly. We do not, for example, want a client application to have to return all orders and then filter them client-side.</p>
<p>That&#39;s too inefficient. Instead, the API could support passing a filter in the query string of a URI. For example, year&#61;22. The web API is also responsible for parsing and handling the cust-ID parameter in the query string and returning the filtered results from the server-side. Now, this is a typical REST API Design. So from the left-hand side, we&#39;ve got the data model, which is provided by the application.</p>
<p>Then we have the resource model, which is the API. So, for example, we have a resource model that exposes a logical hierarchy over the customers&#39; resources. And then we have on the client-side a client app, a REST library or an HTTP library that makes the client requests. Now, an API can support partial responses for large binary resources. For convenience and reliability, we can enable resources to be retrieved in chunks by supporting the Accept-Ranges header for GET requests, for large resources.</p>
<p>APIs can use HTTP HEAD requests for these resources. A HEAD request is similar to a normal GET request, but a HEAD request only returns the HTTP headers that describe the resource. The Content-Length header gives the total size of the resource. Now, Hypermedia as the Engine of Application State is a design feature of RESTful architecture. Under this principle, a client communicates with the network through hypermedia, which supports various delivery formats.</p>
<p>Each GET request should return the information necessary to locate resources related directly to the requested resource through hyperlinks included in the response. Now, APIs may change, for example, when business requirements change, perhaps there are new or different data sources or collections. For that, we can employ some versioning scheme.</p>
<p>When considering making changes to an API, though, it&#39;s imperative that one consider how client applications will be affected. Backward compatibility is imperative, in order to continue to handle existing client application requests, unchanged, while allowing new client applications to take advantage of new features and resources.</p>
<p>Versioning enables an API to indicate the features and resources it exposes. Likewise, client applications should be able to submit requests that are directed to specific versions of a feature or resource. Versioning approaches include no versioning, which is the simplest approach, URI versioning, means that each time you modify the web API or change the schema of resources, you add a version number to the URI for each resource.</p>
<p>Then we have query string versioning. Here, rather than providing multiple URIs, you can specify the version of the resource by using a parameter within the query string appended to the HTTP request. With header versioning, rather than appending the version number as a query string parameter, a custom header could be implemented, indicating the version of the resource.</p>
<p>The client application adds the appropriate header to any requests. And media type versioning. When a client application sends a GET request, it should specify the format of the content that it can handle by using an Accept header. The Accept header can be used to allow the client application to specify the format of response body, typically XML, JSON, or any other common format that the client is capable of parsing.</p>
<p>When designing an API, the OpenAPI initiative is one consideration. It was created by an industry consortium to standardize the REST API. The OpenAPI specification includes a set of opinionated guidelines on how a REST API should be designed. And OpenAPI promotes a contract-first approach, which means that the API contract, the interface, is designed first and then code is written to implement the contract.</p></div></div></div><div class="section"><a name="section_12" /><h2 class="section_title">13. Video: API Patterns ( it_sdjcfa_05_enus_13)</h2><img src="https://cdn2.percipio.com/public/b/ebd36dd8-c012-434e-bf45-f78c6137abc4/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/ebd36dd8-c012-434e-bf45-f78c6137abc4/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll learn more about fundamental design patterns for implementing API resource layout and naming. You’ll learn that REST is an architectural design pattern, not a communication protocol. HTTP is considered a restful protocol, as it’s one implementation of the REST architecture.</p>
<p>You’ll learn about the five constraints most experts agree must be present for an application to be considered RESTful. </p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe fundamental design patterns for implementing API resource layout and naming</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: API Patterns. Your host for this session is Joseph Khoury.</em> [Video description ends]
<p>In this video, we&#39;ll explore fundamental design patterns for implementing API resource layout and naming. REST is an architectural design pattern and is not a communication protocol. HTTP is considered a restful protocol, as it is one implementation of the REST architecture. Due to the fact that it is not a formally defined protocol, there are all sorts of opinions about implementing REST APIs.</p>
<p>But here are five constraints that most experts will agree must be present for an application to be considered RESTful. First, must be client/server. A client/server architecture allows a clear separation of concerns. The client is responsible for requesting and displaying data. The server is responsible for data storage and application logic. It should employ a uniform interface. Caching: stateless client/server communication can see server load increase because some information may require multiple requests.</p>
<p>So only retrieved data should be cashable. Then there&#39;s statelessness. Communication between client and server must be stateless. Each client request must contain all the information necessary for the server to process the request, and it must be a layered system; a key feature of most network systems where REST is concerned. This means that a client won&#39;t necessarily be able to tell if it is directly communicating with the server or an intermediate, like a proxy.</p>
<p>APIs should be organized around serving resources, focus on the business entities that the web API exposes. Entities are often conveniently grouped together into collections. A collection is a separate resource from the item within the collection, and it should have its own URI. A consistent naming convention for URIs is crucial, and APIs should expose relationships and associations between different types of resources. We also want to keep URIs relatively simple.</p>
<p>APIs must also avoid introducing dependencies between the API and the underlying data sources. The API should be an abstraction of the database and to avoid excessive traffic, web APIs should be careful not to expose huge numbers of small resources that require several requests. Now, looking at a typical REST API Design: on the application, we have a data model. Now that data model is served through the application interface and the API represents a logical hierarchy over the resources it serves.</p>
<p>In this case, customers. So, for example, customers returns all customers, customers/1 returns the customer with an ID of 1 and customers/1/orders would return all the orders for a customer with a customer ID of 1. On the right-most side, we have the client, and the client could be a client app, a REST library or an HTTP library, and these client requests are sent to the server and the server responds accordingly.</p>
<p>Now, when creating resources, we need to use simple API endpoints. The example I use here is customers, and customers/1 which is an individual customer. And customers, which is a collection. We also want to be careful to use nouns, and that&#39;s what I&#39;m doing here: customers/1 and /orders, right? Customers is a noun, orders is a noun. We want to be careful not to use verbs, so for example, a GET request with our URI ending with getAllCustomers is something to avoid.</p>
<p>We want to avoid verbs. We want to avoid mixing verbs and nouns which are operational URIs. So when creating resources, we want to use parameterized URIs. Likewise, we can have multiple parameters in a URI. We should use sub-resources to expose data relationships, for example, the department/IT/employees URI returns all employees that belong to the IT department. So there&#39;s that relationship. We do not want to use, as mentioned, operational URIs.</p>
<p>For example, getAllEmployeesInITDept, or listEmployeeInITDept/NY. And there&#39;s a debate about single versus plural nouns and there is no hard rule. However, when there&#39;s one resource returned, it&#39;s a good idea to return singular and when multiple resources, use plural. So, again, when creating resources, we can use parameters and I&#39;m referring to parameterized URIs, and we want to avoid operational URIs which mix nouns and verbs.</p>
<p>Now, another consideration is the return type. The most common return type is JSON format, so that&#39;s likely the best option. XML is another choice if you want to offer both. However, JSON is the fundamental API return type among web developers and it also works nicely with document databases. Now, what are the specific HTTP methods used for? Well, GET is used for fetching, resources or collections. POST is used for creating resources or collections.</p>
<p>PUT and PATCH are used for updating resources or collections, and DELETE is used for deleting resources or collections.</p></div></div></div><div class="section"><a name="section_13" /><h2 class="section_title">14. Video: Course Summary ( it_sdjcfa_05_enus_14)</h2><img src="https://cdn2.percipio.com/public/b/8159011f-a8f2-4aee-adf6-5e0f6972624c/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/8159011f-a8f2-4aee-adf6-5e0f6972624c/image001.jpg')();" /><div class="section_text"><p>In this video, you’ll review what you’ve learned in this course. In this course, you learned the importance of design patterns as well as types of patterns. You learned about Behavioral, Structural, and Creational design patterns and their implementations.</p>
<p>You also learned about the different types of design anti-patterns. You learned to use code refactoring techniques. And finally, you explored API pattern principles as well as API design patterns for resource layout and naming.</p></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">summarize the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Summary.</em> [Video description ends]
<p>So in this course, we&#39;ve examined the importance of design patterns as well as types of patterns. We did this by exploring Behavioral, Structural and Creational design patterns and their implementations.</p>
<p>We explored different types of design anti-patterns. We explored using code refactoring techniques. We considered API pattern principles as well as API design patterns for resource layout and naming.</p>
<p>In our next course, we&#39;ll move on to describe Java classes, attributes, methods, constructors, access modifiers, and how to compile and run a Java application.</p></div></div></div><div class="copyright-container"><span class="copyright-text">© 2022 Skillsoft Ireland Limited - All rights reserved.</span></div></div><div id="lb-overlay"><div class="lb-header"><button onclick="(()=>{const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'hidden';const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 1.0;curtain.style.backgroundColor = 'white';curtain.style.pointerEvents = 'auto';})();">X</button></div><div id="lb-image-container"><img id="lb-image" alt onload="(()=>{const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 0.5;curtain.style.backgroundColor = 'grey';curtain.style.pointerEvents = 'none';const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'visible';window.scrollTo(0, 0);})();"/></div><div class="lb-footer" /></div></div></body></html>