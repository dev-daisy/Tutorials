<!doctype html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-style-type" content="text/css2"><title>Course Transcript</title><link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css"><style>:root {
    --title-text: #243038;
    --toc-link: #0073C4;
    --section-title-text: #243038;
    --section-title-border: #bababa;
    --grid-caption-text: #164794;
    --grid-border: #c0c0c0;
    --grid-hdr-text: #973131;
    --grid-hdr-background: #f7f7f7;
    --missing-data: #767676;
    --text-color: #343434;
    --lightbox-border: #a0a0a0;

    --bold-font-weight: 700;

    font-family: Lato;
}

.report {
    margin: 24px;
}

.container {
    position: relative;
}

#lb-curtain {
    background-color: white;
    opacity: 1.0;
}

#lb-overlay {
    position: absolute;
    top: 40px;
    left: 20px;
    right: 20px;
    background-color: white;
    border: solid 1px var(--lightbox-border);
    visibility: hidden;
}

.lb-header, .lb-footer {
    height: 40px;
    line-height: 40px;
}

.lb-header {
    display: flex;
    justify-content: flex-end;
    padding-right: 20px;
}

#lb-image-container {
    margin: 0 40px;
}

#lb-image {
    width: 100%;
}

.report_title {
    font-size: 22px;
    font-weight: var(--bold-font-weight);
    color: var(--title-text);
}

.toc_link {
    font-size: 14px;
    color: var(--toc-link);
    margin-top: 6px;
    margin-bottom: 0;
}

.section {
    margin-top: 40px;
    margin-left: 16px;
}

.section.inner {
    margin-top: 20px;
}

.section.inline {
    margin-top: 20px;
    margin-left: 0;
}

.section_title {
    font-size: 18px;
    font-weight: var(--bold-font-weight);
    width: 100%;
    color: var(--section-title-text);
}

h2.section_title {
    border-bottom-color: var(--section-title-border);
    border-bottom-style: solid;
    border-bottom-width: thin;
}

h3.section_title {
    margin: 8px 0;
}

h3.list_title {
    margin: 8px 0;
    font-size: 14px;
    color: var(--title-text);
}

.section_text {
    font-size: 14px;
    color: var(--text-color);
    margin: 12px 0;
    width: 90%;
}

.section_link {
    font-size: 14px;
    margin: 12px 0;
    width: 90%;
}

.grid {
    border-collapse: collapse;
}
.grid_caption {
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    color: var(--grid-caption-text);
    margin: 12px 0;
    text-align: left;
    white-space: nowrap;
}
.grid_hdr_row {

}
.grid_col {
    font-size: 13px;
    color: var(--text-color);
    border-collapse: collapse;
    padding: 2px;
    text-align: left;
    vertical-align: top;
}
.grid_col_hdr, .grid_row_hdr {
    font-size: 12px;
    font-weight: var(--bold-font-weight);
    white-space: nowrap;
}
.grid_row_hdr {

}

.empty_grid {
    border-collapse: collapse;
    border-color: var(--grid-border);
    border-style: solid;
    border-width: 2px;
    padding: 4px;
    text-align: center;
}

.htmlbox {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    padding: 8px;
}

.list {
    font-size: 14px;
    font-style: italic;
}

.missing_data {
    color: var(--missing-data);
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    font-style: italic;
}

.copyright-container {
    margin-top: 24px;
    text-align: center;
}
.copyright-text {
    color: var(--text-color);
    font-size: 12px;
}

/* Transcript Questions CSS */

.question {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    display: flex;
    flex-direction: column;
    padding: 8px;
}

.question_content {
    display: flex;
    justify-content: space-between;
}

.question_details {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.question_images {
    display: flex;
    flex-direction: column;
    margin-left: 16px;
}

.question_image {
    margin-bottom: 8px;
}

.question_title {
    font-weight: var(--bold-font-weight);
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
    padding-bottom: 8px;
    margin-bottom: 8px;
}

.question_label, .question_stem {
    font-weight: var(--bold-font-weight);
    margin-top: 8px;
    margin-bottom: 8px;
}

.question_data_row {
    display: flex;
}

.question_data_col1 {
    padding: 8px;
    white-space: nowrap;
}

.question_data_col2 {
    padding: 8px;
    display: flex;
    flex-direction: column;
}

.question_answer_key {
    margin-top: 8px;
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
}

.feedback {
    font-style: italic;
}
</style></head><body class="report"><div class="container"><div class="content" id="lb-curtain"><h1 class="report_title">Oracle Database 12c R2 SQL: Reporting Aggregated Data Using Group Functions   </h1><div class="section_text"><p>Discover how to obtain summary information, such as averages, for groups of rows in SQL. Explore how to group rows in a table into smaller sets and how to specify search criteria for groups of rows.</p></div><div class="section"><h2 class="section_title">Table of Contents</h2><div class="toc"><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_0">1. Video: Group Functions (it_dfosfd_13_enus_01)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_1">2. Video: AVG and SUM Functions (it_dfosfd_13_enus_02)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_2">3. Video: MIN and MAX Functions (it_dfosfd_13_enus_03)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_3">4. Video: COUNT and COUNT DISTINCT Functions (it_dfosfd_13_enus_04)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_4">5. Video: Group Functions and NULL Values (it_dfosfd_13_enus_05)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_5">6. Video: Creating Groups of Data (it_dfosfd_13_enus_06)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_6">7. Video: GROUP BY Clause  (it_dfosfd_13_enus_07)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_7">8. Video: GROUP BY on Multiple Columns (it_dfosfd_13_enus_08)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_8">9. Video: Illegal Queries (it_dfosfd_13_enus_09)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_9">10. Video: Restricting Group Results Using the HAVING Clause (it_dfosfd_13_enus_10)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_10">11. Video: Nesting Group Functions (it_dfosfd_13_enus_11)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_11">12. Video: Exercise: Use GROUP BY and HAVING (it_dfosfd_13_enus_12)</a></p></div></div><div class="section"><a name="section_0" /><h2 class="section_title">1. Video: Group Functions (it_dfosfd_13_enus_01)</h2><img src="https://cdn2.percipio.com/public/b/eea875ba-28f0-41a9-9a13-fab40d4dd3c2/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/eea875ba-28f0-41a9-9a13-fab40d4dd3c2/image001.jpg')();" /><div class="section_text">After completing this video, you will be able to describe how to use group functions to return one result based on a set of rows in a SQL statement.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe how to use group functions to return one result based on a set of rows in a SQL statement</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: Group Functions. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>In this presentation, we&#39;ll introduce group functions. Which can be used to operate on sets of rows to give one result per group or per set. So unlike single row functions, group functions can operate on these sets of rows and again, return a single result. Now, these sets may comprise the entire table that is still a set of rows but they could also be groups within the table. So as an example, the MAX group function simply returns the highest value. In this particular case, it&#39;s examining the SALARY column. So the set, in this case, is every row in the table, just to examine every value for salary and find out which one is the highest. So of the complete set of rows, a single value comes back, representing the highest salary, okay? But in this example, the DEPARTMENT_ID is also being selected and there are some duplicate values in the DEPARTMENT_ID. Because any given department can have multiple employees. We are selecting from the EMPLOYEES table here.</p>
<p>So for example, there are two employees in department 20, there are two employees in department 110, there are three employees in department 90. So where those duplicates are happening, those can be considered to be their own separate subgroups, if you will. So group functions can also operate on those subgroups. Now, we&#39;ll see that a little bit later in our demonstrations. So the types of group functions that we&#39;ll be working with, include AVG or average. And this simply returns the average value. COUNT is, quite simply, how many are there? MAX is the maximum value. Conversely, MIN is the minimum value, and SUM of course, adds them all up. That is perhaps the most common group function. Now this is not a complete list, but these are certainly the most common group functions. But all of them operate on a set of rows, but they all return a single value. The average salary, for example, the highest salary, the lowest salary, the sum of all salaries. Even the count of how many there are, they would all be single values based on the entire set that was examined. In terms of syntax, it&#39;s referenced in the SELECT statement.</p>
<p>[Video description begins] <em> Group Functions: Syntax.</em> [Video description ends]</p>
<p>You simply specify which function you want to use and then which column that function is operating on. Now, you can select more than one group function. So in another words, I could select group function one, group function two, group function three, that&#39;s fine. But each individual function can only operate on a single column, okay? Then still, from whichever table, and you can still use a where clause if you want to, that&#39;s optional. But from that point on, it&#39;s like any other SELECT statement. But ultimately, it will still group all of the rows that are examined, in any given column, and produce that single output result.</p></div></div></div><div class="section"><a name="section_1" /><h2 class="section_title">2. Video: AVG and SUM Functions (it_dfosfd_13_enus_02)</h2><img src="https://cdn2.percipio.com/public/b/8ca28912-d50a-44fd-a694-8cc15958cca8/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/8ca28912-d50a-44fd-a694-8cc15958cca8/image001.jpg')();" /><div class="section_text">To group numeric data in a SQL statement, use the AVG and SUM functions.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">use the AVG and SUM functions to group numeric data in a SQL statement</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: AVG and SUM Functions. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>In this demonstration, we&#39;ll see our first examples of using group functions. And we&#39;ll begin with perhaps the most common of those, the SUM and the AVG functions. In almost every environment, you will likely find yourself wanting to know the sum of a numeric column. And quite often, the average. So in this case, we&#39;ll use those functions against the salary column, in the EMPLOYEES table.</p>
<p>[Video description begins] <em> The Oracle SQL Developer : HR window is open. It is divided into four parts. The first part is the menu bar. The second part is the toolbar. The third part is divided into two sections. The first section is the Connections pane. It contains the Connections parent node, which contains the HR subnode. It includes the Tables (Filtered) and Views subnodes. The Tables (Filtered) subnode is expanded and it includes the COUNTRIES, DEPARTMENTS, EMPLOYEES, and JOBS tables as subnodes. The second section is the Reports pane. It contains the All Reports parent node. The fourth part contains the Start Page and HR tabs. The HR tab is selected. It is divided into two sections. The first section is the toolbar. It includes the execute icon. The second section contains the Worksheet and Query Builder tabs. The Worksheet tab is selected.</em> [Video description ends]</p>
<p>And, you can see that the syntax is to just preface the column with the function. So we SELECT SUM of the salary column, and you just make sure that the column is in parenthesis, and that&#39;s it. There are no other arguments required for the group functions in this case. Just tell it to operate on this particular column. That is simply being aliased as Sum of Rep Salaries, now I&#39;ll come to the Rep aspect in a minute. And then comma, our next column is the average, again working on the salary column. And that&#39;s being aliased as Average Rep Salary from the EMPLOYEES table. And in this case, I&#39;m just adding a WHERE clause, where the job id is LIKE wildcard REP wildcard. In other words, Any job id that has REP somewhere in the title, okay? So that&#39;s why I aliased this as Rep Salaries. Now, of course, the WHERE clause is up to you. You don&#39;t have to include one, but this does find me Rep Salaries. So let&#39;s go ahead and execute. And we get our answers.</p>
<p>[Video description begins] <em> He selects the SELECT SUM(salary) AS “Sum of Rep Salaries”, AVG(salary) AS “Average Rep Salary”, FROM EMPLOYEES, WHERE job_id LIKE ‘%REP%’; statement and clicks the execute icon. The Query Result tab opens. It is divided into two parts. The first part is the toolbar. The second part contains a table with the Sum of Rep Salaries and Average Rep Salary column headers and one row.</em> [Video description ends]</p>
<p>So the Sum of all Rep Salaries, you can see here, is 273,000. Now, the average is 8272.72727272. So this is just a good candidate for nesting the function within a ROUND function. Okay, so my second piece of code here is identical to the first, with the exception of nesting the AVG(salary) function within the ROUND function. And in this case, I am specifying to ROUND to 2 decimal places. Okay, so the arguments for the ROUND function are the AVG(salary) and 2 decimal places. Again making sure that all of that is placed within it&#39;s own set of parenthesis, okay? So let&#39;s just go ahead and execute here. And it just cleans it up a little bit.</p>
<p>[Video description begins] <em> He selects the SELECT SUM(salary) AS “Sum of Rep Salaries”, ROUND(AVG(salary),2) AS “Average Rep Salary”, FROM EMPLOYEES, WHERE job_id LIKE ‘%REP%’; statement and clicks the execute icon. A table with the Sum of Rep Salaries and Average Rep Salary column headers and one row appears in the Query Result tab.</em> [Video description ends]</p>
<p>So that has been rounded up to 0.73, and we just get a more readable response.</p>
<p>[Video description begins] <em> He points at the value 8272.73 under the Average Rep Salary column header.</em> [Video description ends]</p>
<p>Okay, so those are fairly simple and again, very common. So when you do want to sum up any column value, simply place that column within the SUM function or the AVG function, and you&#39;ll get your answers.</p></div></div></div><div class="section"><a name="section_2" /><h2 class="section_title">3. Video: MIN and MAX Functions (it_dfosfd_13_enus_03)</h2><img src="https://cdn2.percipio.com/public/b/8da22222-144a-4549-ae65-0d20d2c34c35/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/8da22222-144a-4549-ae65-0d20d2c34c35/image001.jpg')();" /><div class="section_text">In this video, you will learn how to use the MIN and MAX functions to group numeric, character, and date data types in a SQL statement.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">use the MIN and MAX functions to group numeric, character, and date data types in a SQL statement</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: MIN and MAX functions. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>For our next demonstration, we&#39;ll see the MIN and MAX group functions. And again, these are very commonly used, but they are quite simple. And their usage is identical in terms of syntax to the SUM and AVG functions that we just saw in our previous demonstration. So I&#39;m still just selecting out the salary column here,</p>
<p>[Video description begins] <em> The Oracle SQL Developer : HR window is open. The HR tab is selected.</em> [Video description ends]</p>
<p>but in this case the function is MIN, and this is being aliased as Lowest Rep Salary. Then simply replacing that with MAX against the salary column, and that is being aliased as Highest Rep Salary. And again my WHERE clause is exactly the same as in the previous demonstration, just looking for a Job_id that contains the value of REP anywhere in there. Now I&#39;ve also included this little calculation here, which certainly would not be necessary, but I&#39;ve taken the MAX(salary) and I&#39;m subtracting from it the MIN(salary). Okay, so each function here is enclosed within another set of parentheses, and I&#39;m aliasing that AS Difference, just so I can see the difference between the two. Again, that&#39;s not necessary, but certainly very plausible. So let&#39;s go ahead and execute, and of course we see the Lowest Rep</p>
<p>[Video description begins] <em> He selects the SELECT MIN(salary) AS “Lowest Rep Salary”, MAX(salary) AS “Highest Rep Salary”, (MAX(salary)) AS “Difference”, FROM EMPLOYEES, WHERE job_id LIKE ‘%REP%’; statement and clicks the execute icon. A table with Lowest Rep Salary, Highest Rep Salary, and Difference column headers and one row appears in the Query Result tab.</em> [Video description ends]</p>
<p>Salary is 6,000, the Highest Rep Salary is 11,500. That is a Difference of 5,500. So we see the spread between the lowest and the highest. So, again those are very commonly used in any kind of numeric value. It&#39;s very common to see what is the low end versus what is the high end, and optionally the difference between the two.</p></div></div></div><div class="section"><a name="section_3" /><h2 class="section_title">4. Video: COUNT and COUNT DISTINCT Functions (it_dfosfd_13_enus_04)</h2><img src="https://cdn2.percipio.com/public/b/1354a71e-ca49-43ce-9b20-ac05e4b54863/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/1354a71e-ca49-43ce-9b20-ac05e4b54863/image001.jpg')();" /><div class="section_text">During this video, you will learn how to use the COUNT and COUNT DISTINCT functions in SQL statements.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">use the COUNT and COUNT DISTINCT functions in a SQL statement</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: COUNT and COUNT DISTINCT Functions. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>Now, for our next demonstration, we&#39;ll take a look at using the COUNT(), which includes COUNT(*) and COUNT(DISTINCT) group functions. And in all cases, they are simply concerned with counting how many values there are. But there are some differences with respect to each one, in terms of how they handle duplicates and nulls. So we&#39;ll begin with COUNT(*) and</p>
<p>[Video description begins] <em> The Oracle SQL Developer : HR window is open. The HR tab is selected.</em> [Video description ends]</p>
<p>you can see that this includes all duplicate rows and all nulls. So star, as we&#39;ve seen in select star, means everything. Select all columns, so therefore, COUNT(*) means count everything, okay? So you don&#39;t even have to specify a particular column in this case, it will just count out the number of records, okay? So I can SELECT COUNT(*) and then simply alias it. And in this case, it is the Total Number of Employees, because I&#39;m counting up the number of records in the EMPLOYEES table. So again, I don&#39;t have to specify any particular column, just count everything. But it is again, specifically the number of rows, not the number of columns, okay? So this will simply tell me how many employees there are, and as mentioned, it would include duplicates and it would include nulls.</p>
<p>[Video description begins] <em> He selects the SELECT COUNT(*) AS “Total Number of Employees”, FROM EMPLOYEES; statement and clicks the execute icon. A table with Total Number of Employees column header and one row appears in the Query Result tab. The value 107 is displayed under the Total Number of Employees column header.</em> [Video description ends]</p>
<p>Now, there aren&#39;t any null values in the EMPLOYEES table nor are there any duplicates in this case. But if I were to issue the COUNT(*) against a specific column, there certainly could be nulls and there could be duplicates. So in this case, if I SELECT COUNT(*) AS Number of Employees in Dept 50, I am explicitly looking for a value of 50, okay? So there certainly could be duplicate values here. There could be a number of employees obviously, in the same department. So they will be included, okay? So let&#39;s go ahead and execute and we see that they&#39;re 45.</p>
<p>[Video description begins] <em> He selects the SELECT COUNT(*) AS “Number of Employees in Dept 50”, FROM EMPLOYEES, WHERE department_id &#61; 50; statement and clicks the execute icon. A table with Number of Employees in Dept 50 column header and one row appears in the Query Result tab. The value 45 is displayed under the Number of Employees in Dept 50 column header.</em> [Video description ends]</p>
<p>So clearly there are many duplicate values in the department_id column. All 45 of those records reference the department number of 50, so clearly we are getting duplicate values back, okay? So in the next example, we are using the COUNT function with a column or an expression, okay? So I&#39;m working on a specific column in this case, not COUNT(*). This does not return nulls but does include duplicates, okay? So in this case it&#39;s SELECT COUNT, working against the Commission_pct column. Aliased as Number of Employees Earning Commission. So as long as there is a value in the commission percentage column, it will be included in the count. If there is a null, it will not be included, okay? So all of those who do not earn commission will simply be ignored in the count. So let&#39;s execute, and there are 35 employees earning commissions.</p>
<p>[Video description begins] <em> He selects the SELECT COUNT(commission_pct) AS “Number of Employees Earning Commission”, FROM EMPLOYEES; statement and clicks the execute icon. A table with Number of Employees Earning Commission column header and one row appears in the Query Result tab. The value 35 is displayed under the Number of Employees Earning Commission column header.</em> [Video description ends]</p>
<p>Now again, this will include duplicates. So if there are two or three, or five, or ten, or any number of employees that are earning the same commission value, they will be included. So that&#39;s exactly what I want in this case, I&#39;m not really concerned with what the commission rate is, simply are they earning commission. Everyone could be earning the exact same commission rate, but count against a specific column will include the duplicates. And finally, COUNT(DISTINCT) will not return either. It will not return nulls nor will it return duplicates. So to demonstrate the difference here, I&#39;m not using the COUNT(DISTINCT) in my first example. I&#39;m counting the location_id column from the DEPARTMENTS table as the Total Number Departments in all Locations. So let&#39;s go ahead and execute and we see that there are 28.</p>
<p>[Video description begins] <em> He selects the SELECT COUNT(location_id) AS “Total Number of Departments in all locations”, FROM DEPARTMENTS; statement and clicks the execute icon. A table with Total Number of Departments in all Locations column header and one row appears in the Query Result tab. The value 28 is displayed under the Total Number of Departments in all Locations column header.</em> [Video description ends]</p>
<p>Okay, but of course, any given location could have multiple departments within that location. So in my second example, all I&#39;ve done is to add the word DISTINCT. Now, take note, it goes inside the parentheses, so it&#39;s still COUNT, but DISTINCT on location_id. This will remove the duplicates, so this can be translated if you will as the number of locations that have departments. So again, I&#39;m not concerned with how many in this case, just are there any number of departments in that location. So recall that without DISTINCT, 28 came back. With DISTINCT, only seven. Okay, so again,</p>
<p>[Video description begins] <em> He selects the SELECT COUNT(DISTINCT location_id) AS “Number of Locations with Departments”, FROM DEPARTMENTS; statement and clicks the execute icon. A table with Number of Locations with Departments column header and one row appears in the Query Result tab. He points at the value 7 displayed under the Number of Locations with Departments column header.</em> [Video description ends]</p>
<p>what that means is that there are many locations that have multiple departments. Seven locations simply have departments in general. There can be any number of departments within that location, but there are seven that have departments. And it is possible that you could have a location with no department yet. Maybe you have just started setting up a new department in that location, but it&#39;s not yet in the database. In that case, there might be a null that would also not be returned with the COUNT(DISTINCT). Recall that it will not return nulls nor will it return duplicates. Okay, so to quickly summarize, COUNT(*) includes all duplicates and all nulls. COUNT with a column or an expression does not return nulls, but does include duplicates. COUNT(DISTINCT) will not return either. No nulls, no duplicates.</p></div></div></div><div class="section"><a name="section_4" /><h2 class="section_title">5. Video: Group Functions and NULL Values (it_dfosfd_13_enus_05)</h2><img src="https://cdn2.percipio.com/public/b/5badf0bb-7e9e-4669-a489-4416154cab1d/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/5badf0bb-7e9e-4669-a489-4416154cab1d/image001.jpg')();" /><div class="section_text">In this video, you will work with NULL values when grouping a set of rows in a SQL statement.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">work with NULL values when grouping a set of rows in a SQL statement</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: Group Functions and NULL Values. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>Now in our previous demonstration, we saw how you can use the COUNT(*) function to instruct the function to recognize nulls. But in fact that&#39;s the only one that supports the use of that star. All other group functions will ignore nulls by default. So in this demonstration we&#39;ll see how you can tell the other group functions to include nulls. And in fact, this is done using the NVL function. Now, this was covered in a previous lesson, but essentially what you do is you just nest this within the group function. So to demonstrate, we&#39;ll just see the results without it,</p>
<p>[Video description begins] <em> The Oracle SQL Developer : HR window is open. The HR tab is selected.</em> [Video description ends]</p>
<p>and I&#39;m going to SELECT the average commission, from the EMPLOYEES table, and as it is, this will not include nulls, okay? Now, I&#39;m also rounding this to two decimal places, so we do see a nested function here, but that&#39;s just to eliminate all of the decimals, okay? So again, this is not including the nulls. And we get an answer of 22%, okay?</p>
<p>[Video description begins] <em> He selects the SELECT ROUND(AVG(commission_pct),2) AS “Average Commssion Rate”, FROM EMPLOYEES; statement and clicks the execute icon. A table with Average Commssion Rate column header and one row appears in the Query Result tab. The value 0.22 is displayed under the Average Commssion Rate column header.</em> [Video description ends]</p>
<p>So, that&#39;s the Average Commission Rate among those who do earn commissions. But there are many employees who do not earn commission at all. Now, it doesn&#39;t really make sense to calculate the average commission and then to include people who do not earn commission. But we&#39;re just trying to demonstrate how this works, okay? So again I&#39;m rounding here, that&#39;s the outer most function but what we want to pay attention to here is the NVL function. So Recall the NVL function requires an argument representing what value should replace a null. So if we are working with numbers and we want to calculate, then 0 needs to be the replacement value. That&#39;s this argument right here, okay? So commission percentage is the column on which the NVL function is operating, and wherever it finds a null it is being instructed to replace it with a 0, okay?</p>
<p>That will allow us to calculate, so all the zeroes will be included in the average. So that is all nested within the average function, and again take note of the parentheses, and then all of that is simply being nested within the ROUND function. And I&#39;m specifying again 2 decimal places. So be sure you count up all your open parentheses and make sure you have all the appropriate closed ones. But let&#39;s take a look at the answer now. So in essence a lot of zeroes are going to be included in the average. So we should absolutely see the Average Commission Rate go down, okay? And I&#39;m giving this a lengthy alias just so it&#39;s indicative of what we are looking at. Average commission including employees who don&#39;t earn commission. So this is why I say it&#39;s not particularly practical but look at the answer, down to 7%. So all of those zeroes were now included in the calculation of the average,</p>
<p>[Video description begins] <em> He selects the SELECT ROUND(AVG(NVL(commission_pct,0)),2) AS “Average commission including employees who don’t earn commission&#34;, FROM EMPLOYEES; statement and clicks the execute icon. A table with Average commission including employees who don’t earn commission column header and one row appears in the Query Result tab. He points at the value 0.07 displayed under the Average commission including employees who don’t earn commission column header.</em> [Video description ends]</p>
<p>so again in this case that&#39;s probably not what you would want to do. But there could be any numeric column where you do want those nulls to be included, but they can&#39;t just be a null. They have to be replaced with a zero so that you can include them within the calculation, and that will generate a different answer.</p></div></div></div><div class="section"><a name="section_5" /><h2 class="section_title">6. Video: Creating Groups of Data (it_dfosfd_13_enus_06)</h2><img src="https://cdn2.percipio.com/public/b/bf8bb28b-2265-4efa-88e8-2e29a267c538/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/bf8bb28b-2265-4efa-88e8-2e29a267c538/image001.jpg')();" /><div class="section_text">In this video, learn how to create groups of data in an SQL statement.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">create groups of data in a SQL statement</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: Creating Groups of Data. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>In this presentation, we&#39;ll introduce the concept of creating groups of data. Now, up until this point, all of the group functions that have been demonstrated have been operating against every row of the table. And that&#39;s certainly fine. There will be many instances where that is exactly what you want. But in some cases, you might want to break the data down into smaller groups and examine just the groups, instead of every single record. And this is done by using a GROUP BY clause. And what the GROUP BY does is to examine a specified column or columns. And it will look for repetitive values. And wherever those repetitive values occur, that&#39;s the basis of forming the group. So in this example, we have a list of</p>
<p>[Video description begins] <em> Creating Groups of Data.</em> [Video description ends]</p>
<p>employees being returned, along with their department ID and their salary. And in the DEPARTMENT_ID, there are repetitive values because many people work in any given department. So there&#39;s only 1 in department 10 but that&#39;s fine, it&#39;s a group of one. There are 2 in department 20, so that&#39;s a group of two. There are 5 in department 50, that&#39;s a group of five. And it just carries on. So wherever those repeating values occur, that forms the group. Then, when the group function operates, it operates on each group. So now that I&#39;ve constructed the groups, the function can be anything but I could find out something like the average salary for each group or each department.</p>
<p>So, the GROUP BY clause, again, is how you form the groups. It divides the rows in the table into those smaller groups, based on the same value being present in that particular column. So in terms of the syntax, you still issue your SELECT statement and you choose whichever columns you want. And then the group function you want to perform from any given table. You can still restrict which rows come back by using a WHERE clause. But then we have the GROUP BY. And again, you would specify at least one column as the GROUP BY column, and that&#39;s where it will look for those repeating values. Then it can still have an ORDER BY if you want to.</p>
<p>[Video description begins] <em> The statement is SELECT column, group_function(column), FROM table, [WHERE condition], [GROUP BY group_by_expression], [ORDER BY column];.</em> [Video description ends]</p>
<p>Now, of course, we&#39;ll see examples of how to put this together, but there are a few quick rules that I do want to mention. If, let&#39;s just say you are using the SALARY column as the group function. So the average salary or the sum of the salary, then that column should not also be listed in the SELECT statement. So in other words, you should not say SELECT employee ID, department ID, salary, and then sum of salary, or average of salary, okay? Now, it is possible as long as you put salary in the GROUP BY clause as well. But then you&#39;d be creating groups based on duplicate values of salary, not department, okay? So in general, whatever column is being examined by the group function, should not be included in the SELECT statement, okay?</p>
<p>Now again, we&#39;ll see examples and in fact, we&#39;ll even see some of those rules in greater detail a little bit later on. But the basis is simply choosing a column that has those repetitive values. In other words, it really wouldn&#39;t make a lot of sense to GROUP BY a column that contains unique values. It would still work, but if you were to GROUP BY something like the employee ID, if they were 100 employees, you would end up with 100 groups, each with one member. So grouping on something unique doesn&#39;t make a lot of sense. You want to group on a column that contains repetitive values. So I can see all of the people in the same department or the same region, or all of the products in the same category. Basically something that repeats, and that will give you much more useful information for your group functions when they perform their calculations.</p></div></div></div><div class="section"><a name="section_6" /><h2 class="section_title">7. Video: GROUP BY Clause  (it_dfosfd_13_enus_07)</h2><img src="https://cdn2.percipio.com/public/b/038a8d08-d06c-4cd3-8530-95b1482847a0/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/038a8d08-d06c-4cd3-8530-95b1482847a0/image001.jpg')();" /><div class="section_text">Find out how to create groups of data and work with the GROUP BY clause in SQL statements.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">create groups of data and work with the GROUP BY clause in a SQL statement</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: GROUP BY Clause. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>All right, so in this demonstration we&#39;ll see how to implement the GROUP BY clause to break down group functions by other columns. Now to set this up, I&#39;ll issue a statement that does not use any grouping, just as a reference. So I&#39;ll SELECT the SUM of the salary column from the EMPLOYEES table.</p>
<p>[Video description begins] <em> The Oracle SQL Developer : HR window is open. The HR tab is selected.</em> [Video description ends]</p>
<p>And this Returns a single value representing the total cost of all salaries. Let&#39;s execute. And we get our answer.</p>
<p>[Video description begins] <em> He selects the SELECT SUM(salary), FROM EMPLOYEES; statement and clicks the execute icon. A tab;e with SUM(SALARY) column header and one row appears in the Query Result tab.</em> [Video description ends]</p>
<p>Now that&#39;s fine, you may want that value. But it doesn&#39;t really give you much context.</p>
<p>[Video description begins] <em> He points at the value 691416 displayed under the SUM(SALARY) column header.</em> [Video description ends]</p>
<p>So grouping allows you to apply that context. So in my second statement, I&#39;m going to Return a total for EACH department, representing the total cost of all salaries within that department. And instead of one row, we&#39;ll see 12 rows, okay? So in terms of the statement, I&#39;m going to SELECT out the department_id first. And this will act as little more than a header. And we&#39;ll see what that looks like in a moment. But I want to see the department_id. Then, still the same function. The SUM operating on the salary column, okay? There&#39;s nothing different about the function itself. But I&#39;m going to alias that as Total Salary per Department, okay? Still selecting FROM the EMPLOYEES table, but in the EMPLOYEES table, each employee has a department_id listed. And of course, any single department can have multiple employees.</p>
<p>So department_id in the EMPLOYEES table is a foreign key and can absolutely contain duplicate values, okay? And you typically want to GROUP BY a column that does contain duplicates, because that&#39;s how it creates groups. So all of the employees in department A, you go into this group. All of the employees in department B, you go into another group. All employees in department C, you go into another group. And then the function operates against each group, not the entire column, okay? So then I&#39;m just finishing up with an ORDER BY clause. And since the ORDER BY process is last, recall that we can reference the alias. And I&#39;m doing it in descending order, so that I simply see which department costs the most in terms of salary. So let&#39;s go ahead and execute. And there we see the breakdown, okay?</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, GROUP BY department_id, ORDER BY “Total Salary per Department” DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID and Total Salary per Department column headers and several rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>So this is what I was talking about when I said the department_id in the SELECT statement essentially acts as a header. So I see department 80 has that much in terms of total salary. Department 50 is next and it has that much. Department 90 is next and it has that much. So now I&#39;m getting that context. The function is operating on each group. That&#39;s what gives me the context. And if I were to add all of these up, it would equal that single value that I calculated in my first statement, okay? Now, I do want to point out that you will see a (null) here.</p>
<p>[Video description begins] <em> He points at the value (null) under the DEPARTMENT_ID column header.</em> [Video description ends]</p>
<p>And recall from our previous demonstration that the group functions ignore nulls, but that&#39;s not what&#39;s happening here. The (null) is in the DEPARTMENT_ID column, not the salary, okay? The group function of SUM is operating on the salary column. The (null) in the DEPARTMENT_ID simply means that there are some employees who have not yet been assigned to a department. Maybe they never will, okay? But again, the (null) is on the DEPARTMENT_ID, not the column that is being calculated, so it&#39;s perfectly fine to see a (null) here, all right? So again, the use of the GROUP BY allows you to create those groups. And when you are getting started with using GROUP BY, you will certainly want to use a column that is meaningful, that gives you context. But again, it should contain duplicate values.</p>
<p>If it was a unique value, then you wouldn&#39;t really get much context. If you were to GROUP BY, for example, the employee ID, well, every employee has a unique ID. It would still work, but you would effectively just see the salary for each employee. As opposed to the collection of employees within the group that you define, okay? So it should be a duplicating column and again, just when starting out, just use a single column as your GROUP BY. We will see, in the next demonstration, how to use more than one. But just until you get the feel of it, keep the GROUP BY columns to a single column. Then once you get comfortable, you can start adding in additional columns at any point in time.</p></div></div></div><div class="section"><a name="section_7" /><h2 class="section_title">8. Video: GROUP BY on Multiple Columns (it_dfosfd_13_enus_08)</h2><img src="https://cdn2.percipio.com/public/b/215461ce-de20-42da-8db0-616f354ed00b/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/215461ce-de20-42da-8db0-616f354ed00b/image001.jpg')();" /><div class="section_text">In this video, you will use the GROUP BY clause on multiple columns in a SQL statement.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">use the GROUP BY clause on multiple columns in a SQL statement</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: GROUP BY on Multiple Columns. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>All right, in our previous demonstration, we saw how to use a group by clause to break down your group functions so that you get a more comprehensive analysis. You simply get more context. And I did recommend that when you just get started using GROUP BY clauses, that you should try to keep it to a single column in the GROUP BY clause itself. And that is perfectly fine. But you absolutely can have more than one, so in this demonstration we&#39;ll see how to do exactly that. And there&#39;s nothing wrong with doing this, you just need to be mindful that the more columns you include in the GROUP BY, the more records you will get back. And if you go too far with this, it can simply become difficult to interpret the results, okay? So again, it&#39;s perfectly fine to have multiple columns in a GROUP BY, just be careful and try to keep it to a minimum number. Now, again, to set this up, what I&#39;m going to do is execute the exact same statement I just did in the previous demonstration. That was to Return a total for EACH department,</p>
<p>[Video description begins] <em> The Oracle SQL Developer : HR window is open. The HR tab is selected.</em> [Video description ends]</p>
<p>representing the total cost of all salaries within that department. So instead of seeing the total sum of every salary, I see it broken down now by department, and we got 12 rows back, okay? So let&#39;s just re-execute that exact same statement. There they are, okay?</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, GROUP BY department_id, ORDER BY “Total Salary per Department” DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID and Total Salary per Department column headers and several rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>So department 80 is costing me the most, I ordered these. And that is the total salary for that department. Department 50 is next, and this is the total for that department.</p>
<p>[Video description begins] <em> He points at the value 304500 under the Total Salary per Department column header adjacent to the value 80 under the DEPARTMENT_ID column header.</em> [Video description ends]</p>
<p>So again, that is exactly the same as in the previous demonstration.</p>
<p>[Video description begins] <em> He points at the value 156400 under the Total Salary per Department column header adjacent to the value 50 under the DEPARTMENT_ID column header.</em> [Video description ends]</p>
<p>This is fine, but maybe I want yet a little bit more information. I want to go a little bit deeper with my analysis. Well, within each department there can be multiple employees. And among those employees, there could be people with different job titles. There could be several with the same job title, but there could be others as well. So what I want to do now is further break this down by including the job ID. So now, I&#39;m Returning a total of salaries for EACH job_id within each department. Since I&#39;m including another column in the GROUP BY, I&#39;m going to get 20 rows, okay? And you will always get, I won&#39;t say every single time, but you will almost always get more rows back. You would never get fewer. You might get the same, but even that&#39;s doubtful. But it&#39;s going to still group together all of the departments, then within those groups, it will examine the job ID. And it will do the same thing, it will look for the duplicates and gather them up.</p>
<p>But there could be three, or four, or five different job IDs within any single department, so it creates groups within groups. So therefore, you always get either the same or more rows coming back, okay, so 20 in this case. So let&#39;s look at the SELECT statement, since I am now breaking it down by the job_id, I have included that column in the SELECT statement. So I still want my department_id but now I also want to see the job_id, then still the group function, SUM of the salary, and again that does not change, okay? The function itself does not change, you still want to sum the salaries, but it will do so based on every column of the GROUP BY. I&#39;m aliasing that still as Total Salary per Department. In this case, I didn&#39;t bother changing it, but let&#39;s actually put that in, Total Salary per jobid, per Department, okay? Still FROM the EMPLOYEES table and here&#39;s my GROUP BY, and we simply include both columns, department_id and job_id. But you do need to be mindful of the order. Whichever one is listed first is which groups will be created first.</p>
<p>So in this case, it will group by the departments, then within each department, it will then group the jobs. So if I were to reverse that, it would create the job_id group first, then within those duplicates, it would group the department. And that could result in differences in terms of the results coming back. So again that&#39;s up to you, just be mindful that the order does matter. You can try it either way, okay? But ultimately, try to determine which one is more meaningful. And in this case, I&#39;m still ordering but I&#39;m just going to order by the department_id. So that we can see the duplicate values coming back for the department_id, and then the individual job IDs within that department, okay? So we execute. And again, we still see a (null) because</p>
<p>[Video description begins] <em> He selects the SELECT department_id, job_id, SUM(salary) AS “Total Salary per jobid, per Department”, FROM EMPLOYEES, GROUP BY department_id, job_id, ORDER BY department_id DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID, JOB_ID, and Total Salary per jobid, per Department column headers and several rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>that&#39;s in the DEPARTMENT_ID, that&#39;s fine. We do have a single SA_REP who has not been assigned to any department. So a (null) still comes back, that&#39;s fine.</p>
<p>[Video description begins] <em> He points at the value SA_REP under the JOB_ID column header adjacent to the (null) value under the DEPARTMENT_ID column header.</em> [Video description ends]</p>
<p>It&#39;s not in the salary column. But if we look now at the DEPARTMENT_ID, we see two entries for 110. And that is because there are two different JOB_IDs in that department, and then these are the respective total salaries for each of those JOB_IDs . Then we see another duplicate and department 100,</p>
<p>[Video description begins] <em> He points at the values AC_ACCOUNT and AC_MGR under the JOB_ID column header and values 39600 and 12008 under the Total Salary per jobid, per Department column header adjacent to the value 110 under the DEPARTMENT_ID column header.</em> [Video description ends]</p>
<p>again because there are two different JOB_IDs within department 100. And again, we see the total salary for each of those JOB_IDs, and again this just continues.</p>
<p>[Video description begins] <em> He points at the values FI_ACCOUNT and FI_MGR under the JOB_ID column header and values 8300 and 12008 under the Total Salary per jobid, per Department column header adjacent to the value 100 under the DEPARTMENT_ID column header.</em> [Video description ends]</p>
<p>So we&#39;re seeing groups within groups, all right? And that is essentially all that happens when you have multiple columns in a GROUP BY statement. You can have groups within groups, that&#39;s perfectly fine and you can keep going, you can have groups within groups within groups. But that&#39;s where things start to get a little complicated. If you have too many groups within groups within groups within groups, it just gets difficult to perform any kind of analysis. So again, I do recommend that you keep the number of columns in your GROUP BY clauses to as few as possible. That just makes it easier to perform your analysis and understand the results. Too much grouping just complicates things, okay? But it is certainly fine to include multiple columns in a GROUP BY clause.</p></div></div></div><div class="section"><a name="section_8" /><h2 class="section_title">9. Video: Illegal Queries (it_dfosfd_13_enus_09)</h2><img src="https://cdn2.percipio.com/public/b/c0d411c9-e516-474a-be72-8051e21703b0/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/c0d411c9-e516-474a-be72-8051e21703b0/image001.jpg')();" /><div class="section_text">In this video, find out how to apply illegal queries when using the GROUP BY clause in a SQL statement.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate illegal queries when using the GROUP BY function in a SQL statement</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: Illegal Queries. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>All right, in our previous demonstrations, we&#39;ve seen how to use the GROUP BY clause and we&#39;ve seen how to use group functions. And how to put them together to perform more detailed analysis. But as you start assembling these statements, there are some rules that you need to be mindful of.</p>
<p>And if those rules are violated, you&#39;ll get some errors. So in this demonstration, we&#39;ll see how you can recognize those illegal grouping operations by intentionally making some mistakes. And in fact, the Oracle SQL Developer application is kind enough to tell us when those mistakes are happening.</p>
<p>[Video description begins] <em> The Oracle SQL Developer : HR window is open. The HR tab is selected.</em> [Video description ends]</p>
<p>There is a yellow squiggly line underneath the error. Syntactically it looks correct, but we are violating the rules of grouping. So our first rule is that a column cannot be listed in the SELECT statement that is not also listed in the GROUP BY. So in this case, I&#39;m selecting the department_id and the job_id, then the group function, in this case SUM on the salary column. From the EMPLOYEES table, but notice that I am only grouping by the department_id. So this will cause a problem. If I&#39;m selecting two columns but grouping only by one of them, it simply will not work.</p>
<p>The GROUP BY expects in this case to create the groups within the groups. The collection of job IDs within the collections of department ID. So this quite simply will fail. We&#39;ll execute and we get an error, okay?</p>
<p>[Video description begins] <em> He selects the SELECT department_id, job_id, SUM(SALARY), FROM EMPLOYEES, GROUP BY department_id, ORDER BY department_id DESC; statement and clicks the execute icon. An error is displayed in the Query Result tab.</em> [Video description ends]</p>
<p>So the solution is, in this case, to remove the job_id from the SELECT statement or to add it to the GROUP BY, either will suffice, okay? So I&#39;ll add it to the GROUP BY and as soon as I do that, the yellow squiggly line disappears.</p>
<p>[Video description begins] <em> He alters the GROUP BY department_id to GROUP BY department_id, job_id from the SELECT department_id, job_id, SUM(SALARY), FROM EMPLOYEES, GROUP BY department_id, ORDER BY department_id DESC; statement.</em> [Video description ends]</p>
<p>Now, essentially everything matches up. I&#39;m allowing it to create the groups within the groups and this statement succeeds, okay?</p>
<p>[Video description begins] <em> He selects the SELECT department_id, job_id, SUM(SALARY), FROM EMPLOYEES, GROUP BY department_id, job_id, ORDER BY department_id DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID , JOB_ID, and SUM(SALARY) column headers and several rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>The next problem is that a column cannot be specified in both the SELECT statement and the group function. So in this case, I&#39;ve selected out the department_id, the salary, then I&#39;m trying to sum the salary. This will generate another error, okay? I cannot see each individual salary, and then see a sum of all salaries. So again, if I execute, I get an error.</p>
<p>[Video description begins] <em> He selects the SELECT department_id, salary, SUM(SALARY), FROM EMPLOYEES, GROUP BY department_id, ORDER BY department_id DESC; statement and clicks the execute icon. An error is displayed in the Query Result tab.</em> [Video description ends]</p>
<p>So this is a fairly easy fix, in most cases you would just remove the salary from the SELECT statement, in this particular example. Or, of course, you could use a column that is listed for the group function. So in other words, I could sum by something else, okay? But you cannot have the same column in the SELECT statement and in the group function. So let&#39;s just get rid of salary in this case from the SELECT statement, re-execute, and we get our results.</p>
<p>[Video description begins] <em> He alters SELECT department_id, salary, SUM(SALARY) to SELECT department_id, SUM(SALARY) from the SELECT department_id, salary, SUM(SALARY), FROM EMPLOYEES, GROUP BY department_id, ORDER BY department_id DESC; statement.</em> [Video description ends]</p>
<p>The next illegal operation is A column cannot be listed in the group function that is also in the GROUP BY.</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(SALARY), FROM EMPLOYEES, GROUP BY department_id, ORDER BY department_id DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID and SUM(SALARY) column headers and several rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>So in this case I&#39;m selecting the department_id and a sum of the salary in the SELECT statement but then I&#39;m attempting to GROUP BY the salary. So again, it&#39;s similar to the previous one where I can&#39;t have the same column in the SELECT statement and the function. I also cannot have the same column in the group function and the GROUP BY, okay? So again, I&#39;m seeing the yellow squiggly line. And if I execute, I get an error.</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary), FROM EMPLOYEES, GROUP BY salary, ORDER BY department_id DESC; statement and clicks the execute icon. An error is displayed in the Query Result tab.</em> [Video description ends]</p>
<p>So again, the solution is to GROUP BY a different column, or use a different column for the group function, as long as it&#39;s not the same. So let&#39;s GROUP BY the department_id in this case and now we get results.</p>
<p>[Video description begins] <em> He alters GROUP BY salary to GROUP BY department_id from the SELECT department_id, SUM(salary), FROM EMPLOYEES, GROUP BY salary, ORDER BY department_id DESC; statement.</em> [Video description ends]</p>
<p>Okay so, those are the illegal operations.</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary), FROM EMPLOYEES, GROUP BY department_id, ORDER BY department_id DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID and SUM(SALARY) column headers and several rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>But I do want to point out that you can GROUP BY a column that is not in the SELECT list, okay? But this makes it rather difficult to understand the results. So here I&#39;m selecting just the group function. The SUM of the salary, that&#39;s the only thing I&#39;m selecting, and I am grouping by the department_id, okay? So in other words, I&#39;m not selecting the department_id. This does work. Okay, we can execute and we get results.</p>
<p>[Video description begins] <em> He selects the SELECT SUM(salary), FROM EMPLOYEES, GROUP BY department_id, ORDER BY department_id DESC; statement and clicks the execute icon. A table with SUM(SALARY) column header and several rows appears in the Query Result tab. He points at the values displayed under the SUM(SALARY) column header.</em> [Video description ends]</p>
<p>But I&#39;ve told it to GROUP BY the department_id, but in my results I don&#39;t see the department_id. So that&#39;s why I say it&#39;s rather difficult to understand the results. I&#39;m just getting a number back but I do not know which department is being represented by this value, okay? So the recommendation here, not so much a solution because this did work. The Recommendation is to include the GROUP BY column in the SELECT list. So the GROUP BY column is department_id. Let&#39;s just copy this, and paste it into the SELECT statement. Put a comma in, re-execute.</p>
<p>[Video description begins] <em> He alters SELECT SUM(salary) to SELECT department_id, SUM(salary) from the SELECT SUM(salary), FROM EMPLOYEES, GROUP BY department_id, ORDER BY department_id DESC; statement.</em> [Video description ends]</p>
<p>And now we see, essentially, labels, okay?</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary), FROM EMPLOYEES, GROUP BY department_id, ORDER BY department_id DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID and SUM(SALARY) column headers and several rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>This department has that total salary. So again, that works, but not really recommended because it&#39;s difficult to understand the results.</p>
<p>[Video description begins] <em> He points at the values 110 and 20308 under the DEPARTMENT_ID and SUM(SALARY) column headers, respectively.</em> [Video description ends]</p>
<p>So always just be mindful of those rules when you are assembling your GROUP BY statements with group functions. And you should avoid those errors.</p></div></div></div><div class="section"><a name="section_9" /><h2 class="section_title">10. Video: Restricting Group Results Using the HAVING Clause (it_dfosfd_13_enus_10)</h2><img src="https://cdn2.percipio.com/public/b/203de040-2da3-4067-b730-dc42ffbc5185/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/203de040-2da3-4067-b730-dc42ffbc5185/image001.jpg')();" /><div class="section_text">During this video, you will learn how to use the HAVING clause to restrict the grouped rows returned in a SQL statement.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">use the HAVING clause to restrict grouped rows returned in a SQL statement</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: Restricting Group Results Using the HAVING Clause. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>In all of our demonstrations for this course so far, we have not been implementing any kind of filtering or restriction of rows. You might recall from earlier demonstrations that we can do that using a WHERE clause. But in this demonstration things are little bit different and we&#39;ll see how you can still restrict the rows, but by using what&#39;s known as a HAVING clause. Now before we get to that, let&#39;s just rerun a statement from an earlier demonstration that was not restricted, okay?</p>
<p>[Video description begins] <em> The Oracle SQL Developer : HR window is open. The HR tab is selected.</em> [Video description ends]</p>
<p>So I&#39;m just selecting out the department_id, the SUM of the salary column as Total Salary per Department from my EMPLOYEES table. And I&#39;m grouping by the department_id, hence the alias of Total Salary Per Department. And I&#39;m also ordering that, but again, this is not restricted, okay? I get 12 rows, and I&#39;m seeing the total salary for all 12 departments.</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, GROUP BY department_id, ORDER BY “Total Salary per Department” DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID and Total Salary per Department column headers and several rows in the Query Result tab.</em> [Video description ends]</p>
<p>Okay, great, that&#39;s fine. But maybe you might not be interested in all of these records. For example, if we look at the Total Salary per Department, there are several departments with much higher values than others. So maybe I&#39;m only interested in those higher value records. So, I can implement a filter. Now, as mentioned, we know that a WHERE clause can operate as a filter. But not against a column that is being operated on by a group function, okay?</p>
<p>The WHERE clause operates on entire record set. It basically does not recognize these summarized or grouped values, such as the sum of the salary per department. So before I even try to execute the code that I have here, I&#39;ll show you that, I&#39;ll replace the HAVING keyword with WHERE.</p>
<p>[Video description begins] <em> He alters HAVING SUM(salary) &gt;&#61; 25000 to WHERE SUM(salary) &gt;&#61;25000 from the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, GROUP BY department_id, HAVING SUM(salary) &gt;&#61; 25000, ORDER BY “Total Salary per Department” DESC; statement.</em> [Video description ends]</p>
<p>And I immediately get a little red squiggly line indicating an error. So if I attempt to execute by using a where clause on the SUM(salary) column, it fails, okay?</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, GROUP BY department_id, WHERE SUM(salary) &gt;&#61; 25000, ORDER BY “Total Salary per Department” DESC; statement and clicks the execute icon. An error is displayed in the Query Result tab.</em> [Video description ends]</p>
<p>So that&#39;s why the HAVING clause was introduced. It is required if you want to filter by the group function column, okay? You restrict your rows returned by the group function with a HAVING clause, a WHERE clause cannot reference a group function column.</p>
<p>[Video description begins] <em> He alters WHERE SUM(salary) &gt;&#61; 25000 to HAVING SUM(salary) &gt;&#61;25000 from the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, GROUP BY department_id, WHERE SUM(salary) &gt;&#61; 25000, ORDER BY “Total Salary per Department” DESC; statement.</em> [Video description ends]</p>
<p>So let&#39;s change my WHERE clause back to HAVING, and then I can specify the function. So HAVING a sum of the salary greater than or equal to 25,000, okay? That represents the upper values. Let&#39;s re-execute, and I get my records but there are only five now, so I have restricted the rows that are coming back.</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, GROUP BY department_id, HAVING SUM(salary) &gt;&#61; 25000, ORDER BY “Total Salary per Department” DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID and Total Salary per Department column headers and five rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>In the first example we got 12. I filtered out the lower values now, and I only get five, okay? But it does depend on what you want to use as the filter. In my last example, I do have a WHERE clause, but it&#39;s not operating on the group function column, it&#39;s operating on the department ID. So now, I&#39;m still selecting out the exact same columns, department_id, and a sum of the salary from EMPLOYEES. But instead of restricting based on the total sum, I&#39;m restricting based on the department_id.</p>
<p>So where department_id is in this group of 50, 80, or 90, okay? Then I can still have my GROUP BY, and I can still have my HAVING as well. There&#39;s no problem with having two filters. So, this having a sum of the salary of greater than or equal to 25,000, we just saw returned five rows. But I can further restrict that by saying, well, I only want to focus on these three departments of those five rows. So let&#39;s execute, and now we only get three rows, okay?</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, WHERE BY department_id IN (50, 80, 90), HAVING SUM(salary) &gt;&#61; 25000, ORDER BY “Total Salary per Department” DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID and Total Salary per Department column headers and three rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>So these satisfied both conditions. The Total of the Salary per Department is greater than or equal to 25,000. But I only see departments, 50, 80 and 90 as specified by the WHERE clause, okay? Now, I should tell you that you can do this another way. This is up to you but although the WHERE clause cannot reference the group function. A HAVING clause can reference other columns other than just the group function column. So HAVING is currently operating on the SUM column, but I could also do this. Put AND after the HAVING statement here, and then say department_id IN, and use the exact same criteria, 50, 80, 90. And just remove the WHERE clause entirely, I&#39;ll just comment it out.</p>
<p>[Video description begins] <em> He alters HAVING SUM(salary) &gt;&#61; 25000 to HAVING SUM(salary) &gt;&#61; 25000 AND department_id IN (50, 80, 90) from the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, WHERE BY department_id IN (50, 80, 90), HAVING SUM(salary) &gt;&#61; 25000, ORDER BY “Total Salary per Department” DESC; statement.</em> [Video description ends]</p>
<p>So now my HAVING is operating on both the group function column, and the department_id, a regular column for lack of a better word.</p>
<p>[Video description begins] <em> He comments out the WHERE BY department_id IN (50, 80, 90) from the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, WHERE BY department_id IN (50, 80, 90), HAVING SUM(salary) &gt;&#61; 25000 AND department_id IN (50, 80, 90) , ORDER BY “Total Salary per Department” DESC; statement.</em> [Video description ends]</p>
<p>And this produces the same results, okay?</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, WHERE BY department_id IN (50, 80, 90), HAVING SUM(salary) &gt;&#61; 25000 AND department_id IN (50, 80, 90) , ORDER BY “Total Salary per Department” DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID and Total Salary per Department column headers and three rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>So again, it depends on what you want to use as a filter. But if you are wanting to use the group function column as your filter, you must use a HAVING clause. WHERE can still be used on any other column, but not the group function column.</p></div></div></div><div class="section"><a name="section_10" /><h2 class="section_title">11. Video: Nesting Group Functions (it_dfosfd_13_enus_11)</h2><img src="https://cdn2.percipio.com/public/b/fd00ea0e-133b-4981-bcdf-fb74e6c70079/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/fd00ea0e-133b-4981-bcdf-fb74e6c70079/image001.jpg')();" /><div class="section_text">In this video, learn how to use nested group functions in a SQL statement to a depth of two functions.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">nest group functions to a depth of two functions in a SQL statement</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: Nesting Group Functions. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>Okay, for our last demonstration, we&#39;ll take a look at nesting group functions but before we get to the examples, a couple of rules to take note of here.</p>
<p>[Video description begins] <em> The Oracle SQL Developer : HR window is open. The HR tab is selected.</em> [Video description ends]</p>
<p>A GROUP BY clause is required when nesting group functions, and group functions can only be nested to 2 levels. Now, that&#39;s not necessarily a bad thing. When nesting comes into play, I recommend you try to keep it to as few levels as possible. But one way or the other, you are limited to just two, when it comes to group functions. Now, I stress that, that&#39;s just group functions. In other words, you can nest beyond 2 levels if you are using a NON-group function (for example ROUND). That&#39;s not a group function, it&#39;s just concerned with removing decimal places from a value. So, in fact, we&#39;ll see that in a mo</p>
<p>ent but the group functions such as MAX, MIN, AVERAGE, SUM, they can only be nested to two levels, okay? So in our first example, I&#39;m not using any nesting. I&#39;m just determining the average salary for each department again, okay? So I&#39;m selecting the department_id, the AVG of the salary column from EMPLOYEES, but I am still grouping by the department_id. Now since I&#39;m not nesting, I actually would not need to GROUP BY. Okay, but I want to see the average salary per department. So, we&#39;ll execute, and I get my results.</p>
<p>[Video description begins] <em> He selects the SELECT department_id, AVG(salary), FROM EMPLOYEES, GROUP BY department_id; statement and clicks the execute icon. A table with DEPARTMENT_ID and AVG(SALARY) column headers and several rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>All right, but now, of those results, and there are 12, I want to know which one of those 12 is the highest value, okay? So I can determine which of the departmental average salary values is the highest by nesting that within a MAX function. Now, that said, another note here, since the MAX function can only return a single value, representing the highest GROUP average, the department_id column can no longer be included in the SELECT list, okay?</p>
<p>So now my code is just selecting the maximum average salary. So, we do see a nested function here, average salary is the inner function, it is then nested within the MAX function. So again, be mindful of the parentheses. For every open parentheses, there needs to be a closed. So we have two open, two closed, okay? The average salary needs to be fully nested within another set of parentheses. And again, we cannot include the department_id column. But let&#39;s execute and again, we are still grouping by the department_id. So, of all departmental averages, we get the highest by nesting it within the MAX, okay? But again, I cannot include the department ID.</p>
<p>[Video description begins] <em> He selects the SELECT MAX(AVG(salary)), FROM EMPLOYEES, GROUP BY department_id; statement and clicks the execute icon. A table with MAX(AVG(SALARY)) column header and one row appears in the Query Result tab.</em> [Video description ends]</p>
<p>Let&#39;s find out here. Let&#39;s see the error. I&#39;ll add it back in, department_id and re-execute and I get an error, okay?</p>
<p>[Video description begins] <em> He alters SELECT MAX(AVG(salary)) to SELECT department_id, MAX(AVG(salary)) from the SELECT MAX(AVG(salary)), FROM EMPLOYEES, GROUP BY department_id; statement.</em> [Video description ends]</p>
<p>Selecting out the single column is not a group function.</p>
<p>[Video description begins] <em> He selects the SELECT department_id, MAX(AVG(salary)), FROM EMPLOYEES, GROUP BY department_id; statement and clicks the execute icon. An error is displayed in the Query Result tab.</em> [Video description ends]</p>
<p>I have nested the function. So essentially there are two functions happening. This column is not part of those functions, so it cannot be included any longer, okay?</p>
<p>[Video description begins] <em> He alters SELECT department_id, MAX(AVG(salary)) to SELECT MAX(AVG(salary)) from the SELECT department_id, MAX(AVG(salary)), FROM EMPLOYEES, GROUP BY department_id; statement. He selects the SELECT MAX(AVG(salary)), FROM EMPLOYEES, GROUP BY department_id; statement and clicks the execute icon. A table with MAX(AVG(SALARY)) column header and one row appears in the Query Result tab.</em> [Video description ends]</p>
<p>Now, as mentioned, I can nest one more level, if it&#39;s not a group function. So, in my final example here, I have taken that maximum average salary, which produced several decimal places and I am rounding it, okay? So, in this case, again, you just need to be mindful of all of the parentheses. For every open parenthesis, there needs to be a closed. So now there are three open parentheses, therefore I need three closed. And the ROUND function does allow me to specify how many decimal places but I&#39;ll just keep it simple in this case. But this does work, okay? All of the decimal places have now been removed.</p>
<p>[Video description begins] <em> He selects the SELECT ROUND(MAX(AVG(salary))), FROM EMPLOYEES, GROUP BY department_id; statement and clicks the execute icon. A table with ROUND(MAX(AVG(salary))) column header and one row appears in the Query Result tab.</em> [Video description ends]</p>
<p>But ROUND, again, is not a group function.</p>
<p>[Video description begins] <em> He points at the value 19333 under the ROUND(MAX(AVG(salary))) column header.</em> [Video description ends]</p>
<p>So when you are working with just group functions, you can only go two levels deep. Well, that&#39;s exactly what I did with my nested average inside of the MAX function. But then all of that can be rounded because ROUND is not a group function, okay? But again, I do still recommend you try to keep all nesting to as few layers as possible.</p></div></div></div><div class="section"><a name="section_11" /><h2 class="section_title">12. Video: Exercise: Use GROUP BY and HAVING (it_dfosfd_13_enus_12)</h2><img src="https://cdn2.percipio.com/public/b/989cce85-c0c0-437b-b5dd-d52e17602a8f/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/989cce85-c0c0-437b-b5dd-d52e17602a8f/image001.jpg')();" /><div class="section_text">Learn how to write SQL statements using the GROUP BY and HAVING clauses.</div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">write SQL statements using GROUP BY and HAVING</li></ul><div class="section inner"><div class="section_text"><p>[Video description begins] <em> Topic title: Exercise: Use GROUP BY and HAVING. The presenter is Aaron Sampson.</em> [Video description ends]</p>
<p>All right, time for an exercise, and this time we&#39;ll ask you to use the AVG and SUM functions in a SQL statement. Then, to use the COUNT and COUNT DISTINCT functions in a SQL statement. Then, to create groups of data by using the GROUP BY clause. And finally, to use the HAVING clause to restrict grouped rows returned in a SQL statement. So again, what we&#39;d like you to do is to take a few minutes and try these exercises on your own. Then we&#39;ll come back to review and we&#39;ll see how you made out. So we&#39;ll see you in a few minutes. All right, to review some possible solutions.</p>
<p>[Video description begins] <em> The Oracle SQL Developer : HR window is open. The fourth part includes four HR tabs: HR, HR ~ 1, HR ~ 2, and HR ~ 3. The HR tab is selected.</em> [Video description ends]</p>
<p>In our first task, we asked you to use the SUM and AVG group functions. So we could select SUM of the salary column. And again, the column goes inside parentheses. And optionally, you could alias that. I&#39;m using Sum of Rep Salaries as my alias, then comma, and the average, AVG of the salary column. So they can both operate on the same column, that&#39;s fine, but a single function cannot operate on more than one column.</p>
<p>That again is aliased as Average Rep Salary from the EMPLOYEES table. And optionally, a WHERE clause I&#39;m looking for job ID&#39;s that include the character&#39;s REP anywhere in the title. So we can execute, and we see the Sum of all Rep Salaries and the Average Rep Salary. And do take note the average has many decimal places.</p>
<p>[Video description begins] <em> He selects the SELECT SUM(salary) AS “Sum of Rep Salaries”, AVG(salary) AS “Average Rep Salary”, FROM EMPLOYEES, WHERE job_id LIKE ‘%REP%’; statement and clicks the execute icon. A table with the Sum of Rep Salaries and Average Rep Salary column headers and one row appears in the Query Result tab.</em> [Video description ends]</p>
<p>So it&#39;s a good candidate for nesting it inside a ROUND, or even a truncate function for that matter, but that is also optional. Then we asked to use the COUNT and COUNT DISTINCT group functions.</p>
<p>[Video description begins] <em> He clicks the HR ~ 1 tab.</em> [Video description ends]</p>
<p>And take note that COUNT with a column or expression specified does not return nulls, but does return duplicates. So we can select the COUNT function. In this case, on the commission_pct column, again in parentheses, optionally, aliased as Number of Employees Earning Commission. So it does not return nulls, so as long as there is a value, or the commission_pct, it will add it to the COUNT. For employees who do not receive any commission, they will not be included. So we can execute. And we get a count of only those employees who earned commission.</p>
<p>[Video description begins] <em> He selects the SELECT COUNT(commission_pct) AS “Number of Employees Earning Commission”, FROM EMPLOYEES; statement and clicks the execute icon. A table with Number of Employees Earning Commission column header and one row appears in the Query Result tab. The value 35 is displayed under the Number of Employees Earning Commission column header.</em> [Video description ends]</p>
<p>COUNT DISTINCT will not return nulls, nor will it return any duplicates, okay? So in my first example, I&#39;m not using the DISTINCT. I&#39;m just using a COUNT just for comparison purposes. So I&#39;m counting the location_id calling that Total Number of Departments in all Locations. When we execute, there are 28, okay?</p>
<p>[Video description begins] <em> He selects the SELECT COUNT(location_id) AS “Total Number of Departments in all locations”, FROM DEPARTMENTS; statement and clicks the execute icon. A table with Total Number of Departments in all Locations column header and one row appears in the Query Result tab. The value 28 is displayed under the Total Number of Departments in all Locations column header.</em> [Video description ends]</p>
<p>But if we COUNT DISTINCT on the exact same column from the exact same table, the duplicates are removed and we only get 7.</p>
<p>[Video description begins] <em> He selects the SELECT COUNT(DISTINCT location_id) AS “Number of Locations with Departments”, FROM DEPARTMENTS; statement and clicks the execute icon. A table with Number of Locations with Departments column header and one row appears in the Query Result tab. He points at the value 7 displayed under the Number of Locations with Departments column header.</em> [Video description ends]</p>
<p>So what that means is that there are some locations with multiple departments. So the duplicates were not being returned when we COUNT DISTINCT, okay? Then we asked to use the GROUP BY clause which can be used to break down group functions by other columns to essentially analyze the data a little more effectively. A group function operating on all of the values in a column returns a single value and that&#39;s fine.</p>
<p>[Video description begins] <em> He clicks the HR ~ 2 tab.</em> [Video description ends]</p>
<p>But it doesn&#39;t really give you any kind of context or breakdown. So in this case I&#39;m returning a total of the salary, so I&#39;m using the SUM(salary) to get a total for each department, not a grand total. So I SELECT the department_id, the SUM of the salary as Total Salary per Department, from EMPLOYEES, but then I GROUP BY the department_id. This will locate the duplicate values in this table for the department ID, gather them all together. And then the group function will operate on each set or each group instead of the entire set of records in the whole table. I can order by that optionally but whereas if I did not GROUP BY, I would get one record back, with the GROUP BY, I get 12 in this case.</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, GROUP BY department_id, ORDER BY “Total Salary per Department” DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID and Total Salary per Department column headers and several rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>Because there are these 12 unique departments plus a (null) in this case, where there is someone who does not have a department but that&#39;s fine. Okay, but I get multiple records back, a total per department instead of a grand total for all departments. That&#39;s the essence of the GROUP BY, create those subgroups within that table. And finally, we asked about restricting the rows being returned by a group function, by using a HAVING clause.</p>
<p>[Video description begins] <em> He clicks the HR ~ 3 tab.</em> [Video description ends]</p>
<p>Conceptually, it operates the same as a WHERE clause in that it&#39;s a filter but a WHERE clause cannot reference the group function column, okay? So HAVING does exactly that. So I&#39;m selecting the department_id, then a SUM of the salary. So if I were to not include a HAVING, every record would come back, every departmental salary would be returned. But maybe I&#39;m not interested in all of them. So I can use a HAVING clause against the SUM of the salary, the group function and specify some kind of condition, in my case, greater than or equal to 25000. So anything that does not meet that criteria is simply not returned. And again, optionally it can be ordered, but that&#39;s not required. So if I execute, only 5 rows are returned.</p>
<p>[Video description begins] <em> He selects the SELECT department_id, SUM(salary) AS “Total Salary per Department”, FROM EMPLOYEES, GROUP BY department_id, HAVING SUM(salary) &gt;&#61; 25000, ORDER BY “Total Salary per Department” DESC; statement and clicks the execute icon. A table with DEPARTMENT_ID and Total Salary per Department column headers and five rows appears in the Query Result tab.</em> [Video description ends]</p>
<p>Recall that previously, without any kind of criteria, 12 rows came back. But since I have now specified that the SUM of the salary must have a total of greater than or equal to 25,000, 7 rows were filtered out, okay? You can still use a WHERE clause but the WHERE clause cannot reference the group function. It can reference any other column, that&#39;s fine, but if you want to use the group function as a filter, then you have to use the HAVING clause. So hopefully, you made out all right with those exercises. And if so, we are ready to move on to our next course.</p></div></div></div><div class="copyright-container"><span class="copyright-text">© 2023 Skillsoft Ireland Limited - All rights reserved.</span></div></div><div id="lb-overlay"><div class="lb-header"><button onclick="(()=>{const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'hidden';const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 1.0;curtain.style.backgroundColor = 'white';curtain.style.pointerEvents = 'auto';})();">X</button></div><div id="lb-image-container"><img id="lb-image" alt onload="(()=>{const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 0.5;curtain.style.backgroundColor = 'grey';curtain.style.pointerEvents = 'none';const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'visible';window.scrollTo(0, 0);})();"/></div><div class="lb-footer" /></div></div></body></html>