<!doctype html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-style-type" content="text/css2"><title>Course Transcript</title><link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css"><style>:root {
    --title-text: #243038;
    --toc-link: #0073C4;
    --section-title-text: #243038;
    --section-title-border: #bababa;
    --grid-caption-text: #164794;
    --grid-border: #c0c0c0;
    --grid-hdr-text: #973131;
    --grid-hdr-background: #f7f7f7;
    --missing-data: #767676;
    --text-color: #343434;
    --lightbox-border: #a0a0a0;

    --bold-font-weight: 700;

    font-family: Lato;
}

.report {
    margin: 24px;
}

.container {
    position: relative;
}

#lb-curtain {
    background-color: white;
    opacity: 1.0;
}

#lb-overlay {
    position: absolute;
    top: 40px;
    left: 20px;
    right: 20px;
    background-color: white;
    border: solid 1px var(--lightbox-border);
    visibility: hidden;
}

.lb-header, .lb-footer {
    height: 40px;
    line-height: 40px;
}

.lb-header {
    display: flex;
    justify-content: flex-end;
    padding-right: 20px;
}

#lb-image-container {
    margin: 0 40px;
}

#lb-image {
    width: 100%;
}

.report_title {
    font-size: 22px;
    font-weight: var(--bold-font-weight);
    color: var(--title-text);
}

.toc_link {
    font-size: 14px;
    color: var(--toc-link);
    margin-top: 6px;
    margin-bottom: 0;
}

.section {
    margin-top: 40px;
    margin-left: 16px;
}

.section.inner {
    margin-top: 20px;
}

.section.inline {
    margin-top: 20px;
    margin-left: 0;
}

.section_title {
    font-size: 18px;
    font-weight: var(--bold-font-weight);
    width: 100%;
    color: var(--section-title-text);
}

h2.section_title {
    border-bottom-color: var(--section-title-border);
    border-bottom-style: solid;
    border-bottom-width: thin;
}

h3.section_title {
    margin: 8px 0;
}

h3.list_title {
    margin: 8px 0;
    font-size: 14px;
    color: var(--title-text);
}

.section_text {
    font-size: 14px;
    color: var(--text-color);
    margin: 12px 0;
    width: 90%;
}

.section_link {
    font-size: 14px;
    margin: 12px 0;
    width: 90%;
}

.grid {
    border-collapse: collapse;
}
.grid_caption {
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    color: var(--grid-caption-text);
    margin: 12px 0;
    text-align: left;
    white-space: nowrap;
}
.grid_hdr_row {

}
.grid_col {
    font-size: 13px;
    color: var(--text-color);
    border-collapse: collapse;
    padding: 2px;
    text-align: left;
    vertical-align: top;
}
.grid_col_hdr, .grid_row_hdr {
    font-size: 12px;
    font-weight: var(--bold-font-weight);
    white-space: nowrap;
}
.grid_row_hdr {

}

.empty_grid {
    border-collapse: collapse;
    border-color: var(--grid-border);
    border-style: solid;
    border-width: 2px;
    padding: 4px;
    text-align: center;
}

.htmlbox {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    padding: 8px;
}

.list {
    font-size: 14px;
    font-style: italic;
}

.missing_data {
    color: var(--missing-data);
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    font-style: italic;
}

.copyright-container {
    margin-top: 24px;
    text-align: center;
}
.copyright-text {
    color: var(--text-color);
    font-size: 12px;
}

/* Transcript Questions CSS */

.question {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    display: flex;
    flex-direction: column;
    padding: 8px;
}

.question_content {
    display: flex;
    justify-content: space-between;
}

.question_details {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.question_images {
    display: flex;
    flex-direction: column;
    margin-left: 16px;
}

.question_image {
    margin-bottom: 8px;
}

.question_title {
    font-weight: var(--bold-font-weight);
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
    padding-bottom: 8px;
    margin-bottom: 8px;
}

.question_label, .question_stem {
    font-weight: var(--bold-font-weight);
    margin-top: 8px;
    margin-bottom: 8px;
}

.question_data_row {
    display: flex;
}

.question_data_col1 {
    padding: 8px;
    white-space: nowrap;
}

.question_data_col2 {
    padding: 8px;
    display: flex;
    flex-direction: column;
}

.question_answer_key {
    margin-top: 8px;
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
}

.feedback {
    font-style: italic;
}
</style></head><body class="report"><div class="container"><div class="content" id="lb-curtain"><h1 class="report_title">Java Certified Foundations Associate: Decision Statements</h1><div class="section_text">One of the main components of modern programming languages is the ability to make decisions using the data provided to them. Java provides decision statements that can be used to make decisions and being able to make decisions is a fundamental part of the Java programming language.

In this course, you&#39;ll learn about various types of Java decision statements. You&#39;ll examine how to use the if-then-else and switch statements. Then, you&#39;ll move on to learn about String comparisons, the comparison operator, the equals() method, and compareTo. You&#39;ll also learn about the strengths and weaknesses of each comparison operator and the best time to use each.

This course is one of a collection of courses that prepares learners for Oracle&#39;s 1Z0-811: Java Certified Foundations Associate certification.

</div><div class="section"><h2 class="section_title">Table of Contents</h2><div class="toc"><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_0">1. Video: Course Overview ( it_sdjcfa_11_enus_01)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_1">2. Video: Java Decision Statements ( it_sdjcfa_11_enus_02)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_2">3. Video: Java if-then-else Statements ( it_sdjcfa_11_enus_03)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_3">4. Video: Programming Java Decision Making Statements ( it_sdjcfa_11_enus_04)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_4">5. Video: Java switch Statements ( it_sdjcfa_11_enus_05)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_5">6. Video: Programming Java switch Statements ( it_sdjcfa_11_enus_06)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_6">7. Video: Java String Comparisons ( it_sdjcfa_11_enus_07)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_7">8. Video: Java Comparison Operator ( it_sdjcfa_11_enus_08)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_8">9. Video: Programming the Java Comparison Operator ( it_sdjcfa_11_enus_09)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_9">10. Video: Java equals() Method  ( it_sdjcfa_11_enus_10)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_10">11. Video: Programming the Java equals() Method ( it_sdjcfa_11_enus_11)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_11">12. Video: Java compareTo Method ( it_sdjcfa_11_enus_12)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_12">13. Video: Programming the Java compareTo Method ( it_sdjcfa_11_enus_13)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_13">14. Video: Course Summary ( it_sdjcfa_11_enus_14)</a></p></div></div><div class="section"><a name="section_0" /><h2 class="section_title">1. Video: Course Overview ( it_sdjcfa_11_enus_01)</h2><img src="https://cdn2.percipio.com/public/b/3a0f7eb1-0d8e-4c35-981c-913411827f22/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/3a0f7eb1-0d8e-4c35-981c-913411827f22/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">discover the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Overview.</em> [Video description ends]
<p>Hi, I&#39;m Steve Scott. I&#39;ve been a software developer and tech consultant for almost a quarter of a century. <br /><br />[Video description begins] <em>Your host for the session is Steve Scott. He is an IT Consultant.</em> [Video description ends] <br /><br />I&#39;ve traveled around the globe to serve clients where I&#39;ve been responsible for building secure systems, hiring development teams, and solving complex problems through technology. With my toolbox of languages, platforms, frameworks and API&#39;s, I round up my technical experience with an academic background in Mathematics and Computer Science. Oracle&#39;s 1Z0-811 Java Certified Foundations Associate certification is targeted to audiences seeking foundational knowledge of the Java programming language and concepts. Individuals tackling the certification will demonstrate they can write and execute a Java program, work with the Java Development Kit, JDK, and the Java Runtime Environment, JRE.</p>
<p>One of the main components of modern programming languages is to make decisions using the data provided to them. Java provides decision statements that can be used to make decisions and being able to make decisions is a fundamental part of the Java programming language.</p>
<p>In this course, I&#39;ll introduce you to various types of Java decision statements. I&#39;ll cover the If Then Else Statement and the Switch statement. Next, I&#39;ll move on to the String comparisons features, the comparison Operator, the Equal operator and the compareTo Operator. Finally, I&#39;ll discuss the strengths and weaknesses of each comparison operator and the best time to use each.</p></div></div></div><div class="section"><a name="section_1" /><h2 class="section_title">2. Video: Java Decision Statements ( it_sdjcfa_11_enus_02)</h2><img src="https://cdn2.percipio.com/public/b/741e34cc-c417-42fe-93a2-645ac8ba01f8/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/741e34cc-c417-42fe-93a2-645ac8ba01f8/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe and compare the various Java decision statements such as if-then, if-then-else, and switch and describe when to use each</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Decision Statements. Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe and compare the various Java decision statements such as if then, if then else, and switch to describe when to use each statement. Decision statements refer to conditional execution, a branching of code based on a comparison or logical test. In general, we also call them conditional statements. The basic syntax starts with the if statement. Using the if keyword, we say that if a condition is true, then execute the given block of code. If a condition is true but we also have an option for if a condition is false, we can use an if else statement. So we have our if block in case it&#39;s true, then an else block with other code to execute if it&#39;s false. We can also use nested if statements. So inside of an if block we have another if block. And inside of that we can have another if block. So there&#39;s nothing stopping an if block from containing another if block. And we have the switch-case statement to execute different cases of code based on a particular value.</p>
<p>The if statement is the decision making model for Java. We can document the if statement and decision making in Java through a flow chart visualization. So we start, we reach a condition, and that condition is our if statement. So if the condition is true, we execute more statements and then we come to the end, our stop. If the condition is false we bypass the statements and go straight to the end where the stop is. The if statement with its conditional block of code is surrounded by braces, and it&#39;s the simplest decision making construct we have in Java.</p>
<p>When the given condition inside of the parentheses, which follow the if keyword is true, the code inside the given block is executed. <br /><br />[Video description begins] <em>The following statement displays on the screen: Execute code when a condition is true</em> [Video description ends] <br /><br />So you have code surrounded by braces after the if, and <br /><br />[Video description begins] <em>Screen title: Java if...else Statement</em> [Video description ends] <br /><br />the condition is in parentheses to execute code when a condition is true. But what if the condition is false? The code skips over the conditional code block. However, we can follow it with the else keyword, which means executing some other code when the if statement is false. What follows the else keyword is another code block surrounded in braces. The conditional code block after an if statement is just like any other code in Java.</p>
<p>We can also and often do embed another <br /><br />[Video description begins] <em>Screen title: Java Nested if Statement</em> [Video description ends] <br /><br />if inside of our if statements conditional code. We can execute an if block inside of an if block, and down further, an if, and an if, and an if, and an if, and so on, and so on. But if you do get more than a few levels deep, you should probably see if your code can be broken up into a different way, separated into functions, because too many nested ifs are hard to follow. But syntactically, there&#39;s nothing stopping you from nesting as many if statements as you&#39;d like.</p>
<p>We also have a branching statement, the switch case,<br /><br />[Video description begins] <em>Screen title: Java switch-case Statement</em> [Video description ends]<br /><br />it&#39;s like an if conditional but it&#39;s based on a specific value. We have the switch keyword followed by a variable name in parentheses, and a code block with braces which contain the possible cases. It&#39;s important that the variable in the switch can have multiple discrete values.</p>
<p>Each branch is a case or multiple cases based on the value of the variable. Choices of code execution are the cases or a default case that is executed if no others are reached. So let&#39;s look at a basic if statement with some example code. <br /><br />[Video description begins] <em>A screen with title, Java if Statement displays. Underneath the title lies the following code: public class JavaConditionals{ /*displays result if value of i is less than 50 */ public static void main(String[] args){ int i &#61; 10; if(i&lt;50){ System.out.println(i &#43; &#34;is less than 50&#34;); } } } Finally, at the bottom of the screen, the following information is written: Output: 10 is less than 50.</em> [Video description ends] <br /><br />So we have this public class Java conditionals, which will display the result if the value of i is less than 50. And inside of our main function here I have int i &#61; 10. And then if i is less than 50, so the i less than 50&#39;s in parentheses, that&#39;s our condition, and then our if block is between the next braces.</p>
<p>So we have an open brace, which usually appears at the end of the line, along with the if statement and its condition. And then on the next line, we have system.out.println, the variable i &#43;, which is going to concatenate the rest of the string, is less than 50. And that&#39;s the end of our code. We close the brace to end the if statement, then another closing brace for our main, and a closing brace for our class. And if this code were executed, the output would be 10 is less than 50.</p>
<p>Let&#39;s have a look at another example if statement, this time inside of a loop. So we have the same class name, public class conditionals, and this one will <br /><br />[Video description begins] <em>A screen with title, Java if Statement in a loop displays. Underneath the title lies the following code: public class JavaConditionals{ /*counts to 10 but displays a result when value of i reaches 5*/ public static void main(String[] args){ for (int i &#61; 1; i&lt;&#61;10; i&#43;&#43;) { if(i&#61;&#61;5){ System.out.println( &#34;\n i is now equal to&#34; &#43; i); } System.out.print(i &#43; &#34; &#34;); }} } Finally, at the bottom of the screen, the following information is written: Output: 1 2 3 4 i is now equal to 5 5 6 7 8 9 10</em> [Video description ends] <br /><br />count to 10, but display a result with the value of i reaches 5. So we&#39;ll print an extra notice when i reaches 5. Then inside of main, I have a for loop for int i &#61; 1; while i &lt;&#61; 10; i&#43;&#43;.</p>
<p>And inside the body of this loop, I have an if statement, if (i&#61;&#61;5). So the condition which requires two equal sign for a comparison to compare i to 5. And when it reaches 5, it executes the code within the braces. Now we have to be careful here, the braces for the if statement, put it onto a single line.</p>
<p>So we have an open brace, System.out.println. And in quotations we have \n, a newline character, then i is now equal to. Then we end our double quotes &#43; i. So we concatenate the value of i at that point which should be 5. We put our semicolon to end the line, and then the brace appears on the same line.</p>
<p>So that&#39;s the end of the if block. Then on the next line, we&#39;re outside of the if block but we&#39;re still inside of the loop with a System.out.print of i &#43; and double quotes with a space in between. So we&#39;re printing the values of the loop followed by a space, and then the loop is closed on that line with its brace.</p>
<p>And then we have a double brace on the next line to close the main function and the class declaration. And the output in this case will be 1, followed by a space, then 2, and 3, and 4. Then we get the newline character, i is now equal to 5. And since it&#39;s the println, it&#39;ll go to the next line and print the 5 and then continue on with a space, and then 6, another space, 7, 8, 9, 10. And that&#39;s the end of the code once it reaches 10. And that concludes this presentation on Java decision statements.</p></div></div></div><div class="section"><a name="section_2" /><h2 class="section_title">3. Video: Java if-then-else Statements ( it_sdjcfa_11_enus_03)</h2><img src="https://cdn2.percipio.com/public/b/2ab314e3-fa2b-454b-9c46-11adf0f75eb0/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/2ab314e3-fa2b-454b-9c46-11adf0f75eb0/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the if-then and if-then-else statements and how they are used as decision statements in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java if-then-else Statements. Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe the if-then and if-then-else statements, and how they&#39;re used as decision statements in Java. So an if statement gives us a conditional way of executing some block of code if the condition is true. So if a condition is true, do something, execute a particular block of code. If it&#39;s not true, skip over it. And if we have an else condition, a type of otherwise, when a condition is false, it leads to doing something else.</p>
<p>And these are mutually exclusive. If we have an if and else statement, then if the condition is true, the code is executed and the else statement is skipped over. And if the statement is false, the true condition block of code is skipped over and the else condition is executed.</p>
<p>So what does this look like? <br /><br />[Video description begins] <em>Screen title: if...else Decision Making in Java</em> [Video description ends]<br /><br />Well, we have a condition. When it&#39;s true, we execute what&#39;s part of the if statement&#39;s block, and then we stop, skipping over or bypassing the else statement. If the condition is false, we bypass the if statement&#39;s code and execute what&#39;s in the else statement until we reach the end and stop.</p>
<p>So what does this look like in code? Well, I have this example code that displays whether a value of i is less than or greater than 50. So in the main function, I have int i &#61; 40; if i is less than 50. <br /><br />[Video description begins] <em>A screen with title, Java if...else Statement displays. Underneath the title lies the following code: public class JavaConditionals{ /*displays whether value of i is less than or greater than 50 */ public static void main(String[] args){ int i &#61; 40; if(i&lt;50){ System.out.println(i &#43; &#34;is less than 50&#34;);} else {System.out.println(i &#43; &#34;is greater than 50&#34;);} } } } Finally, at the bottom of the screen, the following information is written: Output: 10 is less than 50.</em> [Video description ends] <br /><br />So i less than 50 in the parentheses, that&#39;s the condition and if that&#39;s true, and in this case, it obviously is because i is explicitly set to 40.</p>
<p>We will print using System.out.println the contents of the variable i concatenated with the string is less than 50. Then the close brace, followed by the else keyword leads into the else block, which follows it in braces.</p>
<p>So we have the open brace, along with the close brace with the main statement and the public class a few lines down. But inside of this else block, the code that executes is System.out.println with the contents of i concatenated with the string is greater than 50.</p>
<p>And if we&#39;d run this, the output would be 40 is less than 50. Well, let&#39;s look at a modified version of the same code where i is set to 60. So the first line in the main function is int i &#61; 60.<br /><br />[Video description begins] <em>The following code now displays on the screen: public class JavaConditionals{ /*displays whether value of i is less than or greater than 50 */ public static void main(String[] args){ int i &#61; 60; if(i&lt;50){ System.out.println(i &#43; &#34;is less than 50&#34;);} else {System.out.println(i &#43; &#34;is greater than 50&#34;);} } } } Also, at the bottom, the following output displays: 60 is greater than 50.</em> [Video description ends]</p>
<p>Then we have the same conditional if i is less than 50, the printed output is the variable i is less than 50, else i is greater than 50. And since it was set to 60, the second block of code will be executed, the else block, and the output will be 60 is greater than 50. We can expand this a little further, covering the case when i &#61; 50.</p>
<p>So we can use an if, else-if, else block. So we have three blocks with two explicit conditions, and one condition, the else condition, that executes if the other two are false.<br /><br />[Video description begins] <em>A screen with title, Java if...else if...else Statements displays. Underneath the title lies the following code: public class JavaConditionals{ /*displays whether value of i is less than, equal to, or greater than 50 */ public static void main(String[]args){ int i&#61; 50; if(i&lt;50){System.out.println(i &#43; &#34;is less than 50&#34;);} else if (i&#61;&#61;50) { System.out.println(&#34;i is equal to 50&#34;);} else {System.out.println( &#34;i is greater than 50&#34;); } } } Finally, at the bottom of the screen, the following information is written: Output: i is equal to 50.</em> [Video description ends] <br /><br />So we can chain our if statements together using the else-if. And inside the main function, I have int i &#61; 50, then if i is less than 50, the i is less than 50 string is printed.</p>
<p>At the end of that block, we have a brace, and then the keyword, the combination else-if together, it&#39;s conditional is i &#61;&#61; 50. So we use the double equal sign for comparison, so if i is equal to 50, then we print i &#61; 50. And then the else block, where i is greater than 50 is printed. And the output in this case is i &#61; 50. And that concludes this presentation on the Java if-then-else statements.</p></div></div></div><div class="section"><a name="section_3" /><h2 class="section_title">4. Video: Programming Java Decision Making Statements ( it_sdjcfa_11_enus_04)</h2><img src="https://cdn2.percipio.com/public/b/3653c1d4-05f5-4bc5-83ae-bee93138f0a3/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/3653c1d4-05f5-4bc5-83ae-bee93138f0a3/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the use of the if-then and if-then-else statements and how they are used as decision statements in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Decision Making Statements. Your host for the session is Steve Scott.</em> [Video description ends] <br /><br />[Video description begins] <em>The IntelliJ IDEA window titled, ConditionalsDemo-Main.java appears on the screen, showing various lines of code.</em> [Video description ends]
<p>In this video, I&#39;ll demonstrate the if-then and if-then-else statements and how they&#39;re used as decision statements in Java. So I start out in this Main.java file by declaring the package that it&#39;s contained in as package com.example. Then I import java.util.Scanner. So this class is used to take user input. And what we&#39;ll do in this example is use that input to make a decision, to make a number of decisions which will affect our output. Then on line 5, I declare a public class Main.</p>
<p>And inside of it, I have a main method, the entry point into our application on line 7 public static void main with String[] args. And inside the body of this method, I have Scanner input &#61; new Scanner with System.in as its argument. So this is going to take standard input, parse the value, in this case an integer, and we&#39;ll make decisions based on it. On line 10, I have System.out.println, Enter an integer is the string.</p>
<p>And then on the next line, I have int value &#61; input.nextInt, so it&#39;s expecting an integer. Now one thing I haven&#39;t done here is to check that the input is valid. You should always validate your inputs.</p>
<p>But for the sake of this example, I&#39;m going to leave the input validation and any exception handling needed to validate the input. So I&#39;ll expect an integer. And then on line 13, I have my first conditional. The keyword for a conditional statement is if. So if then in parentheses, I have some code that&#39;s expected to return true or false.</p>
<p>If it&#39;s true, then it executes the block within the braces that follows the if statement. If it&#39;s false, it skips over it and doesn&#39;t execute the block. So I have if and then inside of the parentheses, value and double equal sign, this is a direct comparison to check for equality. If we&#39;re doing assignment in Java, we use a single equal sign.</p>
<p>If we&#39;re doing a comparison, we use a double equal sign. So value is equal to 0 or, so the or operator, the logical or is the double pipe characters. So we put the two pipe characters and then value &#61;&#61; 1. So the way we read this is if the value is equal to 0 or the value is equal to 1, if either of those conditions are true, then execute the code within the parentheses, System.out.println, you entered 0 or 1.</p>
<p>Then on line 17, I have a different conditional, if in this case I have value % 2. So this is value modulus 2.</p>
<p>So this modulus operator, the % symbol, says that if we take value divided by 2 and take its remainder, so the remainder of the division. If that&#39;s equal to 0, that means the number is divisible by 2 evenly.</p>
<p>And so inside the block, I print System.out.println, your value is even. On line 19, I do something similar, but here I&#39;m demonstrating that you can have if blocks contained within other if blocks. So this is called a nested if.</p>
<p>So we have an if statement. So if that&#39;s true, inside of it, we have another if block. And an important thing to remember here is that your nested if block, the if block that appears in another if block, we should always make sure that its condition is dependent on the outer if.</p>
<p>So in this case, I say if value % 4 &#61;&#61; 0, so if value mod 4 is equal to 0, then I print, And your value is divisible by 4. But if in this case I changed the 4 to a 5, this wouldn&#39;t make sense because 5 is not even and this could never be true. So that&#39;s one thing to watch out when using nested if statements. And we also have to line up our if statements.</p>
<p>So this inner if statement is separate from the else statement that follows on line 22. So we always should line up our parentheses and within the IDE, like IntelliJ I have here, there&#39;s a very faint line that follows from the if statement to its closing brace. And if we keep this formatting, then we can always follow visually where the indentation happens and who the corresponding blocks belong to.</p>
<p>So this else statement corresponds to if value mod 2 is equal to 0, so if it&#39;s even, we execute the block inside. Then on line 22, the else, this means that the value is odd. If a number is not even, it&#39;s odd, so I print using System.out.println with the string, Your value is odd. And I have a few more blocks to demonstrate. The next block on line 26, I have if value &amp;gt;&#61; 1000 &amp;amp;&amp;amp;. So this is the and logical operator which means the conditions both have to be true for the if block to return successfully for to execute the block.</p>
<p>So both of these conditions have to be true, value &amp;gt;&#61;1000 and value &amp;lt;&#61; 2000. And then inside the block, I have System.out.println, Your value is between 1000 to 2000 inclusively. So it includes the values 1000 and 2000. And in line 30, I have if value &amp;lt; 100. Inside its block, I print Your value is less than 100. And then the next block is else if.</p>
<p>So combining the two words together, else and if, with a space in between them, we can have additional block that if the first condition is false, if the if statement is false, it checks the else if. If value &amp;gt; 100, we use System.out.println to print Your value is greater than 100. And then I follow that with an else block.</p>
<p>So we can have as many else ifs as we want, and we don&#39;t necessarily need an else at all. But if we do include it, the else will get it executed if the if and the else ifs, in this case, the one else if, if both of those are false, it will execute the else statement. In this case, it uses a System.out.println to say Your value is not less than 100 and is not greater than 100.</p>
<p>So that&#39;s combining the results of those two conditions. So if a value is not less than 100 and not greater than 100, your value must be 100. So I actually print that Therefore your value must be 100.</p>
<p>And that&#39;s what this condition amounts to. So I&#39;ll execute the program with Shift&#43;F10. And I&#39;ll select the output window, the run window, and I&#39;ll enter the integer 0. And it tells me you entered zero or one, well, I entered 0. Your value is even, 0 is an even number. Your value is divisible by 4, that&#39;s true.</p>
<p>And your value is less than 100, so that worked. Now if I want to test all the branches, I&#39;ll need to keep running the program. So if I run it again, I&#39;ll test the condition for 1 and it tells me You entered zero or one, Your value is odd and Your value is less than 100. And now I&#39;ll run it again and enter 1000. And it tells me Your value is even, Your value is divisible by 4, Your value is between 1000 and 2000 inclusively and Your value is greater than 100. And that&#39;ll conclude this integration of decision statements in Java using conditionals.</p></div></div></div><div class="section"><a name="section_4" /><h2 class="section_title">5. Video: Java switch Statements ( it_sdjcfa_11_enus_05)</h2><img src="https://cdn2.percipio.com/public/b/1dd8adbc-aef1-44f9-8059-cdabc15662eb/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/1dd8adbc-aef1-44f9-8059-cdabc15662eb/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the switch statement and how it is used as a decision statement in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java switch Statements. Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe the switch statement and how it&#39;s used for decision statements in Java.<br /><br />[Video description begins] <em>Screen title: Java switch-case Statement</em> [Video description ends] <br /><br />So the Java switch-case statement is a type of branching statement to execute conditional code based on particular criteria, based on a single value. And given that value, there are typically numerous multiple executing options for the Java switch-case statement. Let&#39;s see how this looks visually. So given a particular switch condition, in this case a variable, we have various cases based on the value of that variable. <br /><br />[Video description begins] <em>Screen title: switch-case Decision Making in Java</em> [Video description ends] <br /><br />So if the condition or the case is based on a particular value, let&#39;s say a character value.</p>
<p>So if we have a value based on particular cases, so Case A, Case B, Case C, they can execute individually independently in Java or multiple cases can execute the same code. And if all of the cases fail, we can have a default case. So this does behave somewhat like the if, else if, else statements in Java. But the cases are more explicit based on the value and not based on a logical Boolean condition.</p>
<p>It&#39;s also easier to have multiple cases, multiple values execute the same code. And it can be argued that this syntax is more concise. The switch-case statements also make use of a break keyword. <br /><br />[Video description begins] <em>Screen title: break Keyword in switch-case Statements</em> [Video description ends] <br /><br />So instead of surrounding blocks in open and close braces like an if statement, we use open-ended blocks of code that only exit when the break keyword is reached.</p>
<p>So we have a match that&#39;s found and to get out of a switch block, we either break or we fall through to the next result. And the break says there&#39;s no further processing needed. And we can skip past the rest of the code in our cases, but the break is optional.</p>
<p>So if we have multiple cases, a particular case could execute some code and then continue executing the code in the next case, and continue on until it reaches the break statement. So it gives you a lot more power in reusing codes either fully or partially using the switch case. So what does this look like in code? <br /><br />[Video description begins] <em>A screen with title, Java switch-case Statement displays. Underneath the title lies the following code: public class JavaConditionals{ public static void main(String[] args){ String i &#61; &#34;&#34;; switch(i){ case &#34;red&#34;: System.out.println(&#34;red&#34;); break; case &#34;blue&#34;: System.out.println(&#34;blue&#34;); break; case &#34;green&#34;: System.out.println(&#34;green&#34;); break; } } } Finally, at the bottom of the screen, the following information is written: Output:</em> [Video description ends] <br /><br />So inside of my main function in this example, I set a string i is equal to an open and close double quotes.</p>
<p>So it&#39;s an empty string. We have a switch statement, switch i. So it&#39;s going to use the value of i to decide on which case to execute. And our first case is case with the string red followed by a colon. And then inside of it has System.out.println, the string red, followed by the break statement.</p>
<p>Now the break statement can appear on the same line as long as it&#39;s separated with semi colon or it can appear on a line by itself. Typically, we put it on a line by itself at the end of a case that we&#39;d like to execute. Then we have case blue, which prints the string blue and breaks, and case green that prints green and then breaks.</p>
<p>And in this case, the output is nothing because none of the cases are reached. Now when there&#39;s no cases reached, we can also use the keyword default.<br /><br />[Video description begins] <em>Screen title: default Keyword in switch-case Statements</em> [Video description ends] <br /><br />So if none of the cases like in the previous example were reached, then we can say none of them are found or executing whatever code we wish to handle that particular case. <br /><br />[Video description begins] <em>The following text displays on the screen: No match to provided cases and If so, execute code (or do nothing)</em> [Video description ends] <br /><br />But this is optional.</p>
<p>So if we have it, we execute the code. And if we don&#39;t have it, nothing is done. So it&#39;s entirely optional. So let&#39;s have a look at an example where we have the default keyword. So it&#39;s similar to what I had on the previous example code,<br /><br />[Video description begins] <em>A screen with title, Java switch-case Statement displays. Underneath the title lies the following code: public class JavaConditionals{ public static void main(String[] args){ String i &#61; &#34;&#34;; switch(i){ case &#34;red&#34;: System.out.println(&#34;red&#34;); break; case &#34;blue&#34;: System.out.println(&#34;blue&#34;); break;default: System.out.println(&#34;no color!&#34;); break; } } } Finally, at the bottom of the screen, the following information is written: Output: no color!</em> [Video description ends] <br /><br />String i is equal to the empty string.</p>
<p>The switch is based on i. And then the case statements are case red, which will print the string red and break, case blue, which prints the string blue and breaks and then default. So it&#39;s just the keyword default, followed by the colon, and then the code System.out.println no color. And in this case the break, but the break is optional if it&#39;s the last item in this switch block.</p>
<p>So the output in this case is the string, no color. Now I modify it so that one of the cases is executed, the blue case. <br /><br />[Video description begins] <em>The code on the screen gets updated to: public class JavaConditionals{ public static void main(String[] args){ String i &#61; &#34;blue&#34;; switch(i){ case &#34;red&#34;: System.out.println(&#34;red&#34;); break; case &#34;blue&#34;: System.out.println(&#34;blue&#34;); break;default: System.out.println(&#34;no color!&#34;); break; } } } Finally, at the bottom of the screen, the following information is written: Output: blue</em> [Video description ends] <br /><br />So in my main function, I have String i equals the string blue, the switch on i. And then inside of the braces, the switch braces in the block, I have two cases and a default case.</p>
<p>So case red, that prints red and breaks, and then case blue. So the string blue matches the string i so that in this case it will print blue and then break, so it skips over the default case. And the output in this case is just blue. We can also use this with integer values. <br /><br />[Video description begins] <em>The code on the screen gets updated to: public class JavaConditionals{ public static void main(String[] args){ int i &#61; 10; switch(i){ case 5: System.out.println(&#34;i is equal to 5&#34;); break; case 10: System.out.println(&#34;i is equal to 10&#34;); break;default: System.out.println(&#34;i is greater than 10&#34;); } } } Finally, at the bottom of the screen, the following information is written: Output: i is equal to 10</em> [Video description ends]</p>
<p>So I have an example here with int i &#61; 10. And then switching on i switches on an integer value, so the cases must use the literal values for integers. So case 5 followed by a colon, then the block that executes if i is 5, which prints i &#61; 5, and then breaks. case 10, which is the case that will be true in this case, prints i is equal to 10, followed by the break keyword and then default, which prints i is greater than 10.</p>
<p>In the output in this case, i is equal to 10. But we have to be careful how we use that default case because in this example, I changed the previous slide to set int i &#61; 4.<br /><br />[Video description begins] <em>The code on the screen gets updated to: public class JavaConditionals{ public static void main(String[] args){ int i &#61; 4; switch(i){ case 5: System.out.println(&#34;i is equal to 5&#34;); break; case 10: System.out.println(&#34;i is equal to 10&#34;); break;default: System.out.println(&#34;i is greater than 10&#34;); } } } Finally, at the bottom of the screen, the following information is written: Output: i is greater than 10</em> [Video description ends] <br /><br />I switch on i, my case 5 and case 10 are the same as the previous slide.</p>
<p>So in case 5, i is equal to 5 is printed. case 10 prints i is equal to 10, and then the default case prints i is greater than 10. Well, that&#39;s not quite true, because i is 4, and even though it doesn&#39;t match 5 or 10, the default, the actual output is wrong. So we&#39;re not using comparisons. We&#39;re not looking at a case where i is less than or greater than any of the values, it&#39;s looking at the explicit value.</p>
<p>The output here would be i is greater than 10, maybe something more appropriate to print in this case. And the default case would be i is something other than 5 or 10. So I&#39;ve modified the example from the previous slide, <br /><br />[Video description begins] <em>The code on the screen gets updated to: public class JavaConditionals{ public static void main(String[] args){ int i &#61; 4; switch(i){ case 5: System.out.println(&#34;i is equal to 5&#34;); break; case 10: System.out.println(&#34;i is equal to 10&#34;); break;default: System.out.println(&#34;i is not equal to 5 or 10&#34;); } } } Finally, at the bottom of the screen, the following information is written: Output: i is not equal to 5 or 10</em> [Video description ends] <br /><br />I have int i &#61; 4, switch i. I have the case for 5, the case for 10, and the default case is i is not equal to 5 or 10, and that&#39;s what gets printed. i is not equal to 5 or 10, because it&#39;s equal to 4, and that case wasn&#39;t handled. So the default case gets executed correctly. And that concludes this presentation on Java switch statements.</p></div></div></div><div class="section"><a name="section_5" /><h2 class="section_title">6. Video: Programming Java switch Statements ( it_sdjcfa_11_enus_06)</h2><img src="https://cdn2.percipio.com/public/b/fb41206d-4e5b-4b6c-aaad-72fa36a913c4/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/fb41206d-4e5b-4b6c-aaad-72fa36a913c4/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the use of the switch statement and how it is used as a decision statement in Java </li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java switch Statements. Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll demonstrate the switch statement and how it&#39;s used to execute conditional statements in Java. <br /><br />[Video description begins] <em>An IntelliJIDEA window titled, SwitchDemo-Main.java appears on the screen. Currently, the Main.java file is opened and displays various lines of code.</em> [Video description ends] <br /><br />On line 1 in this example, I add the contents of my Main.java to the package com.example. Then on line 3, I import java.util.Scanner, which I&#39;m going to use to get an input of an integer through the command line when the program is run. And on line 5, I declare public class Main, and in it, it has a main entry point, public static void main with string[] args as its parameters.</p>
<p>Then in the body of the main function, I have Scanner input &#61; new Scanner with (System.in). So this is going to let us read from the standard input. On line 10, I have System.out.println of enter an integer. And then on line 11, I have int value &#61; Input.nextInt. So it&#39;s going to take into integer from the input and then execute code based on a switch statement on the value depending on what we enter. So this will take our value and put it in to a switch statement. On line 13, I have switch, and it takes a value, and then in parentheses I need a value.</p>
<p>So in this case it&#39;s just the value. The integer that&#39;s entered, then the cases of a switch statement are defined inside of the braces. So we have everything enclosed in braces. And all of the conditional statements that can be run are inside of this. On line 14, I have case, and then a value, in this case 0, followed by a colon.</p>
<p>So the syntax is the case keyword, the value, and then a colon. And then below that, I have System.out.println, with the string Zero. So it&#39;s going to say that we entered Zero.</p>
<p>So everything after the case gets executed until it reaches a break statement or it reaches the end of the switch. So in this case, I have a break followed by a semicolon. So this will exit the switch statement and continue executing from line 29. Then on line 17, I have the next case, case 1:.</p>
<p>And this time I print System.out.println of the string one, followed by a break with the semi-colon. On line 20, I have case 10 with a colon, and then on line 21, I have case 100 with a colon. This allows us to execute code based on multiple values. So as long as we don&#39;t see a break statement, we&#39;ll keep executing. And in this case, case 10, case 100 executes the same code System.out.println.</p>
<p>This will be printed for 10 or 100, followed by a break statement. Then I have case 1000 with a colon, and on line 25 I have System.out.println, this will be printed for 1000. And then on line 26, I have System.out.println. Without a break, this will fall through to the default case. So there&#39;s the special keyword called default.</p>
<p>And because case 1000 doesn&#39;t have a break statement, it just keeps executing. But in the case of default, so if none of the cases are met, so case 0, case 1, case 10, case 100, and case 1000. If none of these are met, the default case gets executed. But also because case 1000 doesn&#39;t have a break statement, it falls through and executes the default case. And all the default case does is System.out.println.</p>
<p>This is the default case. The default case must come last. But it doesn&#39;t require a break statement because it reaches the end of the switch block. Let&#39;s try this out. I&#39;ll do Shift&#43;F10 to run the code and the first integer I&#39;ll enter is 0. I&#39;ll go through all the possibilities.</p>
<p>So 0, print zero, and I&#39;ll keep doing Shift &#43; F10 after each execution. I&#39;ll enter the integer 1 and it prints 1, and then 10. This will be printed for 10 or 100. So everything looks good so far. I&#39;ll enter the integer 100 this time and this will be printed for 10 or 100. I&#39;ll run it again.</p>
<p>And this time I&#39;ll type 1000. And it has this will be printed for 1000. Without a break, this will fall through to the default case, and it prints, This is the default case. And now finally, I&#39;ll enter, let&#39;s say 99. And all this prints is This is the default case because none of the other cases are met. And that covers all of the possibilities in our switch statement. And that&#39;ll conclude this demonstration of programming Java switch statements.</p></div></div></div><div class="section"><a name="section_6" /><h2 class="section_title">7. Video: Java String Comparisons ( it_sdjcfa_11_enus_07)</h2><img src="https://cdn2.percipio.com/public/b/b9f98dda-379c-40ac-ba35-06d2585b2a4a/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/b9f98dda-379c-40ac-ba35-06d2585b2a4a/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the various classes and methods for comparing primitives and objects such as the ==, compareTo, and equals</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java String Comparisons. Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe the various classes and methods for comparing primitives and objects.<br /><br />[Video description begins] <em>Screen title: Making Comparisons in Java</em> [Video description ends] <br /><br />So what are the main methods for making comparisons in Java? Well, there&#39;s the double equals sign which is used to compare primitives in Java. The equals method, used to compare strings.</p>
<p>And the general compareTo method, used to make comparisons between objects, values, and when compared with strings, used to set an order between objects, not just equality which aids in sorting unranked comparisons. So the double equals comparison operator is primarily used for numeric values or primitive values, but it&#39;s not used for objects. <br /><br />[Video description begins] <em>A screen with title, Java &#61;&#61; Comparison Operator, displays. Underneath the title lies the following code: public class JavaConditionals{ public static void main(String[] args){ int i &#61;5 ; if(i&#61;5){ System.out.println(&#34;i equals 5&#34;); } } } Finally, at the bottom of the screen, the following information is written: Returns and error</em> [Video description ends] <br /><br />It&#39;s also different than the single equal sign which is used for assignment. So in some languages, the equals operator is used for both assignment and comparison depending on the context. But in Java, using the assignment operator when you need comparison is an error. So in the main function of this code, I have int i &#61; 5, then if i &#61; 5 where the single equal sign is used will result in an error, so this is a mistake.</p>
<p>What should be done? The equal sign in Java is used for assignment, to assign a value to a variable. The double equal sign is used only to compare values. So the comparison in the code example where we have int i &#61; 5, if we want to check to see if i &#61; 5, then we say if i &#61;&#61; 5. <br /><br />[Video description begins] <em>A screen with title, Java &#61;&#61; Comparison Operator, displays. Underneath the title lies the following code: public class JavaConditionals{ public static void main(String[] args){ int i &#61;5 ; if(i&#61;&#61;5){ System.out.println(&#34;i equals 5&#34;); } } } Finally, at the bottom of the screen, the following information is written: i equals 5</em> [Video description ends] <br /><br />So that&#39;s our condition that will return true or false.</p>
<p>And in this case, it will obviously return true and the output will print i equals 5. But we can&#39;t use it for comparing objects or comparing strings. <br /><br />[Video description begins] <em>A screen with title, Comparing Strings Using &#61;&#61;, displays. Underneath the title lies the following code: public class JavaConditionals{ public static void main(String[] args){ String myString1 &#61;&#34;Ja&#34; ; String myString2 &#61;&#34;va&#34; ; String myString3 &#61;&#34;Java&#34; ; String myString4 &#61; myString1 &#43; myString2; boolean test &#61; (myString3&#61;&#61;myString4); //returns false System.out.println(myString3 &#43; &#34;should be equal to&#34; &#43; myString4);System.out.println(&#34;using &#61;&#61; results in&#34; &#43;test); } } Finally, at the bottom of the screen, the following information is written: Output: Java should be equal to Java using &#61;&#61; results in false</em> [Video description ends] <br /><br />When using objects, the double equal sign only checks whether the two objects refer to the same place inside of Java&#39;s memory. So if they refer to the same thing, not that their internal values might be the same. Inside of the main method of this example code, I have String myString1 &#61; the string Ja, String myString2 &#61; the string va.</p>
<p>String myString3 is set equal to the string Java, and then String myString 4 equals the concatenation of myString1 &#43; myString2. So the internal characters of myString4 will be J-A-V-A Java. So myString3 and myString4 have the same internal characters as their string representations.</p>
<p>But now I have Boolean test, so a test variable which will contain true or false then I set that equal to the comparison of myString3 &#61;&#61; myString4. And this will actually return false because myString3 and myString4 refer to two separate instances of the memory containing this characters J-A-V-A. So we&#39;re not testing the internal string&#39;s equality.</p>
<p>We&#39;re testing the object equality in what it refers to, so how it internalizes those strings within Java&#39;s memory space in the JVM. Then I call System.out.println with myString3 concatenated with should be equal to myString4. And System.out.println of using &#61;&#61; results in the concatenation of the test variable, true or false.</p>
<p>So the output is Java should be equal to Java. Well, it should be and in terms of the characters, they are. It&#39;s just that the variables are not equal, and using double equal sign results in false. And that concludes this presentation on Java string comparisons.</p></div></div></div><div class="section"><a name="section_7" /><h2 class="section_title">8. Video: Java Comparison Operator ( it_sdjcfa_11_enus_08)</h2><img src="https://cdn2.percipio.com/public/b/428c4dbd-2749-47f1-be30-b0d4ab20bda0/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/428c4dbd-2749-47f1-be30-b0d4ab20bda0/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe how the == operator differs between primitives and objects</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Comparison Operator. Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe how the double equals operator differs between primitives and objects. We use the double equal sign to compare primitive data types.<br /><br />[Video description begins] <em>Screen title: Primitive Data Types in Java</em> [Video description ends] <br /><br />Java has eight primitive types. And the thing about primitive types is that they can&#39;t be set to null or they can&#39;t be uninitialized. Primitive types are set to a default value of 0. In the case of a Boolean data type, a primitive Boolean, it&#39;s set to false. So the primitive data types are byte, short, long, Int, float, double, char, and Boolean. So testing equality with primitives, you always use the double equal sign. And the primitives are assigned with literal values, or set to be equal to other primitives. They occupy a fixed value in memory in Java&#39;s JVM memory.</p>
<p>And they&#39;re tested for equality using the double equal sign, but there are some exceptions. So in this example I have double myDouble &#61; 5.0, myDouble &#43;&#61; 5.1, myDouble &#43;&#61; 5.1. <br /><br />[Video description begins] <em>A screen with title, Comparing Double Primitive Type in Java, displays. Underneath the title lies the following code: public class JavaComparisons{ public static void main(String[] args){Double myDouble &#61;5.0 ; myDouble &#43;&#61;5.1 ; // now equals 10.1 myDouble &#43;&#61;5.1 ; // now equals 15.2 myDouble &#43;&#61;5.1 ; // now equals 20.299999999999997 boolean testEquality &#61; (myDouble&#61;&#61;20.1); System.out.println(testEquality); }} Finally, at the bottom of the screen, the following information is written: Output: false</em> [Video description ends] <br /><br />And the third time instead of having 20.3, we have 20.29999 repeating ending with a 7. And if we test for equality using the double equal sign, we have boolean testEquality&#61;(myDouble &#61;&#61; 20.1). And then we print the testEquality variable, the output is going to be false.</p>
<p>So we have to be very careful about precision. Using double equal sign with objects is looking at the object reference type. So the references can be tested for equality if two variables refer<br /><br />[Video description begins] <em>Screen title: Objects in Java</em> [Video description ends] <br /><br />to the same type or same memory but it must be the same object in memory. The objects being compared with double equal sign can not be compared in terms of their internal values using the double equal sign. For that, the .equals method or the compareTo method must be used. And that concludes this presentation on Java comparisons.</p></div></div></div><div class="section"><a name="section_8" /><h2 class="section_title">9. Video: Programming the Java Comparison Operator ( it_sdjcfa_11_enus_09)</h2><img src="https://cdn2.percipio.com/public/b/f6a990d8-6e68-44d1-b1c9-4392cbd760c5/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/f6a990d8-6e68-44d1-b1c9-4392cbd760c5/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate how the == operator differs between primitives and objects</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming the Java Comparison Operator. Your host for the session is Steve Scott.</em> [Video description ends]<br /><br />[Video description begins] <em>An IntelliJIDEA window titled, ComparisonDemo-Thing.java appears on the screen. Currently, the Thing.java file is opened and displays various lines of code.</em> [Video description ends]
<p>In this video, I&#39;ll demonstrate how the double equal sign, the equality operator differs between primitives and objects. I&#39;ll start in this example code by creating an object called Thing. I&#39;m in this file called Thing.java, I added to the package com.example. I declare it as public class Thing. And then on line 4 inside of Thing I have private int value. So it has a single property, it has a getter and a setter. So in line 6, I have public int getValue that returns value. And on line 10, public void setValue. That takes int value and sets this.value &#61; value. I also implement an equals method as public boolean equals, which will return true if the values are equal and false if they&#39;re not. And it compares a second object Thing o, as its parameter, and then it returns this.value &#61;&#61; o.value.</p>
<p>So it&#39;s going to do a comparison between the int values, the primitive values that are contained within the two objects. <br /><br />[Video description begins] <em>He switches to the Main.java file, which consists of the various lines of code.</em> [Video description ends] <br /><br />Then in Main.java, I add this to the package com.example, I import java.util.Scanner. Because we&#39;re going to enter some inputs, I declare a public class Main. And then the main function public static void main(string[ ]args). And then inside the main method I have Scanner input &#61; new scanner with system.in so we can read from the standard input. On line 10, I have System.out.println(&#34;Enter a String:&#34;) then String a &#61; input.nextLine.</p>
<p>So we&#39;re going to read the input up until the user hits returned and store it in a. On line 13, I have System.out.println, Enter another String, then String b &#61; input.nextLine. On line 16, I print the comparison of the strings using the double equal sign. Now, in dealing with strings, this is not the way to compare their values.</p>
<p>This is how we compare the objects, to see if string a, the variable was assigned to b, or b was assigned to a. So the only way this is true or if the objects are the same object, if they have the same string values, this will be false. Then I take two integers as input. So I print Enter an integer with int x &#61; input.nextInt, so it&#39;s going to expect an integer input. Then enter another integer int y &#61; input.nextInt.</p>
<p>Then I print the comparison of x and y. So System.out.printIn(int x &#61;&#61; to int y). So I have in parentheses (x &#61;&#61; y). So we&#39;re comparing the primitive values. So with primitive types like int, boolean, float, double, short, etc. these comparisons actually compare the values, because we&#39;re not dealing with objects we&#39;re dealing with primitives.</p>
<p>Now let&#39;s look at our custom object. I have Thing u &#61; new Thing, then u.setValue(x). So it&#39;s going to set the value of thing u to x. And then Thing w &#61; new Thing, followed by w.setValue(y).</p>
<p>So it&#39;s going to take the previous inputs, and use them to create our thing objects and set their values. On line 33, I have System.out.println(Thing u &#61;&#61; Thing w, so we&#39;re doing a comparison, u &#61;&#61; w. So it&#39;s looking at the equality of the objects. What we probably want is the comparison of the value. And for that, I can print my u.equals(w), so the result of that to actually compare the values contained within Thing u and Thing w.</p>
<p>So when are these objects the same? Well, they&#39;re only equals using the comparison operator, the double equal sign when the objects are the same. So anytime we have u &#61; w, or w &#61; u, or some way of assigning the objects so that they&#39;re pointing to the same objects, then it will be true. So I print After setting u &#61; w, we check the equality u &#61;&#61; w.</p>
<p>So now let&#39;s run the code. I&#39;ll do Shift&#43;F10 for the first strings, so I Enter a String I will type hello. The second string, hello, again they&#39;re identical in every way, but string a is not equal to string b, that returns false.</p>
<p>Now if I enter an integer, let&#39;s say 1, and then a second integer 1 again, so they&#39;re both the same value. If I compare int x and int y, well it returns true. But using those values to set the values of Thing u and Thing w, and then comparing Thing u to Thing w, It returns false even though u.&#61; w is true.</p>
<p>So then after setting u &#61; w, I checked the equality of the objects u and w, and then that returns true. So it takes a little bit more to have equality between objects, and it&#39;s all, they&#39;re only equal when they&#39;re the same object not just when their values are the same. And that concludes this demonstration of programming java comparisons.</p></div></div></div><div class="section"><a name="section_9" /><h2 class="section_title">10. Video: Java equals() Method  ( it_sdjcfa_11_enus_10)</h2><img src="https://cdn2.percipio.com/public/b/4c0ddabe-8561-4f00-9543-a312aa61e640/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/4c0ddabe-8561-4f00-9543-a312aa61e640/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the differences between the equals() method and the == operator in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java equals() Method . Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe the differences between the equals method and the double equals operator in Java. And I&#39;ll explain some confusing results you might see <br /><br />[Video description begins] <em>A screen with title, Comparing String Using &#61;&#61;, displays. Underneath the title lies the following code: public class JavaConditionals{ public static void main(String[] args){ String myString1 &#61;&#34;Ja&#34; ; String myString2 &#61;&#34;va&#34; ; String myString3 &#61;&#34;Java&#34; ; System.out.println(myString1 &#61;&#61; &#34;Ja&#34;); //returns trueSystem.out.println(myString3 &#61;&#61; &#34;Java&#34;); //returns true System.out.println(myString1 &#43; myString2 &#61;&#61;&#34;Java&#34;); //returns false } } Finally, at the bottom of the screen, the following information is written: Output: true true false</em> [Video description ends]<br /><br />and why things work a certain. So I have an example of comparing strings using the double equal sign. And if you&#39;re comparing the contents of the string, you should never use the double equals sign. This is only for comparing the objects and checking to see that the object references refer to the same object.</p>
<p>So in the main function of this example, I start with String myString1 equals the string Ja. String myString2 &#61; va, String myString3 &#61; the string Java. And now I do a System.out.println of myString1 &#61;&#61; Ja. Well, we assigned myString1 to Ja, and we&#39;re comparing it to Ja, but we&#39;re comparing the object references. The internal object created by Ja as the literal string I&#39;ve typed into this comparison and the variable myString1. And what it refers to in memory, which contains the characters Ja.</p>
<p>But here it returns true. And if we&#39;re comparing the objects, how can this be the case? The Java compiler takes the instance of Ja and sees it twice, so it combines those two literal strings to be the same in memory. So the literal string typed into this comparison and this literal string that we assigned to myString1.</p>
<p>Gets put into the same place by the compiler because it sees a literal string. And instead of storing it twice, it saves memory and stores it once. So the variable and the string refer to the same location in memory. So it returns true, and the same goes for myString3 &#61;&#61; Java. However, if we take myString1 and we concatenate myString2. Making the internal representation of the string that concatenation returns to be J-A-V-A, to be Java, and we compare that to the literal string Java. This will return false because the concatenation and the literal string refer to two different places in memory.</p>
<p>The objects refer to two different things. And this confusion, you might say strange behavior, although it can be explained. It also motivates us to avoid using the double equal sign when we&#39;re dealing with string objects. Let&#39;s look at another similar example. <br /><br />[Video description begins] <em>The code displayed on the screen updates to: public class JavaComparisons{ public static void main(String[] args){ String myString1 &#61;&#34;Ja&#34; ; String myString2 &#61;&#34;va&#34; ; String myString3 &#61;&#34;Java&#34; ; String myString4 &#61; myString1 &#43; myString2; System.out.println(&#34;using &#61;&#61; results in &#34; &#43; (myString3 &#61;&#61; myString4)); // returns false } } Finally, at the bottom of the screen, the following information is written: Output: using &#61;&#61; results in false</em> [Video description ends]</p>
<p>In the main function, I set myString1 &#61; Ja, String of myString2 &#61; va, String myString3 &#61; Java. And string myString4 equal the concatenation, myString1 &#43; myString 2. So the internal contents of myString3 and myString4 are the same, but their memory locations, what they refer to is not. So when we do System.out.println of using double equal sign, comparing myString3 and myString4 with double equals.</p>
<p>This is going to return false even though their internal values are the same. We need to use when comparing string values is the equals method. So this is a method of the object class that gets inherited by string and <br /><br />[Video description begins] <em>Screen title: Java equals() Method</em> [Video description ends] <br /><br />many other classes to compare the contents of the objects. And it&#39;s for testing the content equality, and not the object reference equality. So here we can see the entire thing highlighted. <br /><br />[Video description begins] <em>A screen with title, Comparing String Using equals(), displays. Underneath the title lies the following code: public class JavaComparisons{ public static void main(String[] args){ String myString1 &#61;&#34;Ja&#34; ; String myString2 &#61;&#34;va&#34; ; String myString3 &#61;&#34;Java&#34; ; String myString4 &#61; myString1 &#43; myString2; System.out.println(&#34;using &#61;&#61; results in &#34; &#43; (myString3 &#61;&#61; myString4)); // returns false System.out.println(&#34;using equals() results in &#34; &#43; myString3.equals (myString4)); // returns true } } Finally, at the bottom of the screen, the following information is written: Output: using &#61;&#61; results in false using equals() results in true</em> [Video description ends]</p>
<p>In the main function, the first three lines are the same as my previous code example. myString1 is Ja, myString2 is va, myString3 is Java, and myString4 is the concatenation of myString1 and myString2. So its internal contents are also Java, just like myString3.</p>
<p>Then when comparing the objects, myString3 &#61;&#61; myString4, it returns false even though their contents are the same, the objects are different. But when we compare the contents, we use myString3.equals(myString4). So using equals results in true. And that&#39;s what we get for the output. Using double equals results in false, and using equals, the method results in true.</p>
<p>Then we&#39;ll have a look at one more example.<br /><br />[Video description begins] <em>The code displayed on the screen updates to: public class JavaConditionals{ public static void main(String[] args){ String myString1 &#61;&#34;Ja&#34; ; String myString2 &#61;&#34;va&#34; ; String myString3 &#61;&#34;Java&#34; ; String myString4 &#61; myString1 &#43; myString2; boolean test &#61; (myString3.equals(myString4)); // returns true System.out.println(myString3 &#43; &#34;should be equal to&#34; &#43; myString4);System.out.println(&#34; using equals() results in&#34; &#43; test); } } Finally, at the bottom of the screen, the following information is written: Output: Java should be equal to Java using equals() results in true</em> [Video description ends] <br /><br />So I set up the variables the same as I did in the previous example, myString1 is Ja, J-A, myString2 is va, myString3 is Java, and myString4 is the concatenation of Ja and va, making Java. So I create a variable called test as a Boolean, so I have boolean test &#61; (myString3.equals(myString4)), which returns true.</p>
<p>Then I print myString3&#43; should be equal to &#43;4. So we concatenate the string which will give us Java should be equal to Java. And then using equals results in the result of test, which in this case is true.</p>
<p>So the output is Java should be equal to Java, and using equals results in true as expected. And that concludes this demonstration of the differences between the equals method and the double equals operator in Java.</p></div></div></div><div class="section"><a name="section_10" /><h2 class="section_title">11. Video: Programming the Java equals() Method ( it_sdjcfa_11_enus_11)</h2><img src="https://cdn2.percipio.com/public/b/845479f6-7d96-44f4-9a90-4f0e07df0993/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/845479f6-7d96-44f4-9a90-4f0e07df0993/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the differences between the equals() method and the == operator in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming the Java equals() Method. Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe the difference between equals, <br /><br />[Video description begins] <em>An IntelliJIDEA window titled, StringEqualsDemo-Main.java appears on the screen. Currently, the Main.java file is opened and displays various lines of code.</em> [Video description ends] <br /><br />the method, and the double equal sign operator in Java. So the equals method, in the case of a string is used for comparing the values of the string. The equals operator, the double equal sign, when comparing objects, are to test whether the objects themselves are equal, whether they refer to the same object. And not the actual contents of the objects themselves. So in this Main.java file, I start by putting it into package com.example. And on line 3, I import java.util.Scanner, so that we can take the input of the strings from the command line.</p>
<p>So we&#39;ll actually type in the inputs and compare them. On line 5, I create my public class Main. And on line 7, I have my main entry point declared public static void main (String[] args) as its parameter. And then on line 8, I create Scanner input &#61; new Scanner (System.in) as its argument, so we&#39;re reading from the standard input. On line 10, I have System.out.println (Enter a String), then string a &#61; input.nextLine.</p>
<p>So the string we enter, followed by the Return or Enter key will capture the input for a, then I do the same thing. Then I print, enter another string, followed by string b &#61; input.nextLine, capturing the input of a second string. Then on line 17, I have System.out.println with String a &#61;&#61; String b, and then I concatenate in parentheses (a &#61;&#61; b). So I&#39;m comparing a to b.</p>
<p>But the comment I have on line 16 says, This compares the objects, not the contents of the string. So the only possible way of (a &#61;&#61; b) using the operator for this to be true is if at some point a is set equal to b is assigned to b, or b is assigned to a. Otherwise, even if we enter the same string values, this will never be true.</p>
<p>If we want to compare the string for equality, that returns true if they&#39;re equal and false, if they&#39;re not, I have to use the equals method. And that&#39;s what I do on line 20, boolean areEqual, the variable name &#61; a.equals b. So I pass b as its argument.</p>
<p>On line 21, I have System.out.println, with the literal string Are the strings equal &#43; areEqual(). So I output the contents of the variable which will show us true or false. So I&#39;ll use Shift&#43;F10 to run the code. I&#39;ll enter the first string.</p>
<p>I&#39;ll put in the string hello. The second string I&#39;ll make it identical with hello, and they&#39;re both in lowercase. So it&#39;s important that they&#39;re the same case, otherwise they won&#39;t be equal. And in this case string a equal string b is false.</p>
<p>So the objects are different. And are the strings equal? Well, that&#39;s true because they&#39;re identical. If I do something such as Hello with a capital H, so leading with an uppercase H, and then hello all in lowercase.</p>
<p>In this case, while string a and string b are still false, and they&#39;ll always be false no matter what we put in, and are the strings equal in this case? No, they&#39;re not, so it returns false. And that concludes this presentation on comparing the equals method with the double equals operator.</p></div></div></div><div class="section"><a name="section_11" /><h2 class="section_title">12. Video: Java compareTo Method ( it_sdjcfa_11_enus_12)</h2><img src="https://cdn2.percipio.com/public/b/3904fc4d-6dde-4880-8907-9eb85e15e552/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/3904fc4d-6dde-4880-8907-9eb85e15e552/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe how to compare two String objects by using the compareTo method</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java compareTo Method. Your host for the session is Steve Scott.</em> [Video description ends]
<p>In this video, I&#39;ll describe the use of the Java compareTo method. So the Java compareTo method is quite often used with strings for lexicographic comparison, an ordered comparison, which comes first and which comes second when compared lexicographically or alphabetically. Now the reason why we say lexicographic is because we&#39;re doing a Unicode value of characters comparison. And the way the method works is it returns less than zero if the string you have is less than the one you&#39;re comparing to, so if it comes before it. It returns greater than 0, if your string is greater than the one you&#39;re comparing it to, so if it comes after it lexicographically. So what does this look like? <br /><br />[Video description begins] <em>A screen with title, Comparing Strings Using compareTo(), displays. Underneath the title lies the following code: public class JavaComparisons{ public static void main(String[] args){ String myString1 &#61;&#34;Ja&#34; ; String myString2 &#61;&#34;va&#34; ; System.out.println(&#34;compareTo() value is&#34; &#43; myString1.compareTo(myString2))); } } Finally, at the bottom of the screen, the following information is written: Output: compareTo() value is -44</em> [Video description ends] <br /><br />Well, let&#39;s take two strings.</p>
<p>In this example code, in the main function, I have String myString1 &#61; Ja and String myString2 &#61; va. And then I print using System.out.println compareTo value is, and I concatenate the results of myString1.compareTo myString2 as its argument. And the output of this is compareTo value is -44. So it computes the difference between the two strings, in this case, the difference between the character J, the uppercase J and the lowercase v. And since it&#39;s negative, that means myString1 comes before myString2 when considered lexicographically. What if the strings are equal? <br /><br />[Video description begins] <em>The code on the screen updates to: public class JavaComparisons{ public static void main(String[] args){ String myString1 &#61;&#34;Java&#34; ; String myString2 &#61;&#34;Java&#34; ; System.out.println(&#34;compareTo() value is&#34; &#43; myString1.compareTo(myString2))); } } Finally, at the bottom of the screen, the following information is written: Output: compareTo() value is 0</em> [Video description ends]</p>
<p>Well, in this case, I have String myString1 &#61; Java, String myString2 &#61; Java. And the compareTo value of myString1.compareTo myString 2, the value is 0. So when they&#39;re the same, it returns 0. Let&#39;s have a look at how lowercase and uppercase letters compare. <br /><br />[Video description begins] <em>The code on the screen updates to: public class JavaComparisons{ public static void main(String[] args){ String myString1 &#61;&#34;Java&#34; ; String myString2 &#61;&#34;JAVA&#34; ; System.out.println(&#34;compareTo() value is&#34; &#43; myString1.compareTo(myString2))); } } Finally, at the bottom of the screen, the following information is written: Output: compareTo() value is 32</em> [Video description ends] <br /><br />So I have String myString 1 &#61; Java with an uppercase J and lowercase a-v-a, String myString 2 &#61; JAVA all in uppercase, so uppercase J-A-V-A. And the result here of System.out.println with the string compareTo value is myString1.compareTo myString2, the value is 32.</p>
<p>And this value means that myString1 comes after myString2. And the reason for this, is that the uppercase letters come before the lowercase letters. So the comparison here is between the first a in Java, so the uppercase A and the lowercase a. And the difference, the numeric difference in terms of its Unicode value between uppercase A lowercase a is 32.</p>
<p>So it only needs to compare the first two characters to determine which one comes first and what the value of the comparison is. What happens if we have the same strings but in different orders? <br /><br />[Video description begins] <em>The code on the screen updates to: public class JavaComparisons{ public static void main(String[] args){ String myString1 &#61;&#34;Java coding&#34; ; String myString2 &#61;&#34;coding Java&#34; ; System.out.println(&#34;compareTo() value is&#34; &#43; myString1.compareTo(myString2))); } } Finally, at the bottom of the screen, the following information is written: Output: compareTo() value is -25</em> [Video description ends] <br /><br />So the same characters, so it has nothing to do with the value of all of the individual characters, it&#39;s only the individual characters that come first.</p>
<p>So in this example, I have string myString1 &#61; Java coding and String myString2 &#61; coding Java with everything in lowercase except for the uppercase J on Java. So the compareTo value of myString1.compareTo myString2 in this case is -25, the difference between the uppercase J and the lowercase c. That&#39;s the only comparison needed to determine the value of the compareTo. So the first difference in the string gives us our value. If there are no differences, it returns 0, meaning the strings are the same. And that concludes this presentation on the Java compareTo operator.</p></div></div></div><div class="section"><a name="section_12" /><h2 class="section_title">13. Video: Programming the Java compareTo Method ( it_sdjcfa_11_enus_13)</h2><img src="https://cdn2.percipio.com/public/b/4b68fa14-05c3-448b-807e-d5e9f01292ef/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/4b68fa14-05c3-448b-807e-d5e9f01292ef/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">compare two String objects by using the compareTo method</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming the Java compareTo Method. Your host for the session is Steve Scott.</em> [Video description ends]<br /><br />[Video description begins] <em>An IntelliJIDEA window titled, CompareToDemo-Main.java appears on the screen. Currently, the Main.java file is opened and displays various lines of code.</em> [Video description ends]
<p>In this video, I&#39;ll demonstrate how to compare using the Java compareTo method and how to interpret the results. So compareTo is an ordered comparison. You&#39;re not just comparing two items and getting results that says if they&#39;re the same or not so a binary true or false, you&#39;re actually getting some extra information about the order of the items. When using a string, the CompareTo is for lexicographical order, or more commonly known as alphabetical order.</p>
<p>Let&#39;s start in the example code I have here in main.java. On line 1 I include package com.example to give it a package, and then on line 3 I import java.util.Scanner so we can get some input. And in this case we&#39;re going to input two strings and compare them. On line 5 I declare my class public class Main, and the main entry point to the application public static void main(String[] args), the common Java entry point. On line 8 I create my input scanner, Scanner input &#61; new Scanner with System.in as its argument, so that we can read values from the standard input.</p>
<p>On line 10 I have System.out.println, Enter a String. On line 11, String a &#61; input.nextLine so we can type in some characters hit Enter, and it will accept that as string a. On line 13 System.out.println of Enter another String, then String b &#61; input.nextLine to get the second string. On line 16 I have a value int stringOrder &#61; a.compareTo(b).</p>
<p>So a is a string with a compareTo method that takes an argument as another string. Its return value is an integer using the equals method, it will return a binary, true or false to determine whether the values of the strings are the same or not.</p>
<p>In this case, it returns 0 if they&#39;re the same. If the string order is less than 0, that means string a comes before string b when talking in alphabetical terms, and if string order is positive or greater than 0, then that means b comes before a, when we&#39;re talking alphabetically. So on line 17, I have if string order is equal to 0, I print the strings are equal else if string order is less than 0, then I print string a so I show the contents of a surrounded in single quotes comes before the with string b surrounded in single quotes.</p>
<p>Else if string order is greater than 0, then string b comes before string a. I&#39;ll type Shift&#43;F10 to run the code, and I&#39;ll enter the first string I&#39;ll type hello, enter the second string hello. So these are the same, and it&#39;s important that they&#39;re of the same case. So they&#39;re both in lowercase and it gives me the strings are equal.</p>
<p>And why that&#39;s important if I run it again and enter Hello with a capital H, so capital H E L L O, and then Hello with the lowercase h, and it tells me string hello with a capital H comes before hello was the lowercase h, so the uppercase letters come before the lowercase letters.</p>
<p>So if you&#39;re sorting something and we come upon a word that spelled the same but different in case, then the one with the uppercase will come first, I&#39;ll run it again. And this time, i&#39;ll just hit Enter. So if we enter a string using the input scanner, and we just type enter, it actually stores an empty string.</p>
<p>I can also put a space in so the second string, I&#39;m going to put a space, so I&#39;m going to compare an empty string to a space. And it gives me string double single quotes so there is nothing in between so the empty string comes before the string with single space.</p>
<p>So the empty string will always comes first when we are talking alphabetically or lexicographically. Let&#39;s compare something else. Let&#39;s look at a string as just a character a compared to a number, so the number 1, in this case is not an integer, but actually the character 1.</p>
<p>So what comes first, the a or the 1? And when compared lexicographically or alphabetically, the character 1 comes before the character a. And we&#39;re dealing with numbers, the number 0 comes first, and the numbers appear as strings in the order you&#39;d expect. So 1 comes before 2, etc, all the way to 9. And that concludes this demonstration of programming with the Java compareTo method.</p></div></div></div><div class="section"><a name="section_13" /><h2 class="section_title">14. Video: Course Summary ( it_sdjcfa_11_enus_14)</h2><img src="https://cdn2.percipio.com/public/b/4d6a5e94-1a9a-4eda-9408-0befff89f506/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/4d6a5e94-1a9a-4eda-9408-0befff89f506/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">summarize the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Summary.</em> [Video description ends]
<p>So in this course, we&#39;ve examined various types of Java decision statements. We did this by exploring Java decision statements, programming Java if-then, if-then-else, and switch statements. Java string comparison operators and methods. Programming Java Equal() and compareTo operators.</p>
<p>In our next course, we&#39;ll move on to explore ways to create loops in the Java programming language.</p></div></div></div><div class="copyright-container"><span class="copyright-text">© 2022 Skillsoft Ireland Limited - All rights reserved.</span></div></div><div id="lb-overlay"><div class="lb-header"><button onclick="(()=>{const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'hidden';const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 1.0;curtain.style.backgroundColor = 'white';curtain.style.pointerEvents = 'auto';})();">X</button></div><div id="lb-image-container"><img id="lb-image" alt onload="(()=>{const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 0.5;curtain.style.backgroundColor = 'grey';curtain.style.pointerEvents = 'none';const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'visible';window.scrollTo(0, 0);})();"/></div><div class="lb-footer" /></div></div></body></html>