<!doctype html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-style-type" content="text/css2"><title>Course Transcript</title><link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css"><style>:root {
    --title-text: #243038;
    --toc-link: #0073C4;
    --section-title-text: #243038;
    --section-title-border: #bababa;
    --grid-caption-text: #164794;
    --grid-border: #c0c0c0;
    --grid-hdr-text: #973131;
    --grid-hdr-background: #f7f7f7;
    --missing-data: #767676;
    --text-color: #343434;
    --lightbox-border: #a0a0a0;

    --bold-font-weight: 700;

    font-family: Lato;
}

.report {
    margin: 24px;
}

.container {
    position: relative;
}

#lb-curtain {
    background-color: white;
    opacity: 1.0;
}

#lb-overlay {
    position: absolute;
    top: 40px;
    left: 20px;
    right: 20px;
    background-color: white;
    border: solid 1px var(--lightbox-border);
    visibility: hidden;
}

.lb-header, .lb-footer {
    height: 40px;
    line-height: 40px;
}

.lb-header {
    display: flex;
    justify-content: flex-end;
    padding-right: 20px;
}

#lb-image-container {
    margin: 0 40px;
}

#lb-image {
    width: 100%;
}

.report_title {
    font-size: 22px;
    font-weight: var(--bold-font-weight);
    color: var(--title-text);
}

.toc_link {
    font-size: 14px;
    color: var(--toc-link);
    margin-top: 6px;
    margin-bottom: 0;
}

.section {
    margin-top: 40px;
    margin-left: 16px;
}

.section.inner {
    margin-top: 20px;
}

.section.inline {
    margin-top: 20px;
    margin-left: 0;
}

.section_title {
    font-size: 18px;
    font-weight: var(--bold-font-weight);
    width: 100%;
    color: var(--section-title-text);
}

h2.section_title {
    border-bottom-color: var(--section-title-border);
    border-bottom-style: solid;
    border-bottom-width: thin;
}

h3.section_title {
    margin: 8px 0;
}

h3.list_title {
    margin: 8px 0;
    font-size: 14px;
    color: var(--title-text);
}

.section_text {
    font-size: 14px;
    color: var(--text-color);
    margin: 12px 0;
    width: 90%;
}

.section_link {
    font-size: 14px;
    margin: 12px 0;
    width: 90%;
}

.grid {
    border-collapse: collapse;
}
.grid_caption {
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    color: var(--grid-caption-text);
    margin: 12px 0;
    text-align: left;
    white-space: nowrap;
}
.grid_hdr_row {

}
.grid_col {
    font-size: 13px;
    color: var(--text-color);
    border-collapse: collapse;
    padding: 2px;
    text-align: left;
    vertical-align: top;
}
.grid_col_hdr, .grid_row_hdr {
    font-size: 12px;
    font-weight: var(--bold-font-weight);
    white-space: nowrap;
}
.grid_row_hdr {

}

.empty_grid {
    border-collapse: collapse;
    border-color: var(--grid-border);
    border-style: solid;
    border-width: 2px;
    padding: 4px;
    text-align: center;
}

.htmlbox {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    padding: 8px;
}

.list {
    font-size: 14px;
    font-style: italic;
}

.missing_data {
    color: var(--missing-data);
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    font-style: italic;
}

.copyright-container {
    margin-top: 24px;
    text-align: center;
}
.copyright-text {
    color: var(--text-color);
    font-size: 12px;
}

/* Transcript Questions CSS */

.question {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    display: flex;
    flex-direction: column;
    padding: 8px;
}

.question_content {
    display: flex;
    justify-content: space-between;
}

.question_details {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.question_images {
    display: flex;
    flex-direction: column;
    margin-left: 16px;
}

.question_image {
    margin-bottom: 8px;
}

.question_title {
    font-weight: var(--bold-font-weight);
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
    padding-bottom: 8px;
    margin-bottom: 8px;
}

.question_label, .question_stem {
    font-weight: var(--bold-font-weight);
    margin-top: 8px;
    margin-bottom: 8px;
}

.question_data_row {
    display: flex;
}

.question_data_col1 {
    padding: 8px;
    white-space: nowrap;
}

.question_data_col2 {
    padding: 8px;
    display: flex;
    flex-direction: column;
}

.question_answer_key {
    margin-top: 8px;
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
}

.feedback {
    font-style: italic;
}
</style></head><body class="report"><div class="container"><div class="content" id="lb-curtain"><h1 class="report_title">Java Certified Foundations Associate: Java Concepts & Features</h1><div class="section_text">Java is a powerful object-oriented programming language that allows you to write code once and deploy it on multiple operating systems. In this course, you&#39;ll learn about the Java programming language and related concepts, as well as how to work with the Java Development Kit and the Java Runtime Environment.

First, you&#39;ll learn about the Java Virtual Machine and object-oriented programming concepts. Next, you&#39;ll explore Java features, such as platform independence, security and robustness, architecture neutrality, portability, and performance. Finally, you&#39;ll learn about Java distributed applications, multi-threading, dynamic loading, and real-world applications.

This course is one of a collection of courses that prepares learners for Oracleâ€™s 1Z0-811: Java Certified Foundations Associate certification.
</div><div class="section"><h2 class="section_title">Table of Contents</h2><div class="toc"><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_0">1. Video: Course Overview ( it_sdjcfa_01_enus_01)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_1">2. Video: Java Features ( it_sdjcfa_01_enus_02)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_2">3. Video: Java Virtual Machine  ( it_sdjcfa_01_enus_03)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_3">4. Video: Java Object-oriented Programming ( it_sdjcfa_01_enus_04)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_4">5. Video: Java Platform Independence ( it_sdjcfa_01_enus_05)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_5">6. Video: Java Security and Robustness ( it_sdjcfa_01_enus_06)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_6">7. Video: Java Architecture Neutrality ( it_sdjcfa_01_enus_07)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_7">8. Video: Java Portability ( it_sdjcfa_01_enus_08)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_8">9. Video: Java Performance ( it_sdjcfa_01_enus_09)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_9">10. Video: Java Distributed Applications ( it_sdjcfa_01_enus_10)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_10">11. Video: Java Multi-threading ( it_sdjcfa_01_enus_11)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_11">12. Video: Java Dynamic Loading ( it_sdjcfa_01_enus_12)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_12">13. Video: Java Real-world Applications ( it_sdjcfa_01_enus_13)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_13">14. Video: Course Summary ( it_sdjcfa_01_enus_14)</a></p></div></div><div class="section"><a name="section_0" /><h2 class="section_title">1. Video: Course Overview ( it_sdjcfa_01_enus_01)</h2><img src="https://cdn2.percipio.com/public/b/8ba19393-ab30-4d25-9c74-a74e3fbb3bda/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/8ba19393-ab30-4d25-9c74-a74e3fbb3bda/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">discover the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Overview.</em> [Video description ends] Hi, I&#39;m Steve Scott. I&#39;ve been a software developer and tech consultant for [Video description begins] <em>Steve Scott is an IT consultant.</em> [Video description ends] almost a quarter of a century. I&#39;ve traveled around the globe to serve clients, where I&#39;ve been responsible for building secure systems, hiring development teams, and solving complex problems through technology. With my toolbox of languages, platforms, frameworks and APIs, I round up my technical experience with an academic background in mathematics and computer science. [Video description begins] <em>Screen title: Learning Objectives.</em> [Video description ends]<br /><br />Oracle&#39;s 1Z0-811 Java Certified Foundations Associate Certification is targeted to audiences seeking foundational knowledge of the Java programming language and its concepts. Individuals tackling this certification will demonstrate they can write and executed a Java program work with the Java Development Kit, JDK, and the Java Runtime Environment, JRE. In this course, I&#39;ll review Java virtual machine and object-oriented programming concepts. Next, I&#39;ll discuss the features of Java, such as platform independence, security and robustness, architecture neutrality, portability and performance. Finally, I&#39;ll move to Java-distributed applications, multi-threading, dynamic loading and real-world applications.</div></div></div><div class="section"><a name="section_1" /><h2 class="section_title">2. Video: Java Features ( it_sdjcfa_01_enus_02)</h2><img src="https://cdn2.percipio.com/public/b/c9d5f379-aaa4-4163-b4ed-55e1ad2a90e4/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/c9d5f379-aaa4-4163-b4ed-55e1ad2a90e4/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the main features of the Java programming language</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Features. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the main features of the Java programming language. Java is an object oriented programming language that encapsulates data and methods in objects and makes use of inheritance. Inheritance refers to the traits that an object gets from a parent object. The properties and behaviors it inherits. Think of the analogy in the real world where a child inherits the genes and traits of a parent. Whether we&#39;re talking about a human or other animal, or even a plant species, or any living thing. Some characteristics are defined by genes and some by the individual. In Java, classes are the logical entities that describe the blueprint that objects can be created or instantiated from and inherited from. <br /><br />Think of a blueprint for a house. Many houses can be built or created from a given blueprint. Objects in Java are entities that have both state and behaviors created from the class blueprint. Whether you&#39;re conceptualizing a cat, a house, or a tabular list of values. Objects are what represents the instance of it in a program. So Java is based on objects, classes, and interfaces, with objects being the stateful entities existing in a Java program&#39;s memory. And its behaviors and how a program interacts with it is based on the class blueprint and the interfaces it implements. Classes are the logical structure of properties and methods that objects can be instantiated from. Java also has the concept of regular classes and of abstract classes. And for abstract classes, objects can&#39;t be created directly from them, but they&#39;re used to help define other classes.<br /><br />And interfaces are a type of abstract class, but they don&#39;t contain any code. Interfaces regulate a class, describing how parts of the blueprint must be implemented. Interfaces are a way of making interaction with the class consistent. And taking the analogy of the house. You can think of the interface describing how a house should be built in terms of sizes and functions of elements in the house. Such as the size of a door and the fact that it can open and close. What are the conceptual elements that make up an object? Well objects can have variables to maintain the state of the object. To describe certain characteristics about it. For example, if we have an individual cat, it may be described by its color, its size, and a name. Objects have behavior and can perform actions. <br /><br />For example a cat has the ability to walk, run, jump, and meow. Objects have a unique identity. Even if two objects are the same, they are differentiated. Twin cats, even a clone of a cat, would be different. No two objects can occupy the same space at the same time. In Java objects, we have a unique object identity which is used to internally identify it by the Java virtual machine. Even if multiple objects have exactly the same properties, they are uniquely identified. Apart from Java&#39;s object oriented foundations, some of the features of the Java programming language include the following. Java is considered to be a secure programming language because it does not permit explicit memory pointers. And it runs inside a virtual machine sandbox. Components such as the class loader, bytecode verifier, and the security manager provide further security features. <br /><br />And mechanisms to ensure the code is safe. Java is considered to be a robust programming language. Since it provides strong memory management, the absence of memory pointers, and automatic garbage collection. And exception handling and type checking mechanisms. Java is considered architecturally neutral. Because it doesn&#39;t have implementation-dependent features such as the size of primitive data types. Such as int, which is different on different operating systems and hardware architectures. So Java makes these consistent across the various platforms it can run on. Some more features of Java include. It&#39;s simplicity to learn due to the absence of explicit memory pointers and operator overloading. And it&#39;s a garbage collected language, so explicit calls to free memory when it&#39;s no longer in use is not required. Java is compiled into bytecode which runs on a Java virtual machine. <br /><br />Which then compiles the bytecode to run on local platforms which allow for code portability. Without having to create a separate binary file for each platform implementation. Java virtual machines can run on multiple operating systems and processor architectures, which allow Java to be platform independent. Some additional features that benefit the Java programmer are. Java supports multithreaded processes and uses a common memory area that&#39;s easy to synchronize with. Java supports the creation of distributed applications and allows for the use of remote method invocation. And Java is a dynamic programming language and supports loading classes on demand. Dynamic compilation, and automatic garbage collection. And that concludes this presentation on Java features.</div></div></div><div class="section"><a name="section_2" /><h2 class="section_title">3. Video: Java Virtual Machine  ( it_sdjcfa_01_enus_03)</h2><img src="https://cdn2.percipio.com/public/b/664b3db1-69ed-4a47-87d2-d05ea9eac92d/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/664b3db1-69ed-4a47-87d2-d05ea9eac92d/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the Java Virtual Machine and how it relates to Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Virtual Machine. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the Java virtual machine and how it relates to Java. So Java and other languages that compile to Java bytecode, such as Scala and Clojure, are available to run on the Java virtual machine, or JVM for short. The JVM is available for multiple operating systems, allowing Java to run on NAT OS. The JVM contains several key components. The class loader needs to recognize and load code that compiles with the Java class file format. The Java virtual machine architecture operates on basic values such as integers and floating point numbers. And contains a garbage collector to manage heap memory. <br /><br />Java bytecode is an abstract machine language that runs on the JVM. Java code is compiled to Java bytecode. And JVM languages include any language that can compile down to Java bytecode. The bytecode verifier checks and confirms all bytecode before it&#39;s executed on the JVM. And bytecode interpreters will run Java bytecode on any machine that runs the interpreter. The just-in-time compilation we&#39;ll convert and translate Java bytecode into native machine language in real time. The class loader is used to recognize and load code that compiles with the Java class file format. Some of the key components of the class loader include the following. The first action of the loader is to find and import the binary data for the type. <br /><br />During the linking process the following occurs. Verification is performed to ensure the correctness of the imported type. Then preparation is done to set aside memory for class variables. And during the initialization phase, the Java code is invoked and the class variables are initialized. The Java virtual machine has several key components that are essential to its operation. The JVM operates on basic values such as integers and floating point numbers. Each JVM thread has its own call stack, which is used to store frames and frames are created when a method is called and is deleted when the method exits. The JVM garbage collector is used to manage data that is stored on the heap. Memory is automatically garbage collected and fried when there are no more references to that memory. <br /><br />Java Bytecode is an abstract machine language that runs on the JVM. Bytecode instructions are grouped into the following types of tasks. Load and store instructions are used to provide memory access and arithmetic logic unit ALU operation. Arithmetic operations perform mathematical functions on data type conversion operations are used to convert from one data type to another. Object creation processes are used to create new objects and arrays. Operand stack management processes are used to push and pop data from the stack. Control transfer operations are used to move to locations in the bytecode. Method invocation processes involve jumping to sub routines and carrying out returns. The exception processes involve catching and throwing exceptions. <br /><br />Monitor based concurrency processes are used for working with threads and multiple processes. The JVM languages include any language that can compile down to Java bytecode. Besides Java, here are a few other high profile languages which run in the JVM. Jython is an implementation of the Python programming language that can be compiled to Java bytecode. JRuby, is an implementation of the Ruby programming language. And Clojure is the dynamic and functional dialect of Lisp, which compiles the bytecode and runs in the JVM. The bytecode verifier checks and confirms all bytecode before it&#39;s executed on the JVM, and performs the following checks. The bytecode is verified to ensure all branches are always jumping to valid memory locations. It ensures data is initialized and that references are always type-safe.<br /><br />It ensures access to package or package private methods and data are strictly controlled. And Java is platform-independent and secure due to the JVM. The Java bytecode can be either interpreted or compiled to run natively in just-in-time fashion. Bytecode interpreters can run Java bytecode on any machine that runs an interpreter. The just-in-time or JIT compiler will convert and translate Java bytecode into native machine language as needed when it&#39;s run. And that concludes this presentation on the Java virtual machine.</div></div></div><div class="section"><a name="section_3" /><h2 class="section_title">4. Video: Java Object-oriented Programming ( it_sdjcfa_01_enus_04)</h2><img src="https://cdn2.percipio.com/public/b/27ec03ce-5147-4eb0-a468-103078e1447d/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/27ec03ce-5147-4eb0-a468-103078e1447d/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the key components of object-oriented programming and how it relates to Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Object-oriented Programming. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the key components of object-oriented programming and how it relates to Java. Java makes use of several object-oriented programming concepts such as encapsulation, abstraction and polymorphism. Encapsulation refers to classes which set access controls to properties to private, making access only possible through methods. Other classes cannot access the private properties directly, which is why it&#39;s also called data hiding. Abstraction refers to class blueprints that cannot be instantiated into objects on their own. <br /><br />But they provide a partial blueprint that allows for consistent implementation of concepts. Java uses the abstract class and interface concepts to achieve this type of partial blueprint. Polymorphism is when a class changes its inherited behavior. This is done through what is called method overriding and method overloading. The outward structure of the inherited behavior, the common blueprints are similar, but the underlying implementation differs. Some of the features of the Java programming language include the following. Java is considered a secure programming language because it does not permit explicit memory pointers, and runs inside a virtual machine sandbox. <br /><br />Components such as the class loader, bytecode verifier, and the security manager provide further security features and mechanisms to ensure safe code. Java is considered robust, since it provides strong memory management, the absence of memory pointers and automatic garbage collection, and exception handling and type checking mechanisms. Java is considered architecturally neutral, since there are no implementation dependent features, such as the size of primitive data types like int, which could be different on different operating system architectures and system hardware. Java inheritance refers to the ability of a class to obtain the properties and behaviors of a parent class. Class inheritance is done through extending an existing class. This allows for new features to be implemented, while reusing code that can be more universally described.<br /><br />An interface is a type of class that describe methods that must be interacted with. But the actual implementation is defined by a class that implements the interface. And classes are able to implement more than one interface. However, for direct class inheritance, a class may only extend one other class, known as its base, parent, or superclass, using the extends keyword. Let&#39;s talk a little bit more about the terminology of Java classes. A class is a blueprint for an object that describes the common properties and methods. A class can generally be instantiated into an object unless it&#39;s an abstract class. In which case it&#39;s expected that a non-abstract class that inherits from it will be instantiated into an object. The superclass is what we call the class that is inherited from. It&#39;s also called the base or parent class. <br /><br />A subclass is the class that inherits from another class and is also called a child, derived, or extended class. And in Java when we talk about reusability, it refers to classes being able to make use of the fields and methods they inherit from their superclass. Java abstract classes are similar to a regular type of class, but they can&#39;t be instantiated directly. Abstract classes are restricted and can only be inherited by from other classes. They cannot be used to create objects. Abstract methods contain a signature of a method such as the name, the return type, and any parameters being passed to the method. Then the code of the abstract method must be written in any class that inherits from the abstract class, unless it&#39;s an abstract class itself. Abstract classes can have regular methods that have code. <br /><br />And these methods can be overwritten by the classes that extend it, but it&#39;s not required. Java interfaces are similar to abstract classes, in that they cannot be used to instantiate or create objects, but they can&#39;t contain any code. So interfaces can be thought of as a partial blueprint. A type of blueprint for a class that contain the signature of the method including the return type, method name, and the name and type of its parameters, but has no code body. Interfaces are completely abstract. Abstract classes can have regular methods, but interfaces cannot. And an interface is meant to be inherited by a class through the implements keyword. And unlike an abstract class, multiple interfaces can be implemented by a class. And that concludes this presentation on Java object-oriented programming.</div></div></div><div class="section"><a name="section_4" /><h2 class="section_title">5. Video: Java Platform Independence ( it_sdjcfa_01_enus_05)</h2><img src="https://cdn2.percipio.com/public/b/7ba313af-aa22-4964-8dfd-7b4f04d3d0c9/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/7ba313af-aa22-4964-8dfd-7b4f04d3d0c9/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the platform independence of Java and the advantages and drawbacks of this approach</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Platform Independence. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the platform independence of Java, and the advantages and drawbacks of this approach. Java is a platform independent language which allows for programs to be written once, and run on multiple operating systems. Platforms are software and hardware systems comprising mainly of the operating system and processor architecture, as well as other onboard devices and systems. Independence means that compiled Java bytecode can run on different combinations of platforms without having to be recompiled. You deploy the same Java code on every platform it runs on, without having to change it for each platform. <br /><br />A Java Runtime Environment, JRE, for each platform runs the Java bytecode through the JVM. Regular programming languages, in terms of platform native executables, are compiled to run directly on operating systems such as Windows, Linux, or BSD. Different versions of the same program have separate platform configurations and are compiled for each platform it runs on. The Java programming language only needs to be compiled once, and the same version of code can be run on multiple platforms. The Java Development Kit, JDK, provides the necessary prerequisites for running Java programs. Some components of the JDK are as follows. The Java Runtime Environment, JRE, contains a stand alone, the Java standard library, and a configuration tool. The javac compiler is used to compile Java code to platform neutral byte code. <br /><br />And the Java Virtual Machine, JVM, contains the class loaders, the bytecode verifiers, the bytecode interpreter, and the just in time compiler. So the Java Virtual Machine runs compiled bytecode. The process of running Java code on the JVM is as follows. A Java code is created in a development environment, such as IntelliJ or Eclipse, or even just the basic text editor. The Java Development Kit, the JDK includes the javac compiler, which compiles Java code to bytecode. JVMs are developed specifically for the OS they run on, and only run on that OS. So the JVM reads the bytecode files, the class files, and interprets it and runs it on top of OS, whether it&#39;s a JVM running on Windows or Linux or some other operating system. The Java programming language has many features besides portability. <br /><br />Some of the features include the following. Well, in terms of portability, it means that the compiled Java program can run on any operating system with the JVM installed. The compiled program does not depend on any specific operating system or CPU architecture. Java is an object oriented programming language which supports objects, classes, encapsulation, inheritance, and polymorphism. And Java supports multi-threaded applications and multiple tasks can be performed in parallel. Some more features are as follows. Java is considered a secure programming language because it does not permit explicit memory pointers and runs inside of the JVM sandbox. Components such as the class loader, bytecode verifier, and the security manager provide further security features and mechanisms to ensure safe code.<br /><br />The Java programming language is easy to learn due to the absence of explicit memory pointers and operator overloading. And also because of automatic garbage collection. The Just in time compiler or JIT compiler ensures that compile Java programs run quickly and efficiently. Java programming is platform independent due to the bytecode that is generated when Java is compiled. There are however limitations to this platform independence. Bytecode is portable and can be run on any operating system that has the JVM installed. If there isn&#39;t a JVM installed on the operating system, then the bytecode will not run. Java virtual machines themselves are platform dependent. And every operating system requires a version of the JVM compiled specifically for that operating system and its underlying processor architecture. And that concludes this presentation on Java platform independence.</div></div></div><div class="section"><a name="section_5" /><h2 class="section_title">6. Video: Java Security and Robustness ( it_sdjcfa_01_enus_06)</h2><img src="https://cdn2.percipio.com/public/b/f9822d89-9866-426d-94f2-ac7619316274/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/f9822d89-9866-426d-94f2-ac7619316274/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the features of Java that ensure it is safe, secure, and robust</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Security and Robustness. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the features of Java that ensure that it&#39;s safe, secure, and robust. Java is considered a secure programming language because it doesn&#39;t permit explicit memory pointers and runs inside a virtual machine sandbox, providing an extra layer of protection. Components such as the class loader, bytecode verifier, and security manager provide further security features and mechanisms to ensure safe code. The bytecode verifier provided by the JVM checks and confirms all bytecode before it&#39;s executed on the JVM. And the security manager checks to ensure that code is safe and doesn&#39;t try to run outside of the secure JVM sandbox. <br /><br />Java is considered a robust programming language since it provides strong memory management in managing the stack, which is used to store values and references to objects on the heap. The stack manages the scope of objects which can be accessible from the method level or globally. Every thread in Java creates its own stack, making the stack more secure and free from stack smashing attacks. The heap is used to store actual objects with references to the object being stored in the stack. There is a single heap allocated by the JVM for each Java process. The maximum size of the heap and stack dependent on the platform it runs on. So the address space of a 32 bit platform is smaller and different from a 64 bit platform and the JVM takes this into account. Garbage collection is performed automatically and is managed by the JVM. <br /><br />Garbage collection can also be performed or triggered manually by calling system.gc directly. The class loader is used to recognize and load code that compiles with the Java class file format. Some of the key components of the class loader process work as follows. The first action of the loader is to load the appropriate bytecode. Then comes the linking process where verification is performed to ensure the correctness of the imported types. Preparation is done to set aside memory for class variables and initialize the variables to default values. And resolution is used to convert symbolic references to direct references. And during the initialization phase, the Java code is invoked and class variables are initialized. <br /><br />The Java bytecode verifier, checks and confirms all bytecode before it&#39;s executed on the JVM and performs the following checks. It ensures all branches are always jumping to valid memory locations in the JVM. It ensures data is initialized and that references are always typesafe. And it ensures access to package or package private methods and data are strictly controlled. Applications can be secured using the Java security manager in a process called sandboxing. Permission represents the access to a system resource and must be explicitly granted. Java provides predefined permissions such as file permissions and custom permissions can be created as well. Policies are used to grant permissions, and is responsible to determine if the code can perform a secure operation. <br /><br />Code is not granted any permissions by default. Signed code ensures the authenticity of the application and helps to reassure the users that the application is legitimate. Signatures can be tested within the policies. And privileged code, operates at a higher trust level and has permission to access resources, that the code that called it, may not have. And that concludes this presentation on Java security and robustness.</div></div></div><div class="section"><a name="section_6" /><h2 class="section_title">7. Video: Java Architecture Neutrality ( it_sdjcfa_01_enus_07)</h2><img src="https://cdn2.percipio.com/public/b/950d9ee3-ffdb-40a1-9554-dd6a9b458c93/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/950d9ee3-ffdb-40a1-9554-dd6a9b458c93/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the neutral architecture of Java and the benefits that this provides</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Architecture Neutrality. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the neutral architecture of Java, and the benefits that this provides. Architecture neutrality means that software can be written once and deployed on any target platform. Java is an architecture neutral language because of the following features, the Java Development Kit. It provides the necessary prerequisites for running Java programs. Java is compiled into bytecode, which runs on a Java virtual machine, which then compiles the bytecode to run on the local machine, which allows for code portability. <br /><br />JVMs can run on multiple operating systems and their computing environments, which allows Java to be platform independent. The Java Development Kit or JDK provides the necessary prerequisites for running Java programs. Some components of the JDK are as follows. The JRE or Java Runtime Environment contains a standalone JVM, the Java standard library, and a configuration tool. The javac compiler is used to compile Java code to platform neutral bytecode. And the JVM or Java Virtual Machine contains the class loaders, the bytecode verifiers, and the bytecode interpreter, and a just-in-time compiler. Java bytecode is an abstract machine language that runs on the JVM. The code is compiled to Java bytecode using Java files, which are the plaintext source code. <br /><br />The compiled files are class files, so this is compiled bytecode. And the JVM is the abstract computing machine that translates Java bytecode into the host platform&#39;s language. You can think of bytecode as a machine instruction not tied to any one processor architecture. But can be easily translated to run on different operating systems and processors, such as using Windows or Linux. And processor instructions for architectures from Intel, ARM, MIPS, SPARC, POWER, and other CPUs. The Java Virtual Machine runs compiled bytecode. The process of running Java code on the JVM is as follows. Java code is created in a development environment such as IntelliJ, or Eclipse, or some text editor. The JDK includes the javac compiler, which compiles Java code to bytecode. <br /><br />And JVMs are deployed specifically for the OS they run on, and run only on that OS. And the JVM reads the bytecode files, interprets it, and runs it on top of the OS and CPU that the JVM was designed for. Java and other languages that compile to Java bytecode are able to run on the Java Virtual Machine. The JVM is available for multiple operating systems, allowing Java to run on an OS. The JVM contains several key components. There&#39;s the Class loader that needs to recognize and load code that compiles with the Java class file format. The Virtual machine architecture operates on basic values, such as integers, floating point numbers, and contains a garbage collector to manage heap memory. Java bytecode is an abstract machine language that runs on the JVM. <br /><br />Java bytecode gets translated by the JVM into machine instructions for the platform it runs on. Java and other languages that compile to Java bytecode are able to run on the JVM. The JVM languages include any language that compiles to Java bytecode. A bytecode verifier checks and confirms all bytecode before it&#39;s executed on the JVM. And bytecode interpreters can run Java bytecode on any machine that the interpreter runs on, that the JRE and JVM runs on. The just-in-time compiler will convert and translate Java bytecode into native machine language. And that concludes this presentation on Java architecture neutrality.</div></div></div><div class="section"><a name="section_7" /><h2 class="section_title">8. Video: Java Portability ( it_sdjcfa_01_enus_08)</h2><img src="https://cdn2.percipio.com/public/b/c29abc5f-26b0-4ad0-bc09-4037e2bc5945/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/c29abc5f-26b0-4ad0-bc09-4037e2bc5945/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the features of Java that allow it to be portable, such as two-byte code</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Portability. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the features of Java that allow it to be portable. Java can be created on and executed on any device or operating system or platform that contains a Java Virtual Machine. Java is a portable programming language that you can write once and run anywhere. And that&#39;s how Java has been promoted since it was created in the 1990s. The Java compiler, javac is to used to compile Java code to platform-neutral bytecode. Bytecode are platform-independent machine instructions that aren&#39;t tied to any one processor architecture. But they&#39;re executable by the Java Runtime Environment, JRE. <br /><br />Which contains a standalone JVM, the standard Java library, and a configuration tool, which are the key components for allowing portability of the Java bytecode. Java provides three different types of portability including the following. Source code portability, which ensures the Java program generates bytecode that executes and provides identical results on any operating system that the bytecode is run on. The Java Virtual Machines allow CPU architecture portability by running Java bytecode on any CPU that has a JRE interpreter. And user interface portability is achieved with Java providing a set of UI libraries to create virtual user interfaces that run on a variety of desktop environments. Java code should generate the same results on any operating system that it runs on. This is known as source code portability.<br /><br />During the compilation phase, the Java source code is compiled into Java bytecode. This is an intermediary language that is similar to assembly language, but as a generic, easily translatable assembly language that targets the JVM. The bytecode is not compiled to run on any specific operating system or processor architecture. Instead it runs inside a Java Virtual Machine. During the interpretation phase, the class loader will read bytecode files, which can be run on an interpreter or just in time compiler. Java is a portable language which allows for programs to be written once and run on multiple operating systems. The platform is the environment where the software is executed. Java provides a JRE where compiled Java programs can be run. <br /><br />Portability means that the compiled Java program can run on multiple architectures using the JVM. And Java programs allow for the creation of user interfaces to interact with users of the system. So, it&#39;s not limited to command line or server programs. But each operating system has their own unique libraries and code for displaying user interfaces. Some with multiple different desktop environment possibilities, such as in Linux. So Java code is written using a Java library such as AWT, Util and Lang to generate user interfaces that will run on any operating system via the JVM. The Java libraries operate by writing to the JVM, which maps the generic library calls to the underlying desktop and GUI functionality particular to the operating system it&#39;s running on. <br /><br />The Java libraries are written to allow functionality that is common across all operating systems. This allows the user interface and other code to be portable. The only drawback is that functionality unique to an operating system or desktop environment cannot be taken advantage of. And Java relies only on the common functionality across operating systems. But this allows it to be truly platform independent. And that concludes this presentation on Java portability.</div></div></div><div class="section"><a name="section_8" /><h2 class="section_title">9. Video: Java Performance ( it_sdjcfa_01_enus_09)</h2><img src="https://cdn2.percipio.com/public/b/c867eb70-e594-481d-9371-3c2df2398672/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/c867eb70-e594-481d-9371-3c2df2398672/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the features of Java that allow it to run more quickly than traditional interpreted programming languages</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Performance. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the features of Java that allow it to run quicker than traditional interpreted programming languages, such as common scripting or shell languages. The Java Virtual Machine, JVM, has several features that contribute to the performance of the compiled Java program. Some of the optimization features are as follows. The just-in-time compilation, the original JVM&#39;s would interpret Java bytecode, which added to the execution time. JIT compiling was introduced to increase the speed and optimize code that is frequently run. <br /><br />Adaptive optimization performs dynamic recompilation for parts of the program after analyzing the current execution profile. The adaptive optimizer can make trade offs between interpreting and performing JIT compilation of the Java bytecode. The JVM performs garbage collection using a generational collector that divides objects into generations based on when they were created, which allows for a better defragmentation model. The JVM also has other features that allow it to execute quickly. Compressed ordinary object pointers allow Java to use 32 bit references to address up to 32 gigabytes of heap space, which allows for more efficient memory management. Split bytecode verification performs part of the verification when the class is compiled to bytecode. <br /><br />By annotating the compiled bytecode during runtime, bytecode verification can be performed quicker by using the annotations. Escape analysis and lock coarsening means that when a section of code or an object is requested to be locked, it is only locked when necessary. And some more features that allow Java to execute quickly, is the improved allocation of registers. Which did not live across blocks in the client virtual machines initially. Register allocation improvements allow registers to exist for multiple blocks which produces access to the memory. Class data sharing reduces startup times for Java applications and reduces memory consumption by using a shared archive of pre loaded class libraries.<br /><br />When optimizing and tuning Java applications, there are some main techniques that can be applied to the code itself. Some of the techniques are as follows. Storing and working with data in memory is much faster and more efficient than using disk storage. Cache files and data in memory is used where possible. Reading and writing data sequentially is faster than working with memory and disk storage. Try to perform sequential data access whenever possible instead of random access. Creating and destroying object is resource intensive. Create objects only when necessary, and reuse objects whenever possible. Using the precise data formats and data structures helps increase the speed of the application.<br /><br />Don&#39;t grossly over allocate space for arrays and strings as a premature optimization. Only allocate the space you need and increase it as necessary. When optimizing and tuning Java applications there are a few more techniques that can be applied, such as asynchronous IO, which allow other processes to continue running, while the IO process itself continues to run. This also scales better than synchronous IO processes which require blocking. Single thread performance should be optimized before multi-threaded processes can be expected to also perform efficiently. And be careful using shared memory or shared disk storage across threads. This can be bad because multiple processes are fighting for the same resources, which leads to poor performance for all. <br /><br />When you&#39;re trying to synchronize shared memory across multiple threads, you&#39;ll have many threads waiting. Whoever has access to the data to finish before you can get access to it yourself from a different thread. You want to minimize the amount of time that threads are waiting for each other. And that concludes this presentation on Java performance.</div></div></div><div class="section"><a name="section_9" /><h2 class="section_title">10. Video: Java Distributed Applications ( it_sdjcfa_01_enus_10)</h2><img src="https://cdn2.percipio.com/public/b/3357e7b2-bb1c-4054-bd72-280f5b79256a/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/3357e7b2-bb1c-4054-bd72-280f5b79256a/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the features of Java that allow applications to be distributed, such as RMI and EJB</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Distributed Applications. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the features of Java that allow applications to be distributed. Distributed applications consists of multiple clients that connect to multiple backend services over a network over the internet. Java can be written using many architectural models for creating distributed applications. The client server architecture involves the frontend client system that makes requests to backend services over a network. The broker pattern architecture is the system that uses decoupled components that interact using remote service calls. The broker facilitates all communication between the decouples components and redirects tasks to the correct component. <br /><br />The common object request broker architecture or CORBA, is the standard method on implementing the broker pattern. Service-oriented architecture is the design method which allows applications to use available services on a network. The application can be divided into a client-tier, web-tier, business-tier, and enterprise information system-tier. One method for creating distributed applications is to use the client server architecture. This architecture consists of a client application and a server backend. The client server architecture involves a frontend client system that makes requests to backend services. The client initiates all requests with the backend, and is independent of other client applications. The backend system exists independently of the client application. <br /><br />It receives a request to perform tasks and returns the results back to the application that made the request. The backend system can scale by adding additional services and routing clients requests to these additional services so that the load can be balanced. The broker pattern architecture is a system that uses decoupled components that interact using remote service calls. CORBA contains the following components. The Object request broker is the middleware that manages requests between applications and services. Application interfaces are developed for a specific application and can be developed as required for the application. Domain interfaces define interfaces for specific domains such as manufacturing, telecommunication, medical, and financial. They provide a similar function as Common facilities interfaces are horizontally oriented towards end user application.<br /><br />For example, the Distributed Document Componet Facility, DDCF is based on the open dock standard, and can be used to link together documents. And Object services interfaces are not for any specific domain, and can be used by many distributed object programs. A discovery service can help applications find the service that they require. Examples of this are the naming service which finds objects based on their name, and the trading service that finds objects based on their properties. Java applications can be divided into the following application tiers based on a service-oriented architecture and SLA architecture. The client-tier components run locally on the client machine. The web-tier components run in the backend of the Java server. The business-tier components also run in the backend of the Java server. <br /><br />And the Enterprise Information Systems (EIS)-tier services run on the dedicated EIS server. Some of the benefits of using a distributed application architecture are as follows. Some resources can be very costly to run, so you may only have one such resource running. This could be some complex algorithm or service. Using a distributed architecture permits applications to share this resource. Openness involves making a service available to any users that want to be able to consume it. Concurrency is the ability of sections of the program to run in any order without affecting the outcome of the application. Using a distributed architecture permits concurrency. Distributed services can be scaled by creating and running additional virtual machines that provide a service on demand when need of that service increases. <br /><br />Distributed services are fault-tolerant because if a service fails, the request can be redirected to the same service running on a different server or virtual machine. There are several tools that are available to help create distributed applications. Some of the available tools are as follows. Docker, which is used for containerization and is used for creating and scaling backend services and microservices. Kubernetes is used for container orchestration and it&#39;s useful for automating deployments, scaling, and managing containerized applications. JRebel is used to skip redeployments when developing services in Java. This is a useful time saving tool. An XRebel is used to monitor and track requests in real time as they move through a distributed system. And this tool is very useful for debugging. And that concludes this presentation on Java distributed applications.</div></div></div><div class="section"><a name="section_10" /><h2 class="section_title">11. Video: Java Multi-threading ( it_sdjcfa_01_enus_11)</h2><img src="https://cdn2.percipio.com/public/b/8d1558fb-cf54-4a16-8e4c-6b7be5fc6194/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/8d1558fb-cf54-4a16-8e4c-6b7be5fc6194/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the multi-threading features of Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Multi-threading. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the multi-threading features of Java. Multi-threading in Java allows multiple processes to run concurrently within the application. There are two mechanisms in Java for creating threads. The custom class can be created by extending the Java.lang.thread class, which overrides the run method. The custom class is instantiated, and the start method will invoke the run method for the class. A custom class can also implement the Java.lang.runnable interface and override its run method. This custom class is once again instantiated, its start method invoked, and the run method called.<br /><br />When a thread is created, it follows a number of stages in its lifecycle. The thread can be in one of the following states. Threads start in the new state until the thread is started by the program. Then the start method is called once the thread becomes runnable. The run method is called from the start method and the state of the thread is running. Threads may transition to the waiting state while the thread waits for another thread to perform a task. The thread will move back to the running state once the other thread tells it to. And the thread can also be in a time to wait state. The thread will move back to the running state when the time expires. A thread enters the terminated or dead state when a task it is performing is complete or it terminates. The thread class contains several important methods which need to be understood.<br /><br />The important methods are as follows. The start method is used to start the execution of the thread class. The run method is used if the thread object was instantiated using a runnable target. The setName method changes the name of the thread object, and the getName method retrieves the name of it. The setPriority can change the priority level of the thread from a range from one to ten. The thread class contains several important methods which need to be understood. The setDaemon method can be used to designate the thread as a daemon thread. The join method is called to synchronized threads so that two threads can terminate at the same time or until a specified time passes. The interrupt method is used to continue executing if the thread was blocked. <br /><br />And the isAlive method returns the value true if the thread is active or alive. The thread class contains several important static methods which need to be understood, and are as follows. The yield method causes a thread to yield to another thread with the same priority level. The sleep method causes the thread to lock for a number of milliseconds specified in the parameter value. A holdsLock method returns a value of true if the current thread has a lock on a given object. The currentThread method returns a reference to the currently running thread. And dumpStack returns the stack trace of the thread that is currently running. And that concludes this presentation on Java multi-threading.[Video description begins] <em>Topic title: Java Multi-threading. Presented by: Steve Scott.</em> [Video description ends]<br /><br />In this video, I&#39;ll describe the multi-threading features of Java. Multi-threading in Java allows multiple processes to run concurrently within the application. There are two mechanisms in Java for creating threads. The custom class can be created by extending the Java.lang.thread class, which overrides the run method. The custom class is instantiated, and the start method will invoke the run method for the class. A custom class can also implement the Java.lang.runnable interface and override its run method. This custom class is once again instantiated, its start method invoked, and the run method called. When a thread is created, it follows a number of stages in its lifecycle. The thread can be in one of the following states. Threads start in the new state until the thread is started by the program. <br /><br />Then the start method is called once the thread becomes runnable. The run method is called from the start method and the state of the thread is running. Threads may transition to the waiting state while the thread waits for another thread to perform a task. The thread will move back to the running state once the other thread tells it to. And the thread can also be in a time to wait state. The thread will move back to the running state when the time expires. A thread enters the terminated or dead state when a task it is performing is complete or it terminates. The thread class contains several important methods which need to be understood. The important methods are as follows. The start method is used to start the execution of the thread class. The run method is used if the thread object was instantiated using a runnable target. <br /><br />The setName method changes the name of the thread object, and the getName method retrieves the name of it. The setPriority can change the priority level of the thread from a range from one to ten. The thread class contains several important methods which need to be understood. The setDaemon method can be used to designate the thread as a daemon thread. The join method is called to synchronized threads so that two threads can terminate at the same time or until a specified time passes. The interrupt method is used to continue executing if the thread was blocked. And the isAlive method returns the value true if the thread is active or alive. The thread class contains several important static methods which need to be understood, and are as follows. The yield method causes a thread to yield to another thread with the same priority level. <br /><br />The sleep method causes the thread to lock for a number of milliseconds specified in the parameter value. A holdsLock method returns a value of true if the current thread has a lock on a given object. The currentThread method returns a reference to the currently running thread. And dumpStack returns the stack trace of the thread that is currently running. And that concludes this presentation on Java multi-threading. [Video description begins] <em>Topic title: Java Multi-threading. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the multi-threading features of Java. Multi-threading in Java allows multiple processes to run concurrently within the application. There are two mechanisms in Java for creating threads. The custom class can be created by extending the Java.lang.thread class, which overrides the run method. <br /><br />The custom class is instantiated, and the start method will invoke the run method for the class. A custom class can also implement the Java.lang.runnable interface and override its run method. This custom class is once again instantiated, its start method invoked, and the run method called. When a thread is created, it follows a number of stages in its lifecycle. The thread can be in one of the following states. Threads start in the new state until the thread is started by the program. Then the start method is called once the thread becomes runnable. The run method is called from the start method and the state of the thread is running. Threads may transition to the waiting state while the thread waits for another thread to perform a task. The thread will move back to the running state once the other thread tells it to. <br /><br />And the thread can also be in a time to wait state. The thread will move back to the running state when the time expires. A thread enters the terminated or dead state when a task it is performing is complete or it terminates. The thread class contains several important methods which need to be understood. The important methods are as follows. The start method is used to start the execution of the thread class. The run method is used if the thread object was instantiated using a runnable target. The setName method changes the name of the thread object, and the getName method retrieves the name of it. The setPriority can change the priority level of the thread from a range from one to ten. The thread class contains several important methods which need to be understood. <br /><br />The setDaemon method can be used to designate the thread as a daemon thread. The join method is called to synchronized threads so that two threads can terminate at the same time or until a specified time passes. The interrupt method is used to continue executing if the thread was blocked. And the isAlive method returns the value true if the thread is active or alive. The thread class contains several important static methods which need to be understood, and are as follows. The yield method causes a thread to yield to another thread with the same priority level. The sleep method causes the thread to lock for a number of milliseconds specified in the parameter value. <br /><br />A holdsLock method returns a value of true if the current thread has a lock on a given object. The currentThread method returns a reference to the currently running thread. And dumpStack returns the stack trace of the thread that is currently running. And that concludes this presentation on Java multi-threading.</div></div></div><div class="section"><a name="section_11" /><h2 class="section_title">12. Video: Java Dynamic Loading ( it_sdjcfa_01_enus_12)</h2><img src="https://cdn2.percipio.com/public/b/b83385a6-aa65-4567-b96b-061241717e79/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/b83385a6-aa65-4567-b96b-061241717e79/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the dynamic loading features of Java </li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Dynamic Loading. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe the dynamic features of Java, such as Static class loading and Dynamic class loading. So class loaders are used to recognize and load code that compiles with the Java class file format. Static class loading is performed when a class is instantiated with a new operator and the object is instantiated at compile time. Dynamic loading involves invoking the functionality of a class loader at run time. This is done when the class name is unknown at compile time. Some of the key components of the class loader include the following. The first action of the loader is to find and import the binary data for a type.<br /><br />Then during the Linking process, verification, preparation and resolution occur. The Initialization phase comes next. And this is where the code is invoked, and class variables are initialized. The Class loaders get arranged in a hierarchy and creating a new class loader requires using the parent class loader. So the class loader will request that its parent attempt to load a class first. There are several steps that are followed when loading a class. The first step is to check that the class is already loaded. If the class is not loaded, then the parent class loader is asked to load the class. If the parent class loader is unable to load the class, then the current class attempts to load the requested class dynamically. One of the key steps of the class loader is the linking of the class. The steps performed during the linking are as follows. <br /><br />Verification, which is performed to ensure the correctness of the imported type. Preparation is done to set aside memory for class variables and initialize the variables to their initial values. And resolution is used to convert symbolic references to direct references. Loading a class dynamically is done by using the class loader class. In this example code, there is a sample class my class which will be loaded dynamically. The sample class will be used to dynamically load the myclass. The class loader is loading using the getClassLoader method, and then on line 11, the myClass is dynamically loaded using the name of the class. So class myClass &#61; myClassLoader to loadClass. And in quotations, MyClass. <br /><br />And then on line 12 System.out.println has the string myClass.getName &#61; &#43; myClass.getName, and it will return the name of the dynamically loaded class. If the class is loaded correctly. And when loading classes dynamically like this, it&#39;s important to catch any class, not found exceptions and handle it appropriately. And that concludes this presentation on Java dynamic loading.</div></div></div><div class="section"><a name="section_12" /><h2 class="section_title">13. Video: Java Real-world Applications ( it_sdjcfa_01_enus_13)</h2><img src="https://cdn2.percipio.com/public/b/8b6cf92f-7af6-436c-bdb8-2a8bf4f0d8da/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/8b6cf92f-7af6-436c-bdb8-2a8bf4f0d8da/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">recognize examples of real-world Java applications </li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Real-world Applications. Presented by: Steve Scott.</em> [Video description ends] In this video, I&#39;ll describe some examples of real world Java applications. Java can be used to create many types of applications. Some of the application types are as follows. Desktop applications can be created using AWT, the Swing API, the Java foundation classes or Java FX, and real world desktop applications include Adobe&#39;s Acrobat Reader. Web Applications can be written in Java using servlets, struts, spring, hibernates, or JSPs. Real world examples of Java Web Applications include Amazon and Wayfair. Mobile applications can be developed using a cross platform framework called J2Me. <br /><br />Real World mobile applications written in Java include Netflix, Google Earth, and Uber. Java can be used to create many types of applications. Some of the application types are as follows. Enterprise applications can be created using the Java Enterprise edition, Java EE, that has an API and runtime environment for running scripts, enterprise software, network tools, and web services. Real world applications include enterprise resource planning, ERP systems, and Customer resource management CRM systems. Java provides powerful math libraries for creating Scientific applications that generate the same results on multiple platforms. Real world examples of scientific tools include Matlab. There are numerous web and application servers available including Apache Tomcat, WebSphere, JBoss, and WebLogic. <br /><br />Some more application types that can be created with Java are as follow. Embedded Systems, which are applications that are part of low level systems and can be created using Java. Real world examples includes SIM cards and blu ray disc players. Financial institutions such as banks and investment firms used server applications to transfer financial information and transactional data. Many software tools are created with Java such as Eclipse IntelliJ IDEA Java has several popular frameworks that can be used to develop applications. Some of the more popular ones are as follows, JavaServer Faces JSF is used for web application development and uses a model view controller or MVC model for its architecture. Scaffolding is available to limit the amount of code that needs to be written. Blade is a tiny MVC framework created with the goals to be self contained, productive, elegant, and fast. <br /><br />Struts is an open source Apache-based enterprise level framework based on the MVC model that requires reduced development time to create applications. And the Google Web Toolkit, GWT, is an open source and cross compatible framework that allows developers to maintain JavaScript front-end applications in Java. Some more popular frameworks are as follow. Grails is an open source framework that uses the Apache groovy programming language and is built on top of the Java platform and can be integrated with Java libraries. Spring is an application framework and an inversion of control container for the Java platform and usually uses the enterprise Java bean model. Hibernate is an object relational mapping or an O-R-M or ORM tool, providing a framework for mapping an object oriented domain model to a relational database. <br /><br />And the play framework is an application framework that uses the MVC pattern and is written in Scala and compiles to Java byte code. And that concludes this presentation on Java real-world applications.</div></div></div><div class="section"><a name="section_13" /><h2 class="section_title">14. Video: Course Summary ( it_sdjcfa_01_enus_14)</h2><img src="https://cdn2.percipio.com/public/b/a0e28398-463f-4995-a886-aa072a62258c/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/a0e28398-463f-4995-a886-aa072a62258c/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">summarize the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Summary.</em> [Video description ends] So in this Java introduction course, we&#39;ve examined the main features of the Java programming language. We did this by exploring the Java Virtual Machine, JVM. Key components of object oriented programming. Java platform independence, security robustness, and architecture neutrality. And Java portability and performance. In our next course, we&#39;ll move on to examine the features of the Java Development Kit, JDK and the Java Runtime Environment, JRE.</div></div></div><div class="copyright-container"><span class="copyright-text">Â© 2022 Skillsoft Ireland Limited - All rights reserved.</span></div></div><div id="lb-overlay"><div class="lb-header"><button onclick="(()=>{const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'hidden';const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 1.0;curtain.style.backgroundColor = 'white';curtain.style.pointerEvents = 'auto';})();">X</button></div><div id="lb-image-container"><img id="lb-image" alt onload="(()=>{const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 0.5;curtain.style.backgroundColor = 'grey';curtain.style.pointerEvents = 'none';const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'visible';window.scrollTo(0, 0);})();"/></div><div class="lb-footer" /></div></div></body></html>