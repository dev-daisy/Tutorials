<!doctype html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="content-style-type" content="text/css2"><title>Course Transcript</title><link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css"><style>:root {
    --title-text: #243038;
    --toc-link: #0073C4;
    --section-title-text: #243038;
    --section-title-border: #bababa;
    --grid-caption-text: #164794;
    --grid-border: #c0c0c0;
    --grid-hdr-text: #973131;
    --grid-hdr-background: #f7f7f7;
    --missing-data: #767676;
    --text-color: #343434;
    --lightbox-border: #a0a0a0;

    --bold-font-weight: 700;

    font-family: Lato;
}

.report {
    margin: 24px;
}

.container {
    position: relative;
}

#lb-curtain {
    background-color: white;
    opacity: 1.0;
}

#lb-overlay {
    position: absolute;
    top: 40px;
    left: 20px;
    right: 20px;
    background-color: white;
    border: solid 1px var(--lightbox-border);
    visibility: hidden;
}

.lb-header, .lb-footer {
    height: 40px;
    line-height: 40px;
}

.lb-header {
    display: flex;
    justify-content: flex-end;
    padding-right: 20px;
}

#lb-image-container {
    margin: 0 40px;
}

#lb-image {
    width: 100%;
}

.report_title {
    font-size: 22px;
    font-weight: var(--bold-font-weight);
    color: var(--title-text);
}

.toc_link {
    font-size: 14px;
    color: var(--toc-link);
    margin-top: 6px;
    margin-bottom: 0;
}

.section {
    margin-top: 40px;
    margin-left: 16px;
}

.section.inner {
    margin-top: 20px;
}

.section.inline {
    margin-top: 20px;
    margin-left: 0;
}

.section_title {
    font-size: 18px;
    font-weight: var(--bold-font-weight);
    width: 100%;
    color: var(--section-title-text);
}

h2.section_title {
    border-bottom-color: var(--section-title-border);
    border-bottom-style: solid;
    border-bottom-width: thin;
}

h3.section_title {
    margin: 8px 0;
}

h3.list_title {
    margin: 8px 0;
    font-size: 14px;
    color: var(--title-text);
}

.section_text {
    font-size: 14px;
    color: var(--text-color);
    margin: 12px 0;
    width: 90%;
}

.section_link {
    font-size: 14px;
    margin: 12px 0;
    width: 90%;
}

.grid {
    border-collapse: collapse;
}
.grid_caption {
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    color: var(--grid-caption-text);
    margin: 12px 0;
    text-align: left;
    white-space: nowrap;
}
.grid_hdr_row {

}
.grid_col {
    font-size: 13px;
    color: var(--text-color);
    border-collapse: collapse;
    padding: 2px;
    text-align: left;
    vertical-align: top;
}
.grid_col_hdr, .grid_row_hdr {
    font-size: 12px;
    font-weight: var(--bold-font-weight);
    white-space: nowrap;
}
.grid_row_hdr {

}

.empty_grid {
    border-collapse: collapse;
    border-color: var(--grid-border);
    border-style: solid;
    border-width: 2px;
    padding: 4px;
    text-align: center;
}

.htmlbox {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    padding: 8px;
}

.list {
    font-size: 14px;
    font-style: italic;
}

.missing_data {
    color: var(--missing-data);
    font-size: 14px;
    font-weight: var(--bold-font-weight);
    font-style: italic;
}

.copyright-container {
    margin-top: 24px;
    text-align: center;
}
.copyright-text {
    color: var(--text-color);
    font-size: 12px;
}

/* Transcript Questions CSS */

.question {
    border: solid 1px var(--grid-border);
    box-shadow: 1px 1px 4px var(--grid-border);
    display: flex;
    flex-direction: column;
    padding: 8px;
}

.question_content {
    display: flex;
    justify-content: space-between;
}

.question_details {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.question_images {
    display: flex;
    flex-direction: column;
    margin-left: 16px;
}

.question_image {
    margin-bottom: 8px;
}

.question_title {
    font-weight: var(--bold-font-weight);
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
    padding-bottom: 8px;
    margin-bottom: 8px;
}

.question_label, .question_stem {
    font-weight: var(--bold-font-weight);
    margin-top: 8px;
    margin-bottom: 8px;
}

.question_data_row {
    display: flex;
}

.question_data_col1 {
    padding: 8px;
    white-space: nowrap;
}

.question_data_col2 {
    padding: 8px;
    display: flex;
    flex-direction: column;
}

.question_answer_key {
    margin-top: 8px;
    border-bottom-color: var(--grid-border);
    border-bottom-style: solid;
    border-bottom-width: 1px;
}

.feedback {
    font-style: italic;
}
</style></head><body class="report"><div class="container"><div class="content" id="lb-curtain"><h1 class="report_title">Java Certified Foundations Associate: Java Operators</h1><div class="section_text">Being able to perform mathematical, conditional, and relational operations is a key feature of the Java programming language. In this course, you&#39;ll learn about the available mathematical, conditional, relational, bitwise, and unary operations.

First, you&#39;ll explore the arithmetic and assignment operators available in Java and how to use them. Then, you&#39;ll move on to learn about Java unary, equality, and relational operators. Next, you&#39;ll examine Java conditional and bitwise operators. Finally, you&#39;ll learn about the precedence of Java mathematical, conditional, relational, unary, and parentheses operators.

This course is one of a collection of courses that prepares learners for Oracle&#39;s 1Z0-811: Java Certified Foundations Associate certification.

</div><div class="section"><h2 class="section_title">Table of Contents</h2><div class="toc"><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_0">1. Video: Course Overview ( it_sdjcfa_08_enus_01)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_1">2. Video: Java Arithmetic and Assignment Operators ( it_sdjcfa_08_enus_02)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_2">3. Video: Programming Java Arithmetic Operators ( it_sdjcfa_08_enus_03)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_3">4. Video: Java Unary Operators ( it_sdjcfa_08_enus_04)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_4">5. Video: Programming Java Unary Operators ( it_sdjcfa_08_enus_05)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_5">6. Video: Java Equality and Relational Operators ( it_sdjcfa_08_enus_06)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_6">7. Video: Programming Java Relational Operators ( it_sdjcfa_08_enus_07)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_7">8. Video: Java Logical Operators ( it_sdjcfa_08_enus_08)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_8">9. Video: Programming Java Logical Operators ( it_sdjcfa_08_enus_09)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_9">10. Video: Java Bitwise Operators ( it_sdjcfa_08_enus_10)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_10">11. Video: Programming Java Bitwise Operators ( it_sdjcfa_08_enus_11)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_11">12. Video: Java Operator Precedence ( it_sdjcfa_08_enus_12)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_12">13. Video: Programming Java Operator Precedence ( it_sdjcfa_08_enus_13)</a></p><p class="toc_link">&nbsp;&nbsp;&nbsp;&nbsp;<a href="#section_13">14. Video: Course Summary ( it_sdjcfa_08_enus_14)</a></p></div></div><div class="section"><a name="section_0" /><h2 class="section_title">1. Video: Course Overview ( it_sdjcfa_08_enus_01)</h2><img src="https://cdn2.percipio.com/public/b/235b8b05-ad50-40dc-9a4a-9172e4606022/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/235b8b05-ad50-40dc-9a4a-9172e4606022/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">discover the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Overview</em> [Video description ends]
<p>Hello and welcome to the course. My name is Peter Adamson, and I&#39;m going to be the instructor for this Java operators course. A little bit about myself.<br /><br />[Video description begins] <em>Your host for this session is Peter Adamson. He is a Security Software Developer.</em> [Video description ends] <br /><br />I have a background in computer science as well as engineering and I&#39;ve spent most of my time working as a security software developer. A lot of my career&#39;s focus has been on cybersecurity in conjunction with software development.</p>
<p>In this course, you will learn about the available mathematical, conditional, relational, bitwise and unary operators. First, you will learn about the arithmetic and assignment operators available in Java. Next, you will learn about Java unary, equality and relational operators. Next you will learn about Java conditional and bitwise operators. Finally, you will learn about the precedence of Java mathematical, conditional, relational, unary and parentheses operators.</p></div></div></div><div class="section"><a name="section_1" /><h2 class="section_title">2. Video: Java Arithmetic and Assignment Operators ( it_sdjcfa_08_enus_02)</h2><img src="https://cdn2.percipio.com/public/b/cd0710bf-c7a6-46e6-b83b-0836d04ab5a8/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/cd0710bf-c7a6-46e6-b83b-0836d04ab5a8/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the various Java arithmetic and assignment operators</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Arithmetic and Assignment Operators. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Operators in Java allow us to manipulate and control our data in various ways in order to accomplish our goals when we&#39;re doing our code. The first type of operator that we&#39;re going to talk about in Java is the arithmetic operator. And these operators allow us to perform mathematical functions on our data. So for example, when we&#39;re dealing with primitive data types like int&#39;s, or Long&#39;s or double&#39;s, then oftentimes we&#39;ll want to do some sort of arithmetic operation on them. So these are things like addition, subtraction, multiplication, division and modulo. And all of these operators are available to us. And we can see them in the bubble.</p>
<p>The percent sign represents modulo, the minus sign represents subtraction, the plus sign represents addition. The forward slash represents division and the asterisk represents multiplication. We also have assignment operators and this allows us to store data into memory by assigning values to variables. So one assignment operator which we see in the bubble on the right is the equal sign. And the example shown is a &#61; 3 and this will store the value three into a.</p>
<p>So that&#39;s what we use when we&#39;re using assignment operators. Something that often goes hand in hand with operators and our use of operators in Java is type casting. Type casting is when we convert a piece of data from one type to another. So in Java, everything has a type. For example, when we define something as an int, that means an integer and it means that it takes up a certain amount of space in memory.</p>
<p>Similarly, when we define something as a float, then that&#39;s defined as a different type than an int. And it consumes more space in memory than an integer does. We have two different types of type casting. The first is implicit conversion. And this is something that Java will just do behind the scenes that you don&#39;t really have any control over and you don&#39;t need to interact with.</p>
<p>And this comes up when we&#39;re dealing with arithmetic operations that have a mismatch of type. So, for example, if we&#39;re trying to perform an arithmetic operation on a float and an integer, Java will implicitly convert the int into a float because the float is a much larger number.</p>
<p>So the int is guaranteed to be able to fit into the memory space of a float. So Java will make sure that they both convert into floats and then perform the operation on two floats rather than a float an an int. Alternatively, we have explicit conversion and this is done by putting a type in parenthesis before the name of the variable that you&#39;re trying to convert.</p>
<p>So in the example shown in a bubble, we can explicitly convert a variable to an int type by putting the word int between parenthesis and placing that in front of the name of our variable. And then Java will convert it for us in that case.</p>
<p>So as we mentioned before, addition is by the plus sign, subtraction is by the minus sign, multiplication is by the asterisk and division is done by the forward slash. All of these operators work by having an operand on either side of them and then giving a result. So for example, you could have int a&#61;5&#43;5, and then a would be equal to 10. And it&#39;s the same for subtraction, multiplication, and division.</p>
<p>You put an operand on either side with the operator between the two and Java will carry out the operation as you specify. The modulo or modulus remainder operator is something that might be a little bit less familiar. It doesn&#39;t come up a lot in daily life but it does come up a lot in coding. What this does is it gives the remainder after a division operation is carried out.</p>
<p>So if you were to divide 7 divided by 3, that would be a modulo of 1 because 3 goes into 7 two times, and has a remainder of 1 left over. And, there are quite a few use cases for the modular remainder operator. One of the major ones is in cryptography.</p>
<p>If you get into cryptography at all, you&#39;ll end up using this modular operator a lot. Two other arithmetic operators that we have are almost like shortcuts and these are the increment and detriment operators. So &#43;&#43; and --. And what these will do is they will either add 1 or subtract 1 from a value respectively.</p>
<p>So let&#39;s go back to our integer a, which is currently equal to 10. If I were to say a &#43;&#43;, then that would increment my a value by 1 and then a would be equal to 11. And then if I were to say, a- -, that would decrement my a value by 1, bringing it back to 10. So that&#39;s how the increment and decrement operators work. And it&#39;s important to note a difference here between the increment and decrement operators and the other arithmetic operators I was talking about before.</p>
<p>So with addition, subtraction, multiplication, division and modulus, we have to have two operands on either side of the operator. With the increment and decrement, we only have a single operand. Notice I only used a&#43;&#43; and a--. We didn&#39;t have to have something on either side of the &#43;&#43; or the --. So increment and decrement are single operand operators. Now let&#39;s look a little closer at our assignment operators and how we can potentially combine them with our arithmetic operators. So the first assignment operator is the one that we&#39;ve already touched on. This is your basic simple assignment, the a &#61; 3, and we do that with a single equal sign.</p>
<p>That will assign the value on the right side of the operator to the storage location on the left side of the operator, in this case the variable a. But we can combine our assignment operators with arithmetic operators.</p>
<p>So we could have a case where we do first and add and then an assign. So what we could do is have something like a &#43;&#61; 3. So to see how that works, let&#39;s give a an initial value. Let&#39;s assume that a is equal to 5. If we then have a &#43;&#61; 3, that&#39;s equivalent to a &#61; a &#43; 3. So a will now be equal to 8 after we do that add and assignment operator. And we do that by having the plus sign followed by equal sign. Similarly, we can have a subtract and assignment operator, which is done with a minus and an equal sign.</p>
<p>So if we had a once again equaling 5 and we did a -&#61; 3. That&#39;s equivalent to saying a&#61;a-3 and after the operation a will be equal to 2. We can do the same thing with multiplication, we can do multiply and assignment with asterisk equals. So saying b*&#61;5 is equivalent to saying b equals b times 5. Divide and assignment with a forward slash followed by an equal sign. So b/&#61;5 is equivalent to saying b equals b divided by 5. And modulus and assignment with a percent sign, followed by an equal sign. So b%&#61;5 is the same as saying b equals b modulo 5.</p></div></div></div><div class="section"><a name="section_2" /><h2 class="section_title">3. Video: Programming Java Arithmetic Operators ( it_sdjcfa_08_enus_03)</h2><img src="https://cdn2.percipio.com/public/b/f95df785-849c-4ad2-80e8-8bb1e10d1b97/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/f95df785-849c-4ad2-80e8-8bb1e10d1b97/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the various Java arithmetic and assignment operators</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Arithmetic Operators. Your host for this session is Peter Adamson.</em> [Video description ends] <br /><br />[Video description begins] <em>The IntelliJ IDEA interface editor pane displays on the screen.</em> [Video description ends]
<p>In this video, we&#39;re going to demonstrate the use of various arithmetic and assignment operators in Java. So to get started, we&#39;re going to create ourselves a Java class to make use of these operators within. <br /><br />[Video description begins] <em>As he clicks the src underneath the &#34;Project&#34; on the left pane a drop down menu appears. He selects the &#34;New&#34; and then further selects the &#34;Java Class&#34;.</em> [Video description ends] <br /><br />This would be called Operators.java. <br /><br />[Video description begins] <em>A pop up box titled, New Java Class appears on the screen.</em> [Video description ends]<br /><br />[Video description begins] <em>The Operators.java file is open in the IntelliJ IDEA interface editor pane.</em> [Video description ends] <br /><br />Now we have our class, we&#39;ll make a main method to demonstrate some of these operators within. <br /><br />[Video description begins] <em>Line 1 reads as: public class Operators {.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 2 reads as: public static void main(String[] args) {.</em> [Video description ends] <br /><br />And now we can look at the operators. In Java, we have the following arithmetic operators. We have the plus sign for addition, the minus sign for subtraction and an asterisk for multiplication, a forward slash for division and a percent symbol for modulo. We also have increment and decrement operators but we&#39;ll talk about those in a future video.</p>
<p>So let&#39;s take a look at each of these operators in turn and see how they work. If I want to add two numbers together, I can have int a equals 5 &#43; 7, and in this case, a will be equal to 12. <br /><br />[Video description begins] <em>Line 4 reads as: int a &#61; 5 &#43; 7; // a &#61;&#61; 12.</em> [Video description ends]<br /><br />I don&#39;t have to use straight values. I can also use variables within my operators. So I could have int b &#61; a &#43; 2 and then b will be equal to 14. And I can also just use variables.</p>
<p>I can have int c &#61; a &#43; b and then c will be equal to 26. So that&#39;s how we can use the addition operator. The rules of using values or variables are the same for every operator, we can use all values like I did with my a with 5&#43;7. We can use a mixed like I did with b with a&#43;2 or we can use all variables like I did with c, a&#43;b. And that&#39;s true for the subtraction, multiplication, division, and modulo. So, if we wanted to do subtraction, I could have int d &#61; 8 - 4 and d will be equal to 4. I could have int e &#61; 12- d. And then in that case, e will be equal to 8. And then I could have int f &#61; e - d. And in that case f will be equal to 4. So now we could see some of these in action. So I&#39;m going to make a print statement for each of these just to print out the variable values so we can see it in the console. <br /><br />[Video description begins] <em>Line 12 reads as: System.out.println(a);.</em> [Video description ends]</p>
<p>And then I will compile and run this. <br /><br />[Video description begins] <em>A Terminal window appears below the editor pane, showing various commands. He enters the Operators.java</em> [Video description ends] <br /><br />And in order the values are as we expect, a is 12, b is 14, c is 26, d is 4, e is 8, and f is 4. So that&#39;s how we can use addition and subtraction. Now let&#39;s look at multiplication and division. They follow the same rules. So we can have int a &#61; 5 times 5. In this case, a will be equal to 25. We could have int b &#61; a times 2 and b will be equal to 50. And we could have int c &#61; a times b and c will be equal to 1250.</p>
<p>If we wanted to divide two numbers, I could have int d &#61; 10 divided by 5. In this case, d will be equal to 2. I could use int e &#61; 6 divided by d. And in this case, e will be equal to 3. And then I can have int f &#61; e divided by d. Now we run into something interesting. What is f going to be equal to? Because e is equal to 3 and d is equal to 2, 2 doesn&#39;t divide into 3 evenly, it leaves a remainder. Now what Java will do, because we&#39;re dealing with integer types, it will just leave off the remainder. It just ignores it as if it isn&#39;t there. So 2 divides into 3 one time evenly and then Java doesn&#39;t care about the rest. So in this case, f is actually going to be equal to 1. And we can see that in action by printing this to the command line. And here in the console, I&#39;ve now run it. So we can see that in order a is equal to 25, b is equal to 50, c is equal to 1,250, d is equal to 2, e is equal to 3, and f is equal to 1, like we suspected that it would be. Now what if I wanted to get the full value of f, not just the value with the remainder trimmed. Well, in that case, I could use different value types, such as double to store the result into f and then I need to cast one of my integers to also be a double.</p>
<p>And what Java will do now is convert implicitly my equation to have all the values to be the same as the largest value type, which in this case is a double. And now, f will not be equal to 1. We can actually see by compiling and running, what f will be equal to. And now if we look at the bottom of our list, f is equal to 1.5. We&#39;ve done the full division here, because we&#39;ve used a value type that matches. <br /><br />[Video description begins] <em>Line 10 reads as: double f &#61; (double) e/d; // f &#61;&#61;1.5.</em> [Video description ends] <br /><br />This same concept applies with all of the other operators as well. But it most frequently becomes a problem with division because that&#39;s most of the time where you&#39;re going to be dealing with these mixed types and looking for remainders.</p>
<p>The last arithmetic operator that we&#39;re going to look at his modulo, which is the percent sign. What modulo does is it gives you the remainder of a division. So we can display that with int a &#61; 6 modulo 2. And in this case, a is going to be equal to 0 because 2 divides into 6 evenly and leaves no remainder. We can also have int b &#61; 15 modulo 4. And in this case, b is going to be equal to 3 because 4 goes into 15, 3 times evenly to get the value of 12 and then leaves a remainder of 3 to get to 15.</p>
<p>And to see that on the command line, let&#39;s do two more print statements <br /><br />[Video description begins] <em>Line 7 reads as System.out.println(a);.</em> [Video description ends] <br /><br />and the values are as we expect, a is equal to 0 and b is equal to 3. Now we&#39;ve seen the arithmetic operators in Java, let&#39;s look at some assignment operators in Java.</p>
<p>I&#39;m going to show most of the assignment operators but I am going to be leaving a couple out because they&#39;re a little more advanced and a little more niche and they deal with bitwise operations. But the assignment operators that I&#39;m going to show are the majority of them and the most common ones that you&#39;ll run into. The first operator you might already be very familiar with, and that is the equal sign. And the equal sign will assign the value on the right side of it to the variable on the left side. So in this case, x will now have the value of 5. <br /><br />[Video description begins] <em>Line 3 reads as: int x &#61; 5; // x &#61;&#61; 5.</em> [Video description ends]</p>
<p>And we&#39;ll set up a print system so that we can see these all at the end of the demonstration. So print out the value of x at this point in time. <br /><br />[Video description begins] <em>Line 4 reads as System.out.println(x);.</em> [Video description ends] <br /><br />The next assignment operator is the &#43;&#61; sign. And what this will tell Java is to add 3 to the value of x. This is the same as saying x &#61; x &#43; 3. And in this case, x is going now to be equal to 8.<br /><br />[Video description begins] <em>Line 5 reads as: x &#43;&#61; 3; // x &#61; x &#43;3, x &#61;&#61; 8.</em> [Video description ends]<br /><br />So we&#39;ll copy this line and we&#39;ll paste it again to see the value of x at that point in time. <br /><br />[Video description begins] <em>He copy the code on line 4 and past it on the line 6.</em> [Video description ends]</p>
<p>On the opposite side of that, we have the -&#61;. So I could write x -&#61;1. And this is the same as saying x &#61; x- 1 and x will now be equal to 7. <br /><br />[Video description begins] <em>Line 7 reads as: x -&#61;; // x &#61; x-1, x &#61;&#61; 7.</em> [Video description ends] <br /><br />We have x *&#61; 2. And this is equivalent to saying x &#61; x times 2 and x will now be equal to 14. <br /><br />[Video description begins] <em>Line 9 reads as: x *&#61; 2; // x &#61; x*2, x &#61;&#61; 14.</em> [Video description ends]<br /><br />We have x /&#61;2. And this is the same as saying x &#61; x/2. And x will once again be equal to 7.<br /><br />[Video description begins] <em>Line 11 reads as: x /&#61; 2; // x &#61;x/2, x &#61;&#61;7.</em> [Video description ends] <br /><br />And then finally we have x% &#61; 4 And this is the same as saying x &#61; x modulo 4 and x will be equal to 3. <br /><br />[Video description begins] <em>Line 13 reads as: x %&#61; 4; // x &#61; x%4, x &#61;&#61; 3.</em> [Video description ends]</p>
<p>Now we can compile this once again and run it again. And we can see that in the console at the bottom of my screen, the values are as expect, x starts out with 5 and then x &#43;&#61; 3 to become 8, x -&#61; 1 to become 7, x *&#61; 2 to become 14, x /&#61; 2 to become 7, and then x %&#61; 4 to become 3. So these are the arithmetic and assignment operators and how they work in Java.</p></div></div></div><div class="section"><a name="section_3" /><h2 class="section_title">4. Video: Java Unary Operators ( it_sdjcfa_08_enus_04)</h2><img src="https://cdn2.percipio.com/public/b/6662d745-228f-4310-924a-e2fc3e316846/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/6662d745-228f-4310-924a-e2fc3e316846/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the various Java unary operators</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Unary Operators. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Unary operators in Java are operators that only take a single operand. An example of these is the prefix and postfix operators which are the increment and decrement operators &#43;&#43; and --. They only take a single operand. We also have certain arithmetic operators that we&#39;ll look at that only take a single operand. And then we have bitwise and logical operators that also only work on a single operand. So let&#39;s look deeper into each of these examples and see how they work. The first unary operators that we&#39;ll talk about are the prefix and postfix operators. So these are both dealing with the increment and decrement operator. But the difference comes in their placement either before or after the variable that you&#39;re trying to increment or decrement. So in a prefix operator, we put our increment or decrement operator before the variable, we have it as &#43;&#43;a or --a if a is our variable. And the postfix operator, we put our increment and decrement after our variable. So if a is our variable once again we&#39;d have a&#43;&#43; and a-- for postfix. Both of these operations end up doing the same thing.</p>
<p>They&#39;ll either increment or decrement your variable by one, but the difference is in how they do it. With a prefix, the variable is first incremented or decremented and then the result is stored. So what that means is let&#39;s say a is equal to 10 and you had b equals &#43;&#43;a. You&#39;re using the prefix increment. Then a will first be incremented to 11 and then stored into b as 11. Now if you&#39;re using the postfix increment, a&#43;&#43; and you had that same statement, b equals a&#43;&#43;. The difference with postfix is that first the value of your variable is stored, and then the operation is carried out. So in the case of b equals a&#43;&#43; with a equaling 10. First off, 10 would be assigned to b and then the increment would happen after that.</p>
<p>So you would have b equal to 10 and a equal to 11. So the difference comes in when the increment or decrement operation happens with prefix and postfix. The second type of unary operators that we have in Java are arithmetic operators. And we have a little bit of overlap here because increment and decrement also fall into this category. And they are signified with the &#43;&#43; and -- symbols as we&#39;ve seen. Other arithmetic operators are unary plus and unary minus signs. And what these do is they indicate the sign of say an integer that you&#39;re working with. If you&#39;re working with a positive value and you want to explicitly define it as a positive value, you could have int i equals &#43;3.</p>
<p>And then that tells Java, this is a positive 3. You could use the unary minus sign to tell Java you&#39;re working with a negative number. You could have int i equals -3, and then that would tell Java this is a -3. The default is unary plus, so if you don&#39;t define explicitly a plus or a minus, Java will default to positive numbers. So if you just have int i equals 3, Java will assume you meant positive 3. And these unary plus and unary minus operators aren&#39;t limited to just ints. They can be used on any value that positive or negative would have some sort of significance. So ints, floats, doubles, longs, these are all examples of things you could use the unary plus and minus sign on.</p>
<p>Finally we have our bitwise and logical operators. With bitwise and logical operators, often we&#39;ll have two operators that have the same last name. So in this example on the screen we have two operators that are both complements. We have one that is a logical complement and one that is a bitwise complement. And you&#39;ll see that pattern repeated for many of the other bitwise and logical operators.</p>
<p>And generally what that means is the logical operator is working with Boolean values, things like true and false and comparisons. Whereas the bitwise operator is working with binary values, 1s and 0s. So looking at the operators on our screen, we have the logical complement, which is represented by an exclamation point. And what this will do is reverse the value of a Boolean value. So if you have, say, a Boolean that&#39;s equal to true, and you put this logical complement symbol in front of it, the exclamation point. Then that&#39;s going to flip that value to be false.</p>
<p>Similarly if you put the exclamation point or the logical complement in front of a false value, it will flip it to be true. Now the bitwise complement which is signified by the tilde works on binary numbers. And what it will do is flip every bit in a binary number. So on the bubble in our screen, we have the binary number 10101111. If you were to apply the bitwise complement to that, the tilde symbol, that number would become 01010000. And that&#39;s how the bitwise complement would work. Here is a code snippet which is showing you an example of the use of a unary operator.</p>
<p>So on the top we have our code snippet and in the bottom underneath where it says java -Xmx128M -Xms16M UnaryExample. We see an example of this program being run and what the system would actually output. So our class is called UnaryExample.</p>
<p>And we can see on line 5 we have an int x being assigned a value of 10 and then we have two print statements beneath it. And in this case, the first print statement is using the post increment operation. It&#39;s saying print out r&#61;: and then followed by the value x&#43;&#43;. So x is currently equal to 10 and the postfix operation will only increment that value after whatever other operation is needed with x.</p>
<p>So in this case, system.out.println on line 6 is going to print out r&#61;: space then it&#39;s going to print out the value of x as it currently is, which is 10, and then it&#39;s going to perform the postfix increment after that. So that&#39;s why we see down in the bottom of the console our first r equals colon line prints out a value of x equal to 10.</p>
<p>Then on line 7, we once again do another print statement, but this time we&#39;re just printing out the value of x as it is. And we can see that now x is equal to 11, because after that first print statement, x has been post incremented and its value has become 11. On line 9, we see another variable, int y, assigned a value of 10. And then we have two more print statements, but this time we&#39;re going to be using the preincrement operation.</p>
<p>So the first print statement just prints out the value of y as it is. And we can see on the bottom console, it prints out y is equal to 10. Then we do another print statement with &#43;&#43;y on line 11. And in this case, the increment operations happens before the actual action of doing whatever it is that we&#39;re doing with y. So, y is first incremented by 1 to 11 and then printed out. So that&#39;s why we see at the very bottom of our screen y equals 11.</p></div></div></div><div class="section"><a name="section_4" /><h2 class="section_title">5. Video: Programming Java Unary Operators ( it_sdjcfa_08_enus_05)</h2><img src="https://cdn2.percipio.com/public/b/cac73728-fa3a-4fa7-ba13-a2ac6661fa9c/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/cac73728-fa3a-4fa7-ba13-a2ac6661fa9c/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the various Java unary operators</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Unary Operators. Your host for this session is Peter Adamson.</em> [Video description ends] <br /><br />[Video description begins] <em>The IntelliJ IDEA interface editor pane displays on the screen.</em> [Video description ends]
<p>In this video, we&#39;re going to demonstrate the use of the increment and decrement operators in Java. So to get started let&#39;s create a class for ourselves to work in.<br /><br />[Video description begins] <em>As he clicks the src underneath the &#34;Project&#34; on the left pane a drop down menu appears. He selects the &#34;New&#34; and then further selects the &#34;Java Class&#34;.</em> [Video description ends] <br /><br />We&#39;ll create a new class called Increment.java. <br /><br />[Video description begins] <em>A pop up box titled, New Java Class appears on the screen.</em> [Video description ends] <br /><br />[Video description begins] <em>The Increment.java file is open in the IntelliJ IDEA interface editor pane.</em> [Video description ends] <br /><br />And we&#39;ll create a second class called Decrement.java. These are going to be two completely independent classes just to show off one to increment and one to decrement. <br /><br />[Video description begins] <em>Line 1 reads as: public class Increment {.</em> [Video description ends] So we&#39;ll have a main method within our increment class.<br /><br />[Video description begins] <em>Line 2 reads as: public static void main(String[] args) {.</em> [Video description ends] <br /><br />And we&#39;ll have a main method within our decrement class. <br /><br />[Video description begins] <em>He switches to the Decrement.java file. Line 1 reads as: public class Decrement {. Line 2 reads as: public static void main(String[] args) {.</em> [Video description ends] <br /><br />So in Java the increment operator is signified by a &#43;&#43;. And the &#43;&#43; can either come before or after a variable. So we could have it as something like &#43;&#43;i or i&#43;&#43;. Both are valid, and in both cases, this is the same as saying i &#61; i &#43; 1. But there is a slight difference in how that addition is done between the two which we&#39;ll talk about shortly. So let&#39;s see this in action. Let&#39;s start out with int i &#61; 3. <br /><br />[Video description begins] <em>Line 4 reads as: int i &#61;3;.</em> [Video description ends]</p>
<p>And then we want to increment the variable i. So we&#39;re going to say &#43;&#43;i. We&#39;ll assign this to a variable into a &#61; &#43;&#43;i. Now, our i variable is going to be equal to 4. And our a variable is going to be equal to 4 because we have incremented the value of i and we&#39;ve assigned that into a. So we can see this in action by throwing in a few print statements. <br /><br />[Video description begins] <em>Line 5 reads as: int a &#61; &#43;&#43; i; // i &#61; 4, a &#61; 4.</em> [Video description ends]<br /><br />[Video description begins] <em>Line 5 reads as System.out.println(i);.</em> [Video description ends]<br /><br />Now our program will print out the initial value of i and then it will print out the value of a and i after the increment has happened.</p>
<p>So we&#39;ll compile that and run it.<br /><br />[Video description begins] <em>A Terminal window appears below the editor pane, showing various commands. He enters the Increment.java.</em> [Video description ends] <br /><br />So in our console output we can see our initial value of 3 for i and then followed by the value of 4 for a and 4 for i. Now let&#39;s revisit what I mentioned earlier, which is the &#43;&#43;i versus i&#43;&#43;. The difference between the two is in post-increment and pre-increment. &#43;&#43;i which is the one that we&#39;ve demonstrated so far is pre-increment.</p>
<p>And what that means is this operation, this i &#61; i &#43; 1 will be carried out before the assignment to a variable. So if we look at line 6 in this case, I&#39;ve got &#43;&#43;i, and I&#39;m assigning that to a, so i is incremented to 4 and then assigned to a. If i were to use post-increment int b &#61; i&#43;&#43;.</p>
<p>Now, what happens is that this i &#61; i &#43; 1 operation is carried out after the assignment to the b variables already happened. So, the order of operations here is that i with a value of 4 is now going to be assigned to b and then i will be incremented to 5. So in this case, i now equals 5, but b &#61; 4. <br /><br />[Video description begins] <em>Line 7 reads as: int b &#61; i&#43;&#43;; // i &#61; 5, b &#61; 4.</em> [Video description ends] <br /><br />So we&#39;ll refactor our print statements to print out the value of b and i now and that will recompile our program and rerun it.</p>
<p>And we see in our console output at the bottom of my screen, the initial value of i is 3, and then we&#39;ve run the operation a &#61; &#43;&#43;i. We haven&#39;t printed anything out there, but we still know that at this point i &#61; 4 and a &#61; 4. And then we&#39;ve done the post-increment where we have assigned the value of i to b, which would be 4, and printed that out in the console. And then we&#39;ve incremented i to become 5 and then we&#39;ve printed out the value of i as 5.</p>
<p>So that&#39;s the difference between the pre-increment and the post-increment. Now let&#39;s look at the decrement operator. The decrement operator is signified with a --, so just like the increment operator, we have a pre and post-decrement. So we have --i or i--. And in both cases, they&#39;re equivalent to i &#61; i - 1. But once, again with the --i, that&#39;s a pre-decrement. So the decrement happens first, the i &#61; i - 1 operation, and then the value is assigned to a variable, whereas the i-- is a post-decrement.</p>
<p>So the initial value of i is assigned to a variable, and then the i &#61; i - 1 operations carried out. So let&#39;s see this in action. We&#39;ll do i equals, we&#39;ll start out with a variable int i &#61; 5.</p>
<p>And then we will apply a pre-decrement to i <br /><br />[Video description begins] <em>Line 4 reads as: int i &#61;5;.</em> [Video description ends]<br /><br />and assign that to a value of a. So we&#39;ll write int a &#61; --i, and now we have a &#61; 4 and i also equals 4.<br /><br />[Video description begins] <em>Line 5 reads as: int a &#61; --i; // a &#61; 4, i&#61; 4.</em> [Video description ends] <br /><br />Then we&#39;ll do a post-decrement with int b &#61; i--. And now we have b &#61; 4, but i &#61; 3.</p>
<p>And we can see that out by printing it to the command line <br /><br />[Video description begins] <em>Line 6 reads as: int b &#61; i--; // b &#61; 4, i &#61; 3.</em> [Video description ends] <br /><br />and we will compile and run our decrement class.<br /><br />[Video description begins] <em>Line 5 reads as System.out.println(i);.</em> [Video description ends] <br /><br />[Video description begins] <em>A Terminal window appears below the editor pane, showing various commands. He enters the Decrement.java.</em> [Video description ends] <br /><br />And so in order of printout in our console, our first print statement prints the value of i, which starts out as 5.</p>
<p>We then print out the final value of i, which is 3, as we would expect, because that&#39;s the value of i after the decrements have been applied completely. And then we have the value of a, which is 4 and then the value of b which is also 4. So the operations have been carried out exactly as we expect. And that&#39;s how the increment and decrement operators work in Java.</p></div></div></div><div class="section"><a name="section_5" /><h2 class="section_title">6. Video: Java Equality and Relational Operators ( it_sdjcfa_08_enus_06)</h2><img src="https://cdn2.percipio.com/public/b/3ba87da5-ba31-47db-8992-c4cb6225e450/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/3ba87da5-ba31-47db-8992-c4cb6225e450/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the various Java equality and relational operators</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Equality and Relational Operators. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Equality and relational operators are both used to compare two operands together and to check their relationship to each other. Most commonly, you&#39;ll see these in loop statements, so things like if else, while, do while. This is where equality and relational operators are most commonly used. And that&#39;s because you often want to do something while something is true or if this check then do this. So equality operators check two different operands together to see if they&#39;re equal to each other and they&#39;ll return a boolean value. If two values are equal, it will return true. And if two values are not equal, they&#39;ll return false. Relational operators on the other hand check various relationships between two operands. Things like, is one larger than the other, or is one smaller than the other, or is one larger than or equal to the other one, things like that. Let&#39;s look at equality operators first. Equality operators check two values to see whether they&#39;re equal to each other or not equal to each other. In the case of primitive values like integers, it&#39;s just going to compare the values directly.</p>
<p>If we&#39;re comparing things like objects, then it&#39;s going to look into the memory and see if we&#39;re looking at the same object. So the first one is our equal to operator and this is represented by a double equals sign. So an equal sign followed by another equal sign. So if we were to compare two integers, we could do that with something like five equals equals six, and that would return false because five does not equal six. Or we could do five equals equals five and that would return true because five does equal five.</p>
<p>And we can do that with variables too. If a was equal to five and b was equal to six, we could do a equal equal b. We could also do a mixture, we could have a equal equal five. So we can play around with the operators like that. We also have not equal to which is represented with an exclamation point followed by an equal sign, and this is the opposite of the equal to operator. This will check if something is not equal to another operand. And if it is not equal to it, then it will return true and if it is equal to it, it will return false.</p>
<p>So going back to our first example, if we did five not equal to six, this would return true. And if we did five not equal to five, it will return false. Now moving on to relational operators, these are used to compare the relationship of two operators. How does one compared to the other in terms of, say its size. So to that end, we have our first relational operator which is the greater than operator represented by a right facing chevron.</p>
<p>And what this will do is we&#39;ll check the operand on the left of the chevron to see if it is greater than the value on the right of the chevron. If it is, then it will return true and otherwise it will return false. So if we were to check five is greater than six, it would return false because five is not greater than six. If we were to check six greater than six, it would still return false because six is not greater than six. But if we checked seven greater than six, it would return true.</p>
<p>And once again, we can mix and match variables and numbers. We could have, a greater than six, a greater than b, we can play around with our variables and numbers that way. The next relational operator is the less than which is represented by a left facing chevron. And this will check the value on the left side of the chevron to see if it is less than the value on the right side of the chevron. So once again, if we did five less than six, that would return true because five is less than six.</p>
<p>If we checked six less than six, that would return false, because six is not less than six. And if we checked seven less than six, that would also return false. The next relational operator is the greater than or equal to operator, and this is represented by a right facing chevron followed by equal sign. So this is going to compare the operand on the left to see if it is greater than or equal to the operand on the right.</p>
<p>So once again, with our examples, if we did five greater than equal to six, that would be false because five is not greater than or equal to six. If we did six greater than or equal to six, that would be true because six is greater than or equal to six. And then if we had seven greater than or equal to six, we would once again return true.</p>
<p>And then we have our less than or equal to operator, which is represented by the left facing chevron followed by an equal sign. And this is going to check the operand on the left side of the operator to see if it is less than or equal to the operand on the right side of the operator. With five less than or equal to six, we would return true.</p>
<p>With six less than or equal to six, we would also return true. And with seven less than or equal to six, we would return false. And here is a code snippet that shows off all of the equality relational operators that we&#39;ve been talking about. So in the top half of the picture, we have our code. And in the bottom half of the picture, we have the console output, which is what the console would show when we run this code.</p>
<p>Essentially, this code is a bunch of print statements showing the result of our operators. So our class is called OperatorExample as defined on line 1. And then on line three, we have two integers defined, we have x and y and both of them are equal to 3. So starting on line 5, and going to line 11, we have a series of print statements.</p>
<p>The first print statement just prints out the value of x and y. So it says x is less than the value of x and y is followed by the value y. And if we look at the console output, our first line, is x is 3 and y is 3. This is followed up with a print statement using the equal to operator. So we first print out x &#61;&#61; y is followed by the operation using the &#61;&#61; operator.</p>
<p>So it&#39;s going to check if x equal to y, which is true. So if we look down at our second line in the console output, x &#61;&#61; y is true. A third print statement is going to check the not equal to operator. So we have x not equal to y is followed by the operator and use x not equal to y. And that&#39;s going to be false because x is equal to y.</p>
<p>So if we look at our third line in the console output, we see x not equal to y is false. Then we have our greater than operator. So we have another print statement with x &gt; y is followed by the use of our greater than operator x &gt; y.</p>
<p>And if we look on the fourth line of the console output, we see x &gt; y is false because 3 is not greater than 3. Then we have our less than operator with x &lt; y is followed by the use of x &lt; y. And that&#39;s also false as we see on the fifth line of the console output x &lt; y is false, because 3 is not less than 3.</p>
<p>Then we have our greater than or equal to operator with if x &gt;&#61; y is followed by the use of it. So x &gt;&#61; y, which is true because 3 is greater than or equal to 3. So on our sixth line of the output, we see x &gt;&#61; y is true. And finally we have our x less than or equal to y, which is shown on the seventh line of the console output as true because 3 is less than or equal to 3. So we see x &lt;&#61; y is true.</p></div></div></div><div class="section"><a name="section_6" /><h2 class="section_title">7. Video: Programming Java Relational Operators ( it_sdjcfa_08_enus_07)</h2><img src="https://cdn2.percipio.com/public/b/79755579-3c40-40d7-8026-1662ab28c540/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/79755579-3c40-40d7-8026-1662ab28c540/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the various Java equality and relational operators</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Relational Operators. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this video, <br /><br />[Video description begins] <em>The IntelliJ IDEA interface editor pane displays on the screen.</em> [Video description ends] <br /><br />we&#39;re going to demonstrate how to use Java relational operators. So to get started, let&#39;s create a Java class to demonstrate within called Relational.java. <br /><br />[Video description begins] <em>As he clicks the src underneath the &#34;Project&#34; on the left pane a drop down menu appears. He selects the &#34;New&#34; and then further selects the &#34;Java Class&#34;.</em> [Video description ends] <br /><br />[Video description begins] <em>A pop up box titled, New Java Class appears on the screen.</em> [Video description ends] <br /><br />[Video description begins] <em>The Relational.java file is open in the IntelliJ IDEA interface editor pane.</em> [Video description ends] <br /><br />And within that, we&#39;ll create a main method. <br /><br />[Video description begins] <em>Line 1 reads as: public class Relational {. Line 2 reads as: public static void main(String[] args) {.</em> [Video description ends] <br /><br />And now I&#39;ll list out what all the relational operators are and then we&#39;ll look at each of them in turn. We have equals equals, we have exclamation point equals, we have a forward chevron. We have forward chevron equals, we have backward chevron, and we have backward chevron equals.</p>
<p>So let&#39;s see how we can use each of these and what their purpose is. Relational operators will always return a Boolean because we&#39;re comparing one value to another in some way. So the result of these will always be either true or false. So let&#39;s create a couple different integers to compare. We&#39;ll have int a equals 3, we&#39;ll have int b equals 5 <br /><br />[Video description begins] <em>Line 5 reads as: int a &#61;3;.</em> [Video description ends]<br /><br />and we&#39;ll have int c equals 7, and finally int d will also equal 3.</p>
<p>Now let&#39;s take a look at equals equals. And to do this I&#39;m going to print the result to the command line of our comparison. So the first thing I want to do is compare my a variable to my d variable. So within my print statement, I&#39;ve said a equals equals d, and what this will do is check for equality. So the equals equals is telling Java is a equal to d? Are they the same value? And if they are the same value, it will return true. And if they&#39;re not the same value, it will return false. So in this case, it will print true because a is equal to d. <br /><br />[Video description begins] <em>Line 10 reads as: System.out.println(a &#61;&#61; d); // true.</em> [Video description ends]</p>
<p>Similarly, if I were to compare a equals equals b, this would return false because a is not equal to b. The next operator is the exclamation point equals and this is going to check for not equal to. So this is the opposite of the equals equals relational operator. So if I do another print statement, and I were to say a not equal d, this will be false because Java is checking to see is a not equal to d?<br /><br />[Video description begins] <em>Line 13 reads as: System.out.println(a !&#61; d); // false.</em> [Video description ends]</p>
<p>And since a is equal to d, this returns false. And if I were to check a not equal b, this will return true because a does not equal b.<br /><br />[Video description begins] <em>Line 14 reads as: System.out.println(a !&#61; b); // true.</em> [Video description ends]<br /><br />Our next operator is the single forward chevron and this stands for greater than. So what this will check for is to see if the value on the left side of the operator is greater than the value on the right side of the operator. So if I were to check is a greater than b, this would return false because 3 is not greater than 5.<br /><br />[Video description begins] <em>Line 16 reads as: System.out.println(a &gt; b); // false.</em> [Video description ends] <br /><br />If I were to reverse the statement, and check b greater than a, this would be true because b, which is 5, is greater than a, which is 3.</p>
<p>And if I were to check two values that are the same value such as a greater than d, this will also print out false because a and d are the same value, therefore a is not greater than d. Next we have forward chevron equals and this will check for greater than or equal to. So it will compare the value on the left side of the operator to the value on the right side of the operator, and return true if the value on the left side is greater than or equal to the value on the right side and false otherwise.</p>
<p>So if we do a greater than or equal to b, we will once again have false because a is 3, b is 5, we are still less than b. <br /><br />[Video description begins] <em>Line 20 reads as: System.out.println(a &gt;&#61; b); // false.</em> [Video description ends]<br /><br />If I reverse that and check b greater than or equal to a, it will return true because b is 5, a is 3, and 5 is greater than or equal to 3. But if I once again check a against d with a greater than or equal to d, now this will return true because a is 3, d is 3. So a is greater than or equal to d because they&#39;re both 3. Next we have the backwards chevron which is going to check for less than.</p>
<p>So it will evaluate the value on the left side and check if it is less than the value on the right side of the operator. If I check a against c, this will evaluate is a less than c? a is equal to 3, c is equal to 7, so a is less than c so this will return true. <br /><br />[Video description begins] <em>Line 24 reads as: System.out.println(a &lt; c); // true.</em> [Video description ends]<br /><br />If I were to reverse these and do c less than a, this will return false because c is 7, a is 3, and 7 is not less than 3, so this evaluates to false.</p>
<p>And finally, if I compare two values that are the same, such as a and d, if I check is a less than d, this will return false as well. Because a is 3, d is 3, they&#39;re the same value, therefore a is not less than d.</p>
<p>And finally, we have the backward chevron equals which will check for less than or equal to. So it&#39;ll evaluate the value on the left side of the operator and see if it is less than or equal to the value on the right side of the operator. So if we were to check is a less than or equal to c, this would return true once again because a is still less than c.<br /><br />[Video description begins] <em>Line 28 reads as: System.out.println(a &lt;&#61; c); // true.</em> [Video description ends] <br /><br />If I were to check out the reverse, c less than or equal to a, this will still evaluate to false because c is not less than or equal to a.</p>
<p>And if I were to compare two values that are the same value like a and d, with a less than or equal to d, this will now return true because a is 3, d is 3, so a is less than or equal to d. To verify that this all works as we expect, we&#39;ll compile and run this Java program and check the output in the console. <br /><br />[Video description begins] <em>A Terminal window appears below the editor pane, showing various commands. He enters the Relational.java</em> [Video description ends] <br /><br />So going in order of our print statements, the first two are checking whether a is equal to d and we have true.</p>
<p>We check if a is equal to b, and we have false. Next, we are checking is a not equal to d and we have false because a is equal to d. And then we are checking is a not equal to b and we have true because a is not equal to b. The next three are checking is a greater than b? It is not, so false.</p>
<p>Is b greater than a? It is, so true. Is a greater than d? It is not, so false. Then we have is a greater than or equal to b? It&#39;s not, so false. Is b greater than or equal to a?</p>
<p>It is, so we have true. Is a greater than or equal to d? It is, so we have true. Then we&#39;re checking is a less than c? And it is, so we have a true. Is c less than a?</p>
<p>It is not, so we have a false. And is a less than d? And is not, so we have another false. And finally, we&#39;re checking is a less than or equal to c? And it is, so we have true. Is c less than or equal to a?</p>
<p>And it is not, so we have a false. And is a less than or equal to d? And it is, so we have true. And that&#39;s how relational operators work in Java.</p></div></div></div><div class="section"><a name="section_7" /><h2 class="section_title">8. Video: Java Logical Operators ( it_sdjcfa_08_enus_08)</h2><img src="https://cdn2.percipio.com/public/b/8e8dfb5c-eb70-4af2-8404-8a1b5954e986/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/8e8dfb5c-eb70-4af2-8404-8a1b5954e986/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the various Java logical operators</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Logical Operators. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Logical operators in Java are operators that we can use to combine relational operators together in order to produce true or false results. So we can have things like, and or or or not. And combine them with the relational operators, like greater than, or equal to, or not equal to. And return a true result from that. And with these logical operators, we can perform something called short circuiting which is a micro optimization in our code. Let&#39;s use the order statement which is a logical operator as an example. The order statement returns true if either operand on either side of it is true. So if Java is checking A or B and A returns true. Java doesn&#39;t even need to bother checking B, because it already knows the end result is going to be true. So it can make the code a little bit more efficient by avoiding that statement.</p>
<p>So if you&#39;re clever with how you place your statements, you can set it up so that a statement that is likely to be true 90% of the time would be on the left. So most of the time, you don&#39;t have to evaluate the one on the right. Let&#39;s look at some of the logical operators we have in Java. The first one we&#39;re going to talk about is the logical AND operator. And this is represented by the double ampersand. So what this will do is it will evaluate an operand on the left side of the operator and an operand on the right side of the operator. And if both operands evaluate to true, this will return true otherwise it will return false. Most commonly on either side of the logical operators, you&#39;re going to have some sort of relational operators. Not always, but that&#39;s the majority of your use cases. So for example, we could have 5 greater than 3 on the left side of our logical AND operator.</p>
<p>And 4 greater than 3 on the right side of our logical AND operator. Both of those statements evaluate to true. So 5 greater than 3, &amp;&amp; 4 greater than 3 is going to evaluate to true. Now if we had one of our statements that evaluated to false. Let&#39;s say for example, we had 5 greater than 3. &amp;&amp; 4 less than 3. Well, 4 less than 3 evaluates to false. So we would have the situation seen in our bubble on the screen where it says true and false. So that&#39;s going to evaluate to false because not both of our operands are true.</p>
<p>And similarly, if both of our operands are false, this would still return false. The next logical operator that we want to talk about is the logical OR operator which is symbolized by two successive bar symbols. So this will return true if an operand on either side of the operator is true. So let&#39;s use our first example. 5 greater than 3, but this time using the logical OR operator and then 4 greater than 3. So we would have 5 greater than 3 or 4 greater than 3. Both operands are true. So this will return true. Now if one of them was false, such as 5 greater than 3, or 4 less than 3. We have one that&#39;s true and one that&#39;s false. Well, this is still returned true because one of the operands is true.</p>
<p>The only time this will return false is if both operands are false. And finally, we have the logical NOT operator, which will just flip the overall result. So let&#39;s use our logical AND example, where we had 5 greater than 3, and 4 greater than 3. This evaluates to true. If we were to put the logical NOT in front of that whole statement, then, that would evaluate to false. It will flip the end result of the entire statement. And this logical logical NOT operator is symbolized with a single exclamation point. Most commonly you&#39;re going to see some sort of expression enclosed in parentheses and the exclamation point sitting just outside the parentheses.</p>
<p>Again, it doesn&#39;t have to be like that. But that&#39;s the most common use case you&#39;re going to see the logical NOT used in. This code snippet shows an example of using the logical AND operator. So we have our public class operator example, defined on line 1. And then we have a main method to find on line 2. On line 3, we have two booleans to find, x is equal to true, and y is equal to false. So then we have a series of print statements from lines 5 to 9.</p>
<p>And if we look at the bottom of the screen, we have five output lines in the console representing what would happen when this program is run. These are the results of the print statements seen from lines 5 to 9. So the first print statement on line 5 is just printing out the value of what x is and y is. On the first console line we can see x is true and y is false. Then we&#39;re going to use the logical AND operator with various combinations of y and x. The first combination seen on line 6 is y and x.</p>
<p>So this is going to be false and true, because y is false, x is true. And since both operators are not true, this is going to result in false. And we can see on the second line of our console output, y &amp;&amp; x is false. Our third print statement on line 7 is going to do x and y. So the same as our previous statement, but we&#39;ve flipped the operators, x is on the left and y is on the right. So in this case, we&#39;re now going to be checking true and false as opposed to false and true. The order of the operands doesn&#39;t matter. So the result is going to be the same.</p>
<p>We still have a false on one side of our and operator. So if we look at our third console line output, we can see x &amp;&amp; y is false as well. Our fourth print statement is comparing x and x. So this is going to be true and true. In this case, we have true as both of our operands on either side of the and operator. So the result is also going to be true.</p>
<p>And if we look on our fourth console line output, we can see x &amp;&amp; x is true, because both operands are true. Finally, our fifth and last print statement is comparing y to itself with y and y. So this is going to be comparing false and false. Since both operands are false and neither one is true, then we have the end result being false. And we can see that on our final console line with y &amp;&amp; y is false. Our next code snippet shows the use of the logical OR operator. So once again we have another public class operator example defined on line 1 with a main method defined on line 2.</p>
<p>And we have two Booleans defined on line 3, boolean x &#61; true and y &#61; false. And then we have a series of five print statements from lines 5 to 9 with their corresponding five console output lines at the bottom of the screen. The first print statement on line 5 is once again printing out the values of x and y. So we see x is true and y is false. Our second print statement on line 6 is using y or x as its operation symbolized by y || x. So this is going to be comparing false or true. Since we have a true on one side of the or, the end result is going to be true.</p>
<p>So we can see that on the second line of the console output y || x is true. Our third print statement on line 7 is the same comparison but with the operands flipped to the other side. So we&#39;re comparing x or y, x || y. Once again, the order of the operands doesn&#39;t matter. So since we have a true on one side of our OR operator, this is going to evaluate to true. And we can see that in the third line of our console output, x || y is true. Our fourth print statement is comparing x or x.</p>
<p>So this would be true or true. And once again, at least one of the operators is true. So the end result is going to be true. We can see that on our fourth line in the console output x || x is true. Finally, we&#39;re going to compare y or y. This is false or false.</p>
<p>And since neither operand is true, this will evaluate to false. And we can see that on the final line of the console output, y || y is false. Our final code snippet deals with the logical NOT operator. Once again we have our public class operator example defined on line 1 followed by a main method on line 2. Followed by the two definitions of the boolean variables on line 3, boolean x &#61; true and y &#61; false. Once again we have five print statements from lines 5 to 9 with their corresponding outputs as would be seen on the console at the bottom of the screen.</p>
<p>The first print statement on line 5 prints out the values of x and y. And we can see that on the first line of the console output saying x is true and y is false. Our second print statement on line 6 is going to say not x. So we can see !x at the end of line 6. And that&#39;s going to flip the value of x. Since x is true, not x will be false. And we can see it on the second line of the console output, !x is false.</p>
<p>Our third print statement on line 7 is dealing with not y. So we can see !y. y is false, so not y is true. And we can see that on the third line of our console output, !y is true. On our fourth print statement on line 8, we&#39;re using a not operator in conjunction with an or statement. So inside of our parentheses, we have x or y with x || y. So that statement is going to be comparing true or false and it evaluates to true. So we can think of the inside of the parentheses as being true.</p>
<p>Outside of the parentheses we have an exclamation mark. So that&#39;s saying not whatever&#39;s inside the parentheses. Since whatever is inside the parentheses is true and we&#39;re saying not that, then this will evaluate to false. And we can see that on the fourth console line output, !(x || y) is false. And in our last print statement on line 9, we&#39;re doing an AND comparison inside a parentheses and a NOT operator outside of the parentheses. So we&#39;re checking inside the parentheses x and y. So true and false, which evaluates to false. And then we can think of the NOT operator operating on the inside of the parentheses which is false. So we&#39;re saying not false, which evaluates to true. And we can see that on the final line of the console output, !(x &amp;&amp; y) is true.</p></div></div></div><div class="section"><a name="section_8" /><h2 class="section_title">9. Video: Programming Java Logical Operators ( it_sdjcfa_08_enus_09)</h2><img src="https://cdn2.percipio.com/public/b/a83ac355-7657-408a-9ce5-93b3d8db9a7c/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/a83ac355-7657-408a-9ce5-93b3d8db9a7c/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the various Java logical operators
</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Logical Operators. Your host for this session is Peter Adamson.</em> [Video description ends] <br /><br />[Video description begins] <em>The IntelliJ IDEA interface editor pane displays on the screen.</em> [Video description ends]
<p>In this video, we&#39;re going to demonstrate the use of Java conditional operators. To get started, I&#39;m going to create a class for us to work in <br /><br />[Video description begins] <em>As he clicks the src underneath the &#34;Project&#34; on the left pane a drop down menu appears. He selects the &#34;New&#34; and then further selects the &#34;Java Class&#34;.</em> [Video description ends] <br /><br />called Conditional.java. <br /><br />[Video description begins] <em>A pop up box titled, New Java Class appears on the screen.</em> [Video description ends]<br /><br />[Video description begins] <em>The Conditional.java file is open in the IntelliJ IDEA interface editor pane.</em> [Video description ends]<br /><br />And within that, I&#39;m going to have a main method to run our codec. <br /><br />[Video description begins] <em>Line 2 reads as: public static void main(String[] args) {.</em> [Video description ends] <br /><br />In Java, we have three conditional operators. We have &amp;&amp;, ||, and !. So let&#39;s look at what each of these do in turn. The first conditional operator we&#39;ll look at is &amp;&amp; and this stands for logical AND. So what this will do is evaluate two statements, and return true if both statements are true, and false if both statements are false.</p>
<p>So let&#39;s see how that works. I&#39;m going to make an integer X &#61; 9. This is what we&#39;re going to use in our conditional. <br /><br />[Video description begins] <em>Line 5 reads as: int x &#61;9;.</em> [Video description ends] <br /><br />So I&#39;m going to next make a print statement to use our logical AND and within that print statement, I&#39;m going to check (X &gt; 5 &amp;&amp; X &lt;11). And this returns true because x is both greater than 5 and it is less than 11.<br /><br />[Video description begins] <em>Line 6 reads as: System.out.println(x &gt;5 &amp;&amp; x &lt; 11 );// returns true.</em> [Video description ends] <br /><br />Let&#39;s do one that would return false with once again (X &gt; 5 &amp;&amp; X &lt; 8).</p>
<p>This will return false because while x is greater than 5, x is not less than 8, so both conditions on either side of the logical AND are not true. And therefore, the statement as a whole evaluates to false. The next conditional operator is ||, and this is logical OR.</p>
<p>So this one will look at two statements on either side of it and return true if either one of those statements are true. So with logical AND, we had the requirement that both statements be true. With the logical OR, all we care about is that one statement is true.</p>
<p>So let&#39;s see how we do that with another print statement (X &gt; 5 || X &lt; 8). This will now return true because even though x is not less than 8, x is greater than 5. And since all we need is one of the statements to be true, <br /><br />[Video description begins] <em>Line 9 reads as: System.out.println(x &gt;5 || x &lt; 8 );// returns true.</em> [Video description ends]<br /><br />since this is asking, is X greater than 5, or is X less than 8.</p>
<p>Well, X is greater than 5, so we return true. If both statements are true, such as X greater than 5 or less than 11. We would still return true. And if neither statement is true, such as (X &gt; 10 || X &lt; 8), then we return false because X is neither greater than 10 nor less than 8.</p>
<p>And the last operator that we want to look at is the logical NOT operator. The NOT will flip the overall result. So let&#39;s look at some of the statements that we&#39;ve already done. So I&#39;m going to copy our first logical AND statement from line 6, and paste it here on line 13.</p>
<p>Now, this is the exact same statement that we have on line 6, but I&#39;m going to add something to it. I&#39;m going to put the inside statement or logical AND within another set of parentheses, and outside of that set of parentheses, I&#39;m going to add our logical NOT operator, the exclamation point.</p>
<p>And now what this will do is return false. Because it will evaluate the first statement within the parentheses, which we already know returns true because X is greater than 5 and X is less than 11. And then the NOT operator will flip that result. So the inside evaluates to true, and then we say, not this, so that will flip it to become false.</p>
<p>If I paste the line from line 7 onto line 14 and once again do the same thing enclose the inner statement within parentheses and add my exclamation point my logical NOT.</p>
<p>Now, this will return true because previously, we know that X greater than 5 and X less than 8 will return false. And then, I add the NOT outside of that parentheses to flip it to return true.</p>
<p>To see this in action, we&#39;ll compile and run our program.<br /><br />[Video description begins] <em>A Terminal window appears below the editor pane, showing various commands. He enters the Conditional.java</em> [Video description ends] <br /><br />And in order, we have our first logical AND statement X greater than 5 AND X less than 11, which evaluates to true.</p>
<p>Then, we have our second logical AND statement, X greater than 5 AND X less than 8 which evaluates to false. Then we have our logical ORs with X greater than 5 OR X less than 8, and that evaluates to true. X greater than 5 OR X less than 11 which evaluates to true as well. X greater than 10 OR X less than 8 which evaluates to false.</p>
<p>Then we have our logical NOTs, which are the opposite of our first two statements. So we have NOT X greater than 5 AND X less than 11, which returns false. And then, we have NOT X greater than 5 AND X less than 8, which returns true. So that&#39;s how we use conditional operators in Java.</p></div></div></div><div class="section"><a name="section_9" /><h2 class="section_title">10. Video: Java Bitwise Operators ( it_sdjcfa_08_enus_10)</h2><img src="https://cdn2.percipio.com/public/b/c2d18ac7-c484-43af-aaeb-9cdada4b1140/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/c2d18ac7-c484-43af-aaeb-9cdada4b1140/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe the various Java bitwise operators</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Bitwise Operators. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Bitwise operators in Java are used against integer types of data, things like ints, longs, doubles, floats and they work by operating on the binary representations of these data. So you might have an integer and if you&#39;re applying bitwise operators, Java behind the scenes, will be working on the binary representation of that integer. Our bitwise operators come in two forms either unary or binary. The unary bitwise operators work on a single operand. So that means that they&#39;re doing things like flipping the bits of a number.</p>
<p>And we have binary operators which are working between two different operands. So this is more of a comparison between two binary numbers. Let&#39;s take a look at some of the bitwise operators that we have. The first ones that we want to talk about are the bitwise shift operators. And these are all unary operators, these are going to be working on a single operand. They&#39;re either going to be pushing the numbers of the binary to the right or to the left. The first one is our zero-fill left shift, and let&#39;s use the binary number that we have in the bubble on screen as an example 1010.</p>
<p>The zero-left shift will shift the numbers or the bits in our binary number to the left the number of places specified. So the operand goes on the left side of the operator and the number of places that you want to shift goes on the right side of the operator. So if we wanted to left shift our number by one place, we could have 1010 followed by the left shift represented by two left facing chevrons, and then the number 1. And that will shift our value 1 place to the left. Now, how does it do that? Well, our left most bit will just be dropped off.</p>
<p>So in this case, in our 1010, we&#39;ll get rid of that first 1 and from the right side we&#39;ll fill in zeros. So our number will become 0100 once it&#39;s left shifted by one place. Next, we have our signed right shift. Signed right shift will shift the bits in our number to the right by the amount specified. So once again, our binary number or integer which will be treated as a binary number on the back end anyway.</p>
<p>It&#39;s placed on the left side of the operator, followed by the signed right shift operator, which is to right facing chevrons, followed by the number of specifying, how many places we want it to shift to the right. So if we want to shift it one place to the right, we could have 1010, right shift one. And what this will do is it will shift the number to the right by one place.</p>
<p>So our right most bit, which is a zero will get dropped off and then our leftmost bit will be copied with whatever the previous leftmost bit was. So if I left most bit was a zero, then a zero will be filled in from the left. And if our leftmost bit was a one, then a one will be filled in from the left. So in this case, our leftmost bit was a one so a one will be filled in. So once we right shift our number right one place, it would become 1101. And finally we have a zero-fill right shift. This is represented by three chevrons, and it works very similar to the side right shift, but it&#39;s different in how it brings a number in from the left.</p>
<p>With the signed right shift, we copy whatever number was previously on the left whether it was a 1 or a 0, with zero-fill right shift, we just default by filling it with a 0. So once again, if we were to right shift our 1010 by one, but with a zero-fill right shift, we would have 1010 followed by three right facing chevron&#39;s to signify the zero-fill right shift, followed by one. And what that will do is once again, it will drop the zero off the far right side of our binary number, and then it will bring a zero in on the left side of our binary number giving us 0101.</p>
<p>Now let&#39;s move on to a couple binary bitwise operators. Operators that are going to work on two operands. The first is our bitwise AND, and what this is going to do is perform a bit by bit operation. So what that means is you&#39;re going to have two binary numbers. And it&#39;s going to compare the bit in the first spot of your first binary number to the bit in the first spot of your second binary number.</p>
<p>And then it will continue on that way comparing the bit in the second place of your first binary number to the bit in the second place of your second binary number all the way until you are out of bits. And we&#39;ll use these operators to perform these comparisons in order to generate a new binary number based on the results of the comparison. So in the case of the bitwise AND represented by a single ampersand, we&#39;re going to be going on a bit by bit procedure.</p>
<p>And if we&#39;re looking at the first bit in the first place of our number, then the result will go in the first bit of our resulting binary numbers. So in the case of the first bit in both of our numbers being one, then the bitwise AND operator will return a one and we&#39;ll have a one in our resulting binary number at that place. If either bit is a zero, then we&#39;ll have a zero in our resulting binary number at that place.</p>
<p>And if both bits are zero, then we&#39;ll have a zero at that binary number in that place. The bitwise OR operator works in the same way, except it only requires one of the bits to be a one. So in the case of both bits in a certain place being a 1 than the resulting bit in that place in our resulting number will be a 1.</p>
<p>If we have a single 1 and another 0, then we&#39;ll still have a resulting 1 in that place in our result. And if we have both bits as a zero, then we&#39;ll have a zero in that resulting bit in that place in our result. And the Bitwise OR operator is represented by a single bar. Moving on to the bitwise NOT operator, this one is once again a unary operator, so it&#39;s only working on a single operand. And what this does is it flips the bit in every place of a binary number.</p>
<p>So it&#39;s symbolized by a tilde, and you put the tilde in front of your binary number. So let&#39;s say for example, our binary number is 1111. Well, if we put the bitwise NOT operator in front of that, it would flip and the result would be 0000. So anytime you see a 1, you flip it to a 0, anytime you see a 0, you flip it to a 1 and that&#39;s how the bitwise NOT operator works. We also have the bitwise Exclusive OR represented by a carrot symbol. And this is a binary operator. So it once again works on two operands.</p>
<p>So we&#39;re comparing two binary numbers in a bit by bit operation once again, but what we&#39;re checking now is, the result will be a one if and only if a single bit in the two operands is a one. So if we&#39;re comparing a 1 Exclusive OR to a 1, the result is going to be a 0 because we don&#39;t want both bits to be a 1. If we&#39;re comparing 1 exclusive or to a 0, the result will be 1 because that satisfies our conditions. And if we&#39;re comparing 0 Exclusive OR to a 0, our result will be once again 0.</p>
<p>And we can combine these bitwise operators with assignment operators to help give us some shortcuts and clean up our code. So we can use our left shift followed by an assignment operator with two left chevrons followed by an equal sign. To use this, we put the variable on the left that we want to be shifted and we put the number of times we want it to be shifted on the right.</p>
<p>So it will shift the variable that number of times and then store it in that variable. Similarly with the right shift, we put the variable on the left side, number of places we want it to be right shifted on the right. And then it is right shifted that amount and stored in that variable. With the bitwise AND assignment, we can do the variable on the left side, the value we want to end it with on the right, and then it is carried out and stored in the variable. Bitwise Exclusive OR an assignment with the carrot symbol followed by an equal sign. And once again, it will perform the Exclusive OR between the variable on the left and the number or value on the right. And then store that result in the variable that you will have on the left. And much the same with the bitwise inclusive OR, but instead now it&#39;s a bar and an equal sign.</p></div></div></div><div class="section"><a name="section_10" /><h2 class="section_title">11. Video: Programming Java Bitwise Operators ( it_sdjcfa_08_enus_11)</h2><img src="https://cdn2.percipio.com/public/b/b5915dea-86fc-4689-b016-5bb0d753db7b/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/b5915dea-86fc-4689-b016-5bb0d753db7b/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate the various Java bitwise operators</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Bitwise Operators. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>In this video, we&#39;re going to demonstrate the use of Java bitwise operators. <br /><br />[Video description begins] <em>The IntelliJ IDEA interface editor pane displays on the screen.</em> [Video description ends] <br /><br />When we&#39;re talking about bitwise operators, we&#39;re actually dealing with binary logic. So in the demonstration, I&#39;m going to be showing you how we use these with integers. But the whole time, we&#39;re going to need to be thinking about these integers in terms of their binary representation. To get started, we&#39;ll create a Java class called Bitwise.java. <br /><br />[Video description begins] <em>As he clicks the src underneath the &#34;Project&#34; on the left pane a drop down menu appears. He selects the &#34;New&#34; and then further selects the &#34;Java Class&#34;. A pop up box titled, New Java Class appears on the screen.</em> [Video description ends] <br /><br />And within Bitwise.java, I&#39;m going to have a main method. <br /><br />[Video description begins] <em>The Bitwise.java file is open in the IntelliJ IDEA interface editor pane. Line 2 reads as: public static void main(String[] args) {.</em> [Video description ends] <br /><br />And now we can deal with our bitwise operators. The bitwise operators that we have represented by ampersand, bar, tilde, caret, a double left chevron, a double right chevron and a triple right chevron. So let&#39;s take a look at each of these intern and see what they do and how they&#39;re used. Starting in order, the first one we&#39;ll look at is the single ampersand, and this stands for bitwise AND. So let&#39;s use it to perform a bitwise AND operation on two integers and then we&#39;ll take a look at what it&#39;s doing behind the scenes. So int x &#61; 4 and then we&#39;ll have another int y &#61; 1.<br /><br />[Video description begins] <em>Line 5 reads as: int x &#61; 4;.</em> [Video description ends] <br /><br />And then what we&#39;ll do is throw a few print statements out, so we can see it in the console later with X bitwise AND Y. <br /><br />[Video description begins] <em>Line 8 reads as: System.out.println(x &amp; y );.</em> [Video description ends]<br /><br />So what this is going to do is look at both of these numbers in their binary format. Now in Java, int&#39;s are 32 bit signed representation.</p>
<p>So that means every integer is going to have 32 bits with the first bit representing the sign, whether it&#39;s positive or negative. And the remaining bits representing the actual value of the number. When we get into negative values, it&#39;s important to remember that Java is actually dealing with these using two&#39;s complement. And I&#39;ll show a little bit about how that works in the shift operations, the left left chevron, the right right chevron and the right right right chevron. So for now, let&#39;s look at what these integers actually look like in binary. So besides int x &#61; 4, I&#39;m going to put the 32 bit signed representation of four. So this value that I put in the comment beside four is what Java is actually looking at the binary representation of four. Similarly, beside int y &#61; 1, I&#39;ll put the binary representation of one.</p>
<p>So that&#39;s what we&#39;re looking at when we&#39;re doing these bitwise operations. So going back to our bitwise AND, where we&#39;ve done our X and Y. What this will do is look at each bit in both numbers. And if both bits are one, the resulting bit in that same location will also be one. If both bits are not one, then the resulting bit will be zero. So if we look at our int x &#61; 4, and int y&#61; 1 values, we can see as I&#39;ve placed them one on top of each other, it&#39;s very easy visually to do the comparison. Because we just have to look at the top value and the bottom value. And if they&#39;re both one, the result will be one, otherwise the result will be zero. So starting from the right, we have for int x &#61; 4, a zero value, and for int y &#61;1, a one value.</p>
<p>We don&#39;t have any duplication there, since not both values are 1, this will be a 0. Similarly, on our third bit, we only have one bit which is a 1, the one below it is a 0 so the resulting bit will be 0. So by doing a bitwise AND between these two integers, we&#39;ll actually end up with a value of 0.<br /><br />[Video description begins] <em>On the line 8 he enters the text &#34;will print 0&#34;.</em> [Video description ends]<br /><br />The next operator that we want to look at is the single bar, which is bitwise OR. <br /><br />[Video description begins] <em>Line 10 reads as: System.out.println(x | y );.</em> [Video description ends]<br /><br />And I can do it with the following print statement, x OR y. And what this will do is once again, compare the two binary numbers and looking at the same position versus the same position.</p>
<p>And if either bit in that position is a 1, then the resulting bit in that position will also be a 1. So if we look at our values x and y in our rightmost bit, x is 0 and y is 1. So since one of those values is a one, the result will be a one in that place. Moving along the next second bit both of them are zero, so the result will be zero. The third bit in x is a one, the third bit in y is a zero.</p>
<p>So the result will be one, and then the rest are all zeros and both of them so they will remain zeros. So our result in binary is 101, which is equivalent to 5.<br /><br />[Video description begins] <em>On the line 10 he enters the text &#34;will print 5&#34;.</em> [Video description ends]<br /><br />Our next operator is the tilde which stands for bitwise NOT. So we can use it as follows. I can do bitwise NOT x, <br /><br />[Video description begins] <em>Line 12 reads as: System.out.println( ~x );.</em> [Video description ends]<br /><br />and what this will do is invert all of the bits in x. So if the bit is a zero, it will be flipped to a one. If the bit is a one, it will be flipped to a zero.</p>
<p>So the result will be as seen in my comment at the end of line 12 where we have a large amount of leading ones, a zero in the third bit from the right, followed by two more ones. Now this is where, what I mentioned at the beginning of the video where Java uses 32 bit signed integers and two&#39;s complement becomes important. Because in order to read what this value is, we need to understand first how signed integers work, and that is the first bit on the left, the most significant is either a 1 or a 0. If it&#39;s a 0, it&#39;s a positive number, if it&#39;s a 1, it&#39;s a negative number.</p>
<p>So in this case, we know we will be dealing with a negative number now. Since the bitwise NOT has flipped everything. And then in the two&#39;s complement, in order to read a negative number, flip all the bits once again and then add the value one to it, and then add the negative sign in front of it. So what this will actually convert to when it prints is minus 5, because if we invert all of the bits in this value, we get the original value <br /><br />[Video description begins] <em>On the line 12 he enters the text &#34;will print -5&#34;.</em> [Video description ends] <br /><br />that we started with before we did the bitwise NOT, which is 4.</p>
<p>We add 1 to make it 5, and then we put our negative symbol back in front of the value to make it negative 5. And that&#39;s how these values are handled in Java. Next, we have the caret symbol and that can be used such as x caret y. And the caret stands for exclusive OR.<br /><br />[Video description begins] <em>Line 14 reads as: System.out.println( x ^ y );.</em> [Video description ends]<br /><br />So this differs from our bar symbol which was the bitwise OR in that the bitwise exclusive OR will set a bit to one, if and only if one of the bits is a one. So if both bits are a one, we don&#39;t set the resulting bit to a one.</p>
<p>We only do it in cases where a single bit is one. So in this case, if we look at x with 4 and y with 1, in all cases, we only have a one in one of the positions in the binary representation. So the actual result will be the same as the regular OR in this case. <br /><br />[Video description begins] <em>On the line 14 he enters the text &#34;will print 5&#34;.</em> [Video description ends]<br /><br />Now we move on to our shift operators.</p>
<p>So our first one will be the double left chevron, which stands for zero fill left shift. And I can use it with x double left chevron y. And what this will do is shift all of the numbers <br /><br />[Video description begins] <em>Line 16 reads as: System.out.println( x &lt;&lt; y );.</em> [Video description ends]<br /><br />in the binary representation to the left by the amount specified on the right side of the operator.</p>
<p>So in this case, y &#61; 1, so we&#39;re shifting all of the bits in x to the left one place. And any bit that gets shifted to the left off the left side is just discarded because we can&#39;t have more than 32 bits in an integer. And from the right side, we fill in with zeros. So what this will look like if we shift x to the left by one place. We will delete this first zero. And at the right side, we&#39;ll add a zero. So the result will be 8. <br /><br />[Video description begins] <em>On the line 16 he enters the text &#34;will print 8&#34;.</em> [Video description ends]<br /><br />Next we have the double right chevron, it can be used in a similar way x double right chevron y.<br /><br />[Video description begins] <em>Line 18 reads as: System.out.println( x &gt;&gt; y );.</em> [Video description ends]</p>
<p>And this is the signed right shift. So this works a little bit different than the zero fill left shift. What this will do is, once again we&#39;re going to shift the bits, whatever number of places is specified by the right side of the operator to the right. So in this case, the x value will be shifted to the right one place, and whatever gets shifted off the right side will just be discarded. But coming in from the left, we don&#39;t automatically fill with zeros, we&#39;ll actually fill with whatever is already on the left side of the value. So if the leftmost bit is zero, we&#39;ll put in a zero. If the leftmost bit is one, we&#39;ll put in a one.</p>
<p>So in this case, we will get rid of the value on the rightmost side of our binary. And then we will fill in on the leftmost side of our binary with a copy of whatever bit is to our right. In this case, it&#39;s a zero. And this will print two, and our final operator is the triple chevron to the right which is used as x triple chevron to the right y. <br /><br />[Video description begins] <em>Line 20 reads as: System.out.println( x &gt;&gt;&gt; y );.</em> [Video description ends] <br /><br />And this is the zero fill right shift. This is more similar to our zero fill left shift, which is the double left chevron.</p>
<p>And in this case, we&#39;ll once again shift our binary to the right by the amount specified on the right side of the operator. So we&#39;ll shift our x binary to the right one place, would discard whatever bits gets pushed off the right side, and we&#39;ll fill in from the left with zeros. So once again, we&#39;ll get rid of our rightmost zero, and then we&#39;ll just add a zero to the left side of the value. And in this case, we&#39;ll on again print 2. Let&#39;s compile our program and see the output in the console. <br /><br />[Video description begins] <em>A Console window appears below the editor pane, showing various commands. He enters the Bitwise.java</em> [Video description ends]</p>
<p>So our first operation, as we predicted has printed 0. The second operation has printed 5, third operation has printed minus 5. The fourth operation has printed 5, the fifth operation is printed 8. The sixth operation has printed 2, and the seventh operation has also printed 2. So everything has worked as we predicted that it would. And that&#39;s how we can use bitwise operators in Java.</p></div></div></div><div class="section"><a name="section_11" /><h2 class="section_title">12. Video: Java Operator Precedence ( it_sdjcfa_08_enus_12)</h2><img src="https://cdn2.percipio.com/public/b/90d60ec3-a798-4c85-9d2c-3776b54d21ba/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/90d60ec3-a798-4c85-9d2c-3776b54d21ba/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">describe operator precedence in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Java Operator Precedence. Your host for this session is Peter Adamson.</em> [Video description ends]
<p>Operator precedence refers to the order in which Java will carry out your operations. In Java, every operator has a certain precedence priority. The higher the priority, the earlier that operator is carried out. So take a look at how the operator precedence works in Java and the order in which these operators are used. So we&#39;ll look at unary operators which are performed first, then arithmetic, shift, relational, bitwise, logical and ternary and assignment operators. Unary operators have the highest precedence in Java and are therefore executed first in any operation.</p>
<p>The highest priority of the unary operators are the post increment and post decrement operators. These will be carried out first. Next, we have the rest of our unary operators like pre-increment and pre-decrement, the unary plus sign to signify whether something is a positive or a negative. Along with the unary minus sign, the bitwise complement, and the logical complement. So everything on the left side of the screen has the absolute highest priority followed by the unary operators on the right side of our screen.</p>
<p>Moving down in the priority list, our next operator precedence is with the arithmetic operators. Within these arithmetic operators, our multiplication, division, and modulus/remainder operations have the higher priority. And then addition and subtraction have lower priorities.</p>
<p>So we&#39;ve moved down the level from our unary operators, arithmetic operators have a lower precedence, and then within the arithmetic operators we have two different precedence levels, one with the multiplicative side and one with the additive side.</p>
<p>After the arithmetic operators, we go to a lower precedence level with the bitwise operators, specifically the bitwise shift operators. So, we then have all on the same precedence level, our zero-fill left shift, our signed right shift, and our zero-fill right shift. After the bitwise shift operations, the next operators in line to be executed are the relational operators.</p>
<p>And once again, within the relational operators, we have two different precedence levels. Our higher precedence relational operators are our comparison operators.</p>
<p>Things like greater than, less than, greater than or equal to, less than or equal to and instanceof. We haven&#39;t talked about instanceof before, but that&#39;s a way of testing whether a specified object is a certain type. And then lower in precedence level within the relational operators, we have the equality operators, our equal to&#39;s and are not equal to&#39;s.</p>
<p>After our relational operators, the next lowest priority and the next ones to be executed are the rest of the bitwise operators and each of these actually exists on their own precedence level. So at the highest precedence within the bitwise operators, we have our bitwise AND bitwise exclusive OR is next, and then our bitwise OR is the lowest precedence within this group.</p>
<p>Our next lowest priority is the Java logical and ternary operators. And once again, these all exists on their own precedence level. So within this group, our highest precedence would be the logical AND followed by the logical OR, and finally our ternary operator, which is a shorthand kind of an if else statement. So you have an expression, and if that expression is true, it executes a certain expression otherwise it executes a different expression.</p>
<p>And at the lowest priority, our last to be executed is the Java assignment operators. This is where we have our mathematical assignments, things like your simple assignment, add and assignment, subtract and assignment, multiply and assignment, divide and assignment, modulus and assignment.</p>
<p>Then we have our bitwise assignments, bitwise and assignment and bitwise exclusive OR and assignment, bitwise inclusive OR an assignment.</p>
<p>Then our shift assignments are zero fill left shift and assignment, signed right shift and assignment, zero right shift and assignment. Now every operator that I&#39;ve discussed so far, in terms of their precedence order, will be executed based on highest to lowest priority. But sometimes we don&#39;t always want it to be that way.</p>
<p>So we can manipulate in Java, what order our operators are going to be executed. And we can do that with the use of parentheses. Let&#39;s use multiplication and subtraction for example. Multiplication exists at a higher precedence level than subtraction so it will be carried out first.</p>
<p>Now let&#39;s say we had the expression 5 times 2 - 1. Well, in this case without any parentheses, Java will do 5 times 2 first to be equal to 10 and then subtract 1 to be equal to 9.</p>
<p>But what if we actually wanted that 2 - 1 to be operated on first? Well, in that case, we could enclose 2 -1 in parentheses. And then we could have 5 times open parentheses 2 -1, close parentheses. And what this will do is tell Java, work with whatever is in the parentheses first and then work with whatever is outside of the parentheses.</p>
<p>So Java will do 2- 1 first to be equal to 1, and then it will do 5 times the result of the parentheses which is 1, so it will be 5 times 1 equal to 5. That&#39;s how we can manipulate what order the operators get executed in using parentheses to override their default precedence.</p></div></div></div><div class="section"><a name="section_12" /><h2 class="section_title">13. Video: Programming Java Operator Precedence ( it_sdjcfa_08_enus_13)</h2><img src="https://cdn2.percipio.com/public/b/6675c7bf-0bc2-41ea-80f6-7cfd3a0600c3/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/6675c7bf-0bc2-41ea-80f6-7cfd3a0600c3/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">demonstrate operator precedence in Java</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Programming Java Operator Precedence. Your host for this session is Peter Adamson.</em> [Video description ends] <br /><br />[Video description begins] <em>The IntelliJ IDEA interface editor pane displays on the screen.</em> [Video description ends]
<p>In this video, we&#39;re going to show how operator precedence works and how we can use parentheses to modify the default operator precedence. So to get started, I&#39;m going to create a new Java class called Precedence.java. <br /><br />[Video description begins] <em>As he clicks the src underneath the &#34;Project&#34; on the left pane a drop down menu appears. He selects the &#34;New&#34; and then further selects the &#34;Java Class&#34;. A pop up box titled, New Java Class appears on the screen.</em> [Video description ends] <br /><br />What&#39;s in that class I&#39;m going to start with a main method. <br /><br />[Video description begins] <em>The Precedence.java file is open in the IntelliJ IDEA interface editor pane. Line 2 reads as: public static void main(String[] args) {.</em> [Video description ends]<br /><br />Now in Java, every operator has a precedence level, and the higher the precedence level, the earlier that an operator is executed.</p>
<p>So operators with the highest precedence are operated first. The table is as follows, from highest to lowest. <br /><br />[Video description begins] <em>Line 3 reads as: //highest.</em> [Video description ends] <br /><br />We start out with our post increment and post decrement. <br /><br />[Video description begins] <em>Line 4 reads as: // i&#43;&#43;, i--.</em> [Video description ends] <br /><br />Next, we have our pre-increment, our pre-decrement, our tilde, which inverts all the bits in a value, and our NOT operator. <br /><br />[Video description begins] <em>Line 5 reads as: // &#43;&#43; i, --i, ~, !.</em> [Video description ends] <br /><br />Then we have our multiplication, division, and modulo operators <br /><br />[Video description begins] <em>Line 6 reads as: // *, /, %.</em> [Video description ends]<br /><br />followed by our addition and subtraction operators. <br /><br />[Video description begins] <em>Line 7 reads as: // &#43;, -.</em> [Video description ends]</p>
<p>Next are shift operators, so the double left chevron, the double right chevron and the triple right chevron. <br /><br />[Video description begins] <em>Line 8 reads as: // &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;.</em> [Video description ends] <br /><br />Then we have our comparison operators, the less than, greater than, less than or equal to, and greater than or equal to. Then we have our equality operators. <br /><br />[Video description begins] <em>Line 9 reads as: // &lt;, &gt;, &lt;&#61;, &gt;&#61;.</em> [Video description ends] <br /><br />So equal to and not equal to.</p>
<p>Then we have our bitwise AND operator followed by our bitwise Exclusive OR <br /><br />[Video description begins] <em>Line 10 reads as: // &#61;&#61;, !&#61;.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 11 reads as: // &amp;.</em> [Video description ends]<br /><br />operator followed by our bitwise OR operator. <br /><br />[Video description begins] <em>Line 12 reads as: //^.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 13 reads as: // |.</em> [Video description ends] <br /><br />Then we have our logical AND operator and our logical OR operator. <br /><br />[Video description begins] <em>Line 14 reads as: // &amp;&amp;.</em> [Video description ends] <br /><br />[Video description begins] <em>Line 15 reads as: //||.</em> [Video description ends] <br /><br />And finally we have our equals, plus equals, minus equals, multiplication equals, division equals and modulo equals assignment operators. <br /><br />[Video description begins] <em>Line 16 reads as: // &#61;, &#43;&#61;, -&#61;, *&#61;, /&#61;, %&#61;.</em> [Video description ends]</p>
<p>So this is the table that we&#39;ll follow when determining what order something gets executed in. So let&#39;s see how this works.<br /><br />[Video description begins] <em>Line 17 reads as: //lowest.</em> [Video description ends] <br /><br />Let&#39;s look at for example int x &#61; 5 - 7 * 8.</p>
<p>The way that this will operate is Java will look for the operator with the highest precedence first. In this case, multiplication is higher on the precedence table than subtraction.</p>
<p>So 7 times 8 will be executed first, which will give us 56. And then 5 minus that result will be executed next, so we&#39;ll have 5 - 56 which will give us -51. Now, if we wanted to change that behavior, we could use parentheses. <br /><br />[Video description begins] <em>Line 19 reads as: int x &#61; 5-7 *8; // - 51.</em> [Video description ends]</p>
<p>And what parentheses will do is whatever statement is inside the parenthesis block will be executed first, regardless of whether or not that operator has a higher precedence.</p>
<p>So if I used in brackets or parentheses, (5-7)*8, this will work out differently now because whatever is within the parentheses is executed first, even though the subtraction operator has a lower precedence than the multiplication operator.</p>
<p>So for this one, 5-7 will be operated on first, which will be -2. And then that value will be multiplied by 8 to give us -16. So let&#39;s put in two print statements. <br /><br />[Video description begins] <em>Line 20 reads as: int y &#61; (5-7)* 8; // -16.</em> [Video description ends] <br /><br />To print out the values of x and the values of y to verify that they are as we expect them to be.<br /><br />[Video description begins] <em>Line 21 reads as: System.out.println(x);. Line 22 reads as: System.out.println(y);.</em> [Video description ends]</p>
<p>So let&#39;s open up a terminal and compile and run the program to make sure that everything is like we expect it to be.<br /><br />[Video description begins] <em>A Console window appears below the editor pane, showing various commands. He enters the Precedence.java.</em> [Video description ends] <br /><br />Just as we suspected the first operations without parentheses,- 51, and the second operations with parentheses equals -16.</p>
<p>So that&#39;s how we can use precedence in Java and parentheses in order to evaluate what our statements will be resulting in. We go to the precedence table, we find out which operator has the higher precedence we know that one will be operated first and then we can change that Precedence order with parentheses.</p></div></div></div><div class="section"><a name="section_13" /><h2 class="section_title">14. Video: Course Summary ( it_sdjcfa_08_enus_14)</h2><img src="https://cdn2.percipio.com/public/b/c0bced6b-02b6-4a30-a8cf-d524cbb09048/image001.jpg" alt="" width="300" onclick="(()=>document.getElementById('lb-image').src = 'https://cdn2.percipio.com/public/b/c0bced6b-02b6-4a30-a8cf-d524cbb09048/image001.jpg')();" /><div class="section_text"></div><h3 class="list_title">Objectives</h3><ul class="list"><li class="list_item">summarize the key concepts covered in this course</li></ul><div class="section inner"><div class="section_text">[Video description begins] <em>Topic title: Course Summary</em> [Video description ends]
<p>So in this course, we&#39;ve examined the available mathematical, conditional, relational, bitwise, and unary operations. We did this by exploring programming Java arithmetic, assignment, and unary operators. Programming Java equality, relational, and conditional operators. Programming bitwise operators. And programming with operator precedence in Java.</p>
<p>In our next course, we&#39;ll move on to explore working with strings and the benefits of using the StringBuffer and StringBuilder with the stack and heap memory.</p></div></div></div><div class="copyright-container"><span class="copyright-text">© 2022 Skillsoft Ireland Limited - All rights reserved.</span></div></div><div id="lb-overlay"><div class="lb-header"><button onclick="(()=>{const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'hidden';const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 1.0;curtain.style.backgroundColor = 'white';curtain.style.pointerEvents = 'auto';})();">X</button></div><div id="lb-image-container"><img id="lb-image" alt onload="(()=>{const curtain = document.getElementById('lb-curtain');curtain.style.opacity = 0.5;curtain.style.backgroundColor = 'grey';curtain.style.pointerEvents = 'none';const overlay = document.getElementById('lb-overlay');overlay.style.visibility = 'visible';window.scrollTo(0, 0);})();"/></div><div class="lb-footer" /></div></div></body></html>